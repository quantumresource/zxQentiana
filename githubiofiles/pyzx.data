# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""
This file contains rewrite rules for ZX-graphs based on the ZX-calculus.

The current rewrites are based on:

- Spider fusion.
- The bialgebra equation.
- Local Complementation.
- A few variations on Pivoting.
- Removing of identities.

Each of these rewrite rules consists of three methods:

- ``match_*`` finds a single match of the rule in a graph.
- ``match_*_parallel`` finds as many non-overlapping matches as possible.
- The final method takes a list of matches produced by these methods and returns
  a 4-tuple ``(edge_table, verts_to_remove, edges_to_remove, check_for_isolated_vertices)``.
  ``edge_table`` should be fed to :meth:`~graph.base.BaseGraph.add_edge_table`, 
  ``verts_to_remove`` to :meth:`~graph.base.BaseGraph.remove_vertices` (and similarly for ``edges_to_remove``).
  If ``check_for_isolated_vertices`` is ``True``, then 
  :meth:`~graph.base.BaseGraph.remove_isolated_vertices`
  should be called.

These rewrite rules are used in the simplification procedures of :mod:`simplify`. 
In particular, they are used in combination with :func:`simplify.simp` to create rewrite strategies.
"""

from fractions import Fraction
import itertools


def apply_rule(g, rewrite, m, check_isolated_vertices=True):
    etab, rem_verts, rem_edges, check_isolated_vertices = rewrite(g, m)
    g.add_edge_table(etab)
    g.remove_edges(rem_edges)
    g.remove_vertices(rem_verts)
    if check_isolated_vertices: g.remove_isolated_vertices()


def match_bialg(g):
    """Does the same as :func:`match_bialg_parallel` but with ``num=1``."""
    types = g.types()
    for e in g.edges():
        v0, v1 = g.edge_st(e)
        v0t = types[v0]
        v1t = types[v1]
        if ((v0t == 1 and v1t == 2) or (v0t == 2 and v1t == 1)):
            v0n = [n for n in g.neighbours(v0) if not n == v1]
            v1n = [n for n in g.neighbours(v1) if not n == v0]
            if (
                all([types[n] == v1t for n in v0n]) and
                all([types[n] == v0t for n in v1n])):
                return [[v0,v1,v0n,v1n]]
    return []


#TODO: make it be hadamard edge aware
def match_bialg_parallel(g, matchf=None, num=-1):
    """Finds noninteracting matchings of the bialgebra rule.
    
    :param g: An instance of a ZX-graph.
    :param matchf: An optional filtering function for candidate edge, should
       return True if a edge should considered as a match. Passing None will
       consider all edges.
    :param num: Maximal amount of matchings to find. If -1 (the default)
       tries to find as many as possible.
    :param edgelist: List of edges to consider. If -1 (the default), looks 
       at all edges.
    :rtype: List of 4-tuples ``(v1, v2, neighbours_of_v1,neighbours_of_v2)``
    """
    if matchf != None: candidates = set([e for e in g.edges() if matchf(e)])
    else: candidates = g.edge_set()
    types = g.types()
    
    i = 0
    m = []
    while (num == -1 or i < num) and len(candidates) > 0:
        v0, v1 = g.edge_st(candidates.pop())
        v0t = types[v0]
        v1t = types[v1]
        if ((v0t == 1 and v1t == 2) or (v0t == 2 and v1t == 1)):
            v0n = [n for n in g.neighbours(v0) if not n == v1]
            v1n = [n for n in g.neighbours(v1) if not n == v0]
            if (
                all([types[n] == v1t for n in v0n]) and
                all([types[n] == v0t for n in v1n])):
                i += 1
                for v in v0n:
                    for c in g.incident_edges(v): candidates.discard(c)
                for v in v1n:
                    for c in g.incident_edges(v): candidates.discard(c)
                m.append([v0,v1,v0n,v1n])
    return m


def bialg(g, matches):
    """Performs a certain type of bialgebra rewrite given matchings supplied by
    ``match_bialg(_parallel)``."""
    rem_verts = []
    etab = dict()
    for m in matches:
        rem_verts.append(m[0])
        rem_verts.append(m[1])
        es = [(i,j) if i < j else (j,i) for i in m[2] for j in m[3]]
        for e in es:
            if e in etab: etab[e][0] += 1
            else: etab[e] = [1,0]
    
    return (etab, rem_verts, [], True)

def match_spider(g):
    """Does the same as :func:`match_spider_parallel` but with ``num=1``."""
    for e in g.edges():
        if g.edge_type(e) != 1: continue
        v0, v1 = g.edge_st(e)
        if (g.type(v0) == g.type(v1)):
            return [[v0,v1]]
    return []

def match_spider_parallel(g, matchf=None, num=-1):
    """Finds non-interacting matchings of the spider fusion rule.
    
    :param g: An instance of a ZX-graph.
    :param matchf: An optional filtering function for candidate edge, should
       return True if a edge should considered as a match. Passing None will
       consider all edges.
    :param num: Maximal amount of matchings to find. If -1 (the default)
       tries to find as many as possible.
    :rtype: List of 2-tuples ``(v1, v2)``
    """
    if matchf != None: candidates = set([e for e in g.edges() if matchf(e)])
    else: candidates = g.edge_set()
    types = g.types()
    
    i = 0
    m = []
    while (num == -1 or i < num) and len(candidates) > 0:
        e = candidates.pop()
        if g.edge_type(e) != 1: continue
        v0, v1 = g.edge_st(e)
        v0t = types[v0]
        v1t = types[v1]
        if (v0t == v1t and v0t!=0):
                i += 1
                for v in g.neighbours(v0):
                    for c in g.incident_edges(v): candidates.discard(c)
                for v in g.neighbours(v1):
                    for c in g.incident_edges(v): candidates.discard(c)
                m.append([v0,v1])
    return m

def spider(g, matches):
    '''Performs spider fusion given a list of matchings from ``match_spider(_parallel)``
    '''
    rem_verts = []
    etab = dict()
    types = g.types()

    for m in matches:
        v0 = m[0]
        v1 = m[1]
        g.set_phase(v0, g.phase(v0) + g.phase(v1))
        if g.track_phases:
            g.fuse_phases(v0,v1)

        # always delete the second vertex in the match
        rem_verts.append(v1)

        # edges from the second vertex are transferred to the first
        for w in g.neighbours(v1):
            if v0 == w: continue
            e = (v0,w)
            if e not in etab: etab[e] = [0,0]
            etab[e][g.edge_type((v1,w))-1] += 1
    
    return (etab, rem_verts, [], True)

def unspider(g, m, qubit=-1, row=-1):
    """Undoes a single spider fusion, given a match ``m``. A match is a list with 3
    elements given by::

      m[0] : a vertex to unspider
      m[1] : the neighbours of the new node, which should be a subset of the
             neighbours of m[0]
      m[2] : the phase of the new node. If omitted, the new node gets all of the phase of m[0]

    Returns the index of the new node. Optional parameters ``qubit`` and ``row`` can be used
    to position the new node. If they are omitted, they are set as the same as the old node.
    """
    v = g.add_vertex(ty=g.type(m[0]))
    g.set_qubit(v, qubit if qubit != -1 else g.qubit(m[0]))
    g.set_row(v, row if row != -1 else g.row(m[0]))

    g.add_edge((m[0], v))
    for n in m[1]:
        e = g.edge(m[0],n)
        g.add_edge((v,n), edgetype=g.edge_type(e))
        g.remove_edge(e)
    if len(m) >= 3:
        g.add_phase(v, m[2])
        g.add_phase(m[0], Fraction(0) - m[2])
    else:
        g.set_phase(v, g.phase(m[0]))
        g.set_phase(m[0], 0)
    return v


def match_pivot(g):
    """Does the same as :func:`match_pivot_parallel` but with ``num=1``."""
    return match_pivot_parallel(g, num=1, check_edge_types=True)


def match_pivot_parallel(g, matchf=None, num=-1, check_edge_types=False):
    """Finds non-interacting matchings of the pivot rule.
    
    :param g: An instance of a ZX-graph.
    :param num: Maximal amount of matchings to find. If -1 (the default)
       tries to find as many as possible.
    :param check_edge_types: Whether the method has to check if all the edges involved
       are of the correct type (Hadamard edges).
    :param matchf: An optional filtering function for candidate edge, should
       return True if a edge should considered as a match. Passing None will
       consider all edges.
    :rtype: List of 4-tuples. See :func:`pivot` for the details.
    """
    if matchf != None: candidates = set([e for e in g.edges() if matchf(e)])
    else: candidates = g.edge_set()
    types = g.types()
    phases = g.phases()
    
    i = 0
    m = []
    while (num == -1 or i < num) and len(candidates) > 0:
        e = candidates.pop()
        if not check_edge_types and g.edge_type(e) != 2: continue
        v0, v1 = g.edge_st(e)

        if not (types[v0] == 1 and types[v1] == 1): continue

        v0a = phases[v0]
        v1a = phases[v1]
        if not ((v0a in (0,1)) and (v1a in (0,1))): continue

        invalid_edge = False

        v0n = list(g.neighbours(v0))
        v0b = []
        for n in v0n:
            et = g.edge_type(g.edge(v0,n))
            if types[n] == 1 and et == 2: pass
            elif types[n] == 0: v0b.append(n)
            else:
                invalid_edge = True
                break

        if invalid_edge: continue

        v1n = list(g.neighbours(v1))
        v1b = []
        for n in v1n:
            et = g.edge_type(g.edge(v1,n))
            if types[n] == 1 and et == 2: pass
            elif types[n] == 0: v1b.append(n)
            else:
                invalid_edge = True
                break

        if invalid_edge: continue
        if len(v0b) + len(v1b) > 1: continue

        i += 1
        for v in v0n:
            for c in g.incident_edges(v): candidates.discard(c)
        for v in v1n:
            for c in g.incident_edges(v): candidates.discard(c)
        b0 = list(v0b)
        b1 = list(v1b)
        m.append([v0,v1,b0,b1])
    return m

def match_pivot_gadget(g, matchf=None, num=-1):
    """Like :func:`match_pivot_parallel`, but except for pairings of
    Pauli vertices, it looks for a pair of an interior Pauli vertex and an
    interior non-Clifford vertex in order to gadgetize the non-Clifford vertex."""
    if matchf != None: candidates = set([e for e in g.edges() if matchf(e)])
    else: candidates = g.edge_set()
    types = g.types()
    phases = g.phases()
    rs = g.rows()
    
    edge_list = []
    i = 0
    m = []
    while (num == -1 or i < num) and len(candidates) > 0:
        e = candidates.pop()
        v0, v1 = g.edge_st(e)

        if not (types[v0] == 1 and types[v1] == 1): continue

        v0a = phases[v0]
        v1a = phases[v1]
        
        if v0a not in (0,1):
            if v1a in (0,1):
                t = v0
                v0 = v1
                v1 = t
                t = v0a
                v0a = v1a
                v1a = t
            else: continue
        elif v1a in (0,1): continue
        # Now v0 has a Pauli phase and v1 has a non-Pauli phase
        
        v0n = list(g.neighbours(v0))
        v1n = list(g.neighbours(v1))
        if len(v0n) == 1 or len(v1n) == 1: continue # one of them is a phase gadget
        bad_match = False
        discard_edges = []
        for l in (v0n, v1n):
            for n in l:
                if types[n] != 1: 
                    bad_match = True
                    break
                ne = list(g.incident_edges(n))
                if len(ne) == 1: # v0 or v1 is a phase gadget
                    bad_match = True
                    break
                discard_edges.extend(ne)
            if bad_match: break
        if bad_match: continue
                
        if any(types[w]!=1 for w in v0n): continue
        if any(types[w]!=1 for w in v1n): continue
        # Both v0 and v1 are interior
        
        v = g.add_vertex(1,-2,rs[v0],v1a)
        g.set_phase(v1, 0)
        g.set_qubit(v0,-1)
        g.update_phase_index(v1,v)
        edge_list.append((v,v1) if v<v1 else (v1,v))
        
        m.append([v0,v1,[],[v]])
        i += 1
        for c in discard_edges: candidates.discard(c)
    g.add_edges(edge_list,1)
    return m


def match_pivot_boundary(g, matchf=None, num=-1):
    """Like :func:`match_pivot_parallel`, but except for pairings of
    Pauli vertices, it looks for a pair of an interior Pauli vertex and a
    boundary non-Pauli vertex in order to gadgetize the non-Pauli vertex."""
    if matchf != None: candidates = set([v for v in g.vertices() if matchf(v)])
    else: candidates = g.vertex_set()
    types = g.types()
    phases = g.phases()
    rs = g.rows()
    
    edge_list = []
    consumed_vertices = set()
    i = 0
    m = []
    while (num == -1 or i < num) and len(candidates) > 0:
        v = candidates.pop()
        if types[v] != 1 or phases[v] not in (0,1): continue

        good_vert = True
        w = None
        bound = None
        for n in g.neighbours(v):
            if types[n] == 0: # v is on the boundary
                good_vert = False
                break
            if len(g.neighbours(n)) == 1: # v is a phase gadget
                good_vert = False
                break
            if n in consumed_vertices:
                good_vert = False
                break
            boundaries = [b for b in g.neighbours(n) if types[b]==0]
            if len(boundaries) != 1: # n is not on the boundary
                continue        #, or it is connected to both an input and an output
            if phases[n] and phases[n].denominator == 2:
                w = n
                bound = boundaries[0]
            if not w:
                w = n
                bound = boundaries[0]
        if not good_vert or not w: continue
        
        if bound in g.inputs: mod = 0.5
        else: mod = -0.5
        v1 = g.add_vertex(1,-2,rs[w]+mod,phases[w])
        v2 = g.add_vertex(1,-1,rs[w]+mod,0)
        g.set_phase(w, 0)
        g.update_phase_index(w,v1)
        edge_list.append((w,v2) if w<v2 else (v2,w))
        edge_list.append((v1,v2) if v1<v2 else (v2,v1))
        for n in g.neighbours(v): consumed_vertices.add(n)
        for n in g.neighbours(w): consumed_vertices.add(n)
        
        m.append([v,w,[],[bound]])
        i += 1
        for n in g.neighbours(v): candidates.discard(n)
        for n in g.neighbours(w): candidates.discard(n)

    g.add_edges(edge_list,2)
    return m

def pivot(g, matches):
    """Perform a pivoting rewrite, given a list of matches as returned by
    ``match_pivot(_parallel)``. A match is itself a list where:

    ``m[0]`` : first vertex in pivot.
    ``m[1]`` : second vertex in pivot.
    ``m[2]`` : list of zero or one boundaries adjacent to ``m[0]``.
    ``m[3]`` : list of zero or one boundaries adjacent to ``m[1]``.
    """
    rem_verts = []
    rem_edges = []
    etab = dict()
    for m in matches:
        # compute:
        #  n[0] <- non-boundary neighbours of m[0] only
        #  n[1] <- non-boundary neighbours of m[1] only
        #  n[2] <- non-boundary neighbours of m[0] and m[1]
        g.update_phase_index(m[0],m[1])
        n = [set(g.neighbours(m[0])), set(g.neighbours(m[1]))]
        for i in range(2):
            n[i].remove(m[1-i])
            if len(m[i+2]) == 1: n[i].remove(m[i+2][0])
        n.append(n[0] & n[1])
        n[0] = n[0] - n[2]
        n[1] = n[1] - n[2]
        es = ([(s,t) if s < t else (t,s) for s in n[0] for t in n[1]] +
              [(s,t) if s < t else (t,s) for s in n[1] for t in n[2]] +
              [(s,t) if s < t else (t,s) for s in n[0] for t in n[2]])
        
        for v in n[2]: g.add_to_phase(v, 1)

        for i in range(2):
            # if m[i] has a phase, it will get copied on to the neighbours of m[1-i]:
            a = g.phase(m[i])
            for v in n[1-i]: g.add_to_phase(v, a)
            for v in n[2]: g.add_to_phase(v, a)


            if not m[i+2]:
                # if there is no boundary, the other vertex is destroyed
                rem_verts.append(m[1-i])
            else:
                # if there is a boundary, toggle whether it is an h-edge or a normal edge
                # and point it at the other vertex
                e = g.edge(m[i], m[i+2][0])
                new_e = (m[1-i], m[i+2][0])
                if new_e[0] > new_e[1]: new_e = (new_e[1],new_e[0])
                ne,nhe = etab.get(new_e, (0,0))
                if g.edge_type(e) == 1: nhe += 1
                elif g.edge_type(e) == 2: ne += 1
                etab[new_e] = (ne,nhe)
                rem_edges.append(e)


        for e in es:
            nhe = etab.get(e, (0,0))[1]
            etab[e] = (0,nhe+1)

    return (etab, rem_verts, rem_edges, True)

def match_lcomp(g):
    """Same as :func:`match_lcomp_parallel`, but with ``num=1``"""
    return match_lcomp_parallel(g, num=1, check_edge_types=True)

def match_lcomp_parallel(g, vertexf=None, num=-1, check_edge_types=False):
    """Finds noninteracting matchings of the local complementation rule.
    
    :param g: An instance of a ZX-graph.
    :param num: Maximal amount of matchings to find. If -1 (the default)
       tries to find as many as possible.
    :param check_edge_types: Whether the method has to check if all the edges involved
       are of the correct type (Hadamard edges).
    :param vertexf: An optional filtering function for candidate vertices, should
       return True if a vertex should be considered as a match. Passing None will
       consider all vertices.
    :rtype: List of 2-tuples ``(vertex, neighbours)``.
    """
    if vertexf != None: candidates = set([v for v in g.vertices() if vertexf(v)])
    else: candidates = g.vertex_set()
    types = g.types()
    phases = g.phases()
    
    i = 0
    m = []
    while (num == -1 or i < num) and len(candidates) > 0:
        v = candidates.pop()
        vt = types[v]
        va = g.phase(v)
        
        if not (va == Fraction(1,2) or va == Fraction(3,2)): continue

        if check_edge_types and not (
            all(g.edge_type(e) == 2 for e in g.incident_edges(v))
            ): continue
                
        vn = list(g.neighbours(v))

        if not all(types[n] == vt for n in vn): continue # and phases[n].denominator <= 2

        for n in vn: candidates.discard(n)
        m.append([v,vn])
    return m

def lcomp(g, matches):
    """Performs a local complementation based rewrite rule on the given graph with the
    given ``matches`` returned from ``match_lcomp(_parallel)``. See *insert paper here* 
    for more details on the rewrite"""
    etab = dict()
    rem = []
    for m in matches:
        a = g.phase(m[0])
        rem.append(m[0])
        for i in range(len(m[1])):
            g.add_to_phase(m[1][i], -a)
            for j in range(i+1, len(m[1])):
                e = (m[1][i],m[1][j])
                if (e[0] > e[1]): e = (e[1],e[0])
                he = etab.get(e, (0,0))[1]
                etab[e] = (0, he+1)

    return (etab, rem, [], False)


def match_ids(g):
    """Finds a single identity node. See :func:`match_ids_parallel`."""
    return match_ids_parallel(g, num=1)

def match_ids_parallel(g, vertexf=None, num=-1):
    """Finds non-interacting identity vertices.
    
    :param g: An instance of a ZX-graph.
    :param num: Maximal amount of matchings to find. If -1 (the default)
       tries to find as many as possible.
    :param vertexf: An optional filtering function for candidate vertices, should
       return True if a vertex should be considered as a match. Passing None will
       consider all vertices.
    :rtype: List of 4-tuples ``(identity_vertex, neighbour1, neighbour2, edge_type)``.
    """
    if vertexf != None: candidates = set([v for v in g.vertices() if vertexf(v)])
    else: candidates = g.vertex_set()
    types = g.types()
    phases = g.phases()

    i = 0
    m = []

    while (num == -1 or i < num) and len(candidates) > 0:
        v = candidates.pop()
        if phases[v] != 0: continue
        neigh = g.neighbours(v)
        if len(neigh) != 2: continue
        v0, v1 = neigh
        candidates.discard(v0)
        candidates.discard(v1)
        if g.edge_type((v,v0)) != g.edge_type((v,v1)): #exactly one of them is a hadamard edge
            m.append((v,v0,v1,2))
        else: m.append((v,v0,v1,1))
        i += 1
    return m

def remove_ids(g, matches):
    """Given the output of ``match_ids(_parallel)``, returns a list of edges to add,
    and vertices to remove."""
    etab = dict()
    rem = []
    for m in matches:
        rem.append(m[0])
        e = (m[1],m[2])
        if not e in etab: etab[e] = [0,0]
        etab[e][m[3]-1] += 1
    return (etab, rem, [], False)
    


def match_phase_gadgets(g):
    """Determines which phase gadgets act on the same vertices, so that they can be fused together.
    
    :param g: An instance of a ZX-graph.
    :rtype: List of 5-tuples ``(axel,leaf, total combined phase, other axels with same targets, other leafs)``.
    """
    phases = g.phases()

    parities = dict()
    gadgets = dict()
    # First we find all the phase-gadgets, and the list of vertices they act on
    for v in g.vertices():
        if phases[v] != 0 and phases[v].denominator > 2 and len(list(g.neighbours(v)))==1:
            n = list(g.neighbours(v))[0]
            gadgets[n] = v
            par = frozenset(set(g.neighbours(n)).difference({v}))
            if par in parities: parities[par].append(n)
            else: parities[par] = [n]

    m = []
    for par, gad in parities.items():
        if len(gad) == 1: 
            n = gad[0]
            v = gadgets[n]
            if phases[n] != 0: # If the phase of the axel vertex is pi, we change the phase of the gadget
                g.phase_negate(v)
                m.append((v,n,-phases[v],[],[]))
        else:
            totphase = sum((1 if phases[n]==0 else -1)*phases[gadgets[n]] for n in gad)%2
            for n in gad:
                if phases[n] != 0:
                    g.phase_negate(gadgets[n])
            n = gad.pop()
            v = gadgets[n]
            m.append((v,n,totphase, gad, [gadgets[n] for n in gad]))
    return m

def merge_phase_gadgets(g, matches):
    """Given the output of :func:``match_phase_gadgets``, removes phase gadgets that act on the same set of targets."""
    rem = []
    for v, n, phase, othergadgets, othertargets in matches:
        g.set_phase(v, phase)
        g.set_phase(n, 0)
        rem.extend(othergadgets)
        rem.extend(othertargets)
        for w in othertargets:
            g.fuse_phases(v,w)
    return ({}, rem, [], False)




def match_gadgets_phasepoly(g):
    """Finds groups of phase-gadgets that act on the same set of 4 vertices in order to apply a rewrite based on
    rule R_13 of the paper *A Finite Presentation of CNOT-Dihedral Operators*.""" 
    targets = {}
    gadgets = {}
    for v in g.vertices():
        if v not in g.inputs and v not in g.outputs and len(list(g.neighbours(v)))==1:
            if g.phase(v) != 0 and g.phase(v).denominator != 4: continue
            n = list(g.neighbours(v))[0]
            tgts = frozenset(set(g.neighbours(n)).difference({v}))
            if len(tgts)>4: continue
            gadgets[tgts] = (n,v)
            for t in tgts:
                if t in targets: targets[t].add(tgts)
                else: targets[t] = {tgts}
        if g.phase(v) != 0 and g.phase(v).denominator == 4:
            if v in targets: targets[v].add(frozenset([v]))
            else: targets[v] = {frozenset([v])}
    targets = {t:s for t,s in targets.items() if len(s)>1}
    matches = {}

    for v1,t1 in targets.items():
        s = t1.difference(frozenset([v1]))
        if len(s) == 1:
            c = s.pop()
            if any(len(targets[v2])==2 for v2 in c): continue
        s = t1.difference({frozenset({v1})})
        for c in [d for d in s if not any(d.issuperset(e) for e in s if e!=d)]:
            if not all(v2 in targets for v2 in c): continue
            if any(v2<v1 for v2 in c): continue
            a = set()
            for t in c: a.update([i for s in targets[t] for i in s if i in targets])
            for group in itertools.combinations(a.difference(c),4-len(c)):
                group = list(group)+list(c)
                a = set()
                for t in group: a.update([s for s in targets[t] if s.issubset(group)])
                if len(a)>7:
                    matches[frozenset(group)] = a

    m = []
    taken = set()
    for group, gad in sorted(matches.items(), key=lambda a: len(a[1]), reverse=True):
        if taken.intersection(group): continue
        m.append((list(group), {s:(gadgets[s] if len(s)>1 else list(s)[0]) for s in gad}))
        taken.update(group)

    return m


def apply_gadget_phasepoly(g, matches):
    """Uses the output of :func:`match_gadgets_phasepoly` to apply a rewrite based 
    on rule R_13 of the paper *A Finite Presentation of CNOT-Dihedral Operators*.""" 
    rs = g.rows()
    phases = g.phases()
    for group, gadgets in matches:
        for i in range(4):
            v1 = group[i]
            g.add_to_phase(v1, Fraction(5,4))
            
            for j in range(i+1,4):
                v2 = group[j]
                f = frozenset({v1,v2})
                if f in gadgets:
                    n,v = gadgets[f]
                    phase = phases[v]
                    if phases[n]:
                        phase = -phase
                        g.set_phase(n,0)
                else:
                    n = g.add_vertex(1,-1, rs[v2]+0.5)
                    v = g.add_vertex(1,-2, rs[v2]+0.5)
                    phase = 0
                    g.add_edges([(n,v),(v1,n),(v2,n)],2)
                g.set_phase(v, phase + Fraction(3,4))

                for k in range(j+1,4):
                    v3 = group[k]
                    f = frozenset({v1,v2,v3})
                    if f in gadgets:
                        n,v = gadgets[f]
                        phase = phases[v]
                        if phases[n]:
                            phase = -phase
                            g.set_phase(n,0)
                    else:
                        n = g.add_vertex(1,-1, rs[v3]+0.5)
                        v = g.add_vertex(1,-2, rs[v3]+0.5)
                        phase = 0
                        g.add_edges([(n,v),(v1,n),(v2,n),(v3,n)],2)
                    g.set_phase(v, phase + Fraction(1,4))
        f = frozenset(group)
        if f in gadgets:
            n,v = gadgets[f]
            phase = phases[v]
            if phases[n]:
                phase = -phase
                g.set_phase(n,0)
        else:
            n = g.add_vertex(1,-1, rs[group[0]]+0.5)
            v = g.add_vertex(1,-2, rs[group[0]]+0.5)
            phase = 0
            g.add_edges([(n,v)]+[(n,w) for w in group],2)
        g.set_phase(v, phase + Fraction(7,4))# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.


"""This module implements the Third Order Duplicate and Destroy algorithm
from Luke E Heyfron and Earl T Campbell 2019 Quantum Sci. Technol. 4 015004
available at http://iopscience.iop.org/article/10.1088/2058-9565/aad604/meta"""

from __future__ import print_function

from fractions import Fraction
import subprocess
import tempfile
import time
import random
try:
    import numpy as np
except:
    np = None

from .circuit import T, S, Z, ZPhase, CZ, CNOT, ParityPhase
from .linalg import Mat2, column_optimal_swap
from .extract import permutation_as_swaps
from .phasepoly import parity_network

TOPT_LOCATION = None
USE_REED_MULLER = False


class ParityPolynomial:
    """Class used to represent phase polynomials in the standard
    ParityPhase view. For example: x1@x2 + 3x2 + 5x1@x2@x3"""
    def __init__(self,qubits, poly=None):
        self.qubits = qubits
        if poly:
            self.terms = poly.terms.copy()
        else: self.terms = {}
    
    def copy(self):
        return type(self)(self.qubits, self)
    
    def __str__(self):
        l = []
        for t in sorted(self.terms.keys()):
            val = self.terms[t]
            l.append("{!s}{}".format(val if val!=1 else "", "@".join("x{:d}".format(v) for v in sorted(list(t)))))
        return " + ".join(l)
    
    def __repr__(self):
        return str(self)
    
    def add_term(self, term, value):
        term = tuple(sorted(term))
        if term in self.terms:
            self.terms[term] = (self.terms[term] + value) % 8
        else: self.terms[term] = value % 8
        if not self.terms[term]:
            del self.terms[term]
    
    def add_polynomial(self, poly):
        for term, val in poly.terms.items():
            self.add_term(term, val)
    
    def __add__(self, other):
        p = self.copy()
        p.add_polynomial(other)
        return p
    
    def to_par_matrix(self):
        """Converts the phase polynomial into a parity matrix."""
        cols = []
        for par, val in self.terms.items():
            col = [1 if i in par else 0 for i in range(self.qubits)]
            for i in range(val): cols.append(col)
        return Mat2(cols).transpose()

class ParitySingle:
    """Class used for representing a single parity expression
    like x1@x2@x4"""
    def __init__(self,startval):
        self.par = {startval}
    
    def __str__(self):
        return "@".join("x{:d}".format(i) for i in sorted(self.par))
    
    def __repr__(self):
        return str(self)
    
    def add_par(self, other):
        self.par.symmetric_difference_update(other.par)


class MultiLinearPoly:
    """Class for representing phase polynomials in the multilinear formalism.
    For example: x1 + x2 + 2x1x2 + 4x1x2x3"""
    def __init__(self):
        self.l = {}
        self.q = {}
        self.c = set()
    
    def add_parity(self, par, subtract=False):
        p = []
        mult = -1 if subtract else 1
        for i,v in enumerate(par):
            if v: p.append(i)
        for a in range(len(p)):
            v1 = p[a]
            if v1 not in self.l: self.l[v1] = mult
            else: self.l[v1] = (self.l[v1] + mult) % 8
            
            for b in range(a+1, len(p)):
                v2 = p[b]
                if (v1,v2) not in self.q: self.q[(v1,v2)] = 1 if subtract else 3
                else: self.q[(v1,v2)] = (self.q[(v1,v2)] - mult) % 4
                    
                for c in range(b+1, len(p)):
                    v3 = p[c]
                    if (v1,v2,v3) not in self.c: self.c.add((v1,v2,v3))
                    else: self.c.remove((v1,v2,v3))
    
    def add_par_matrix(self, a, subtract=False):
        for col in a.transpose().data:
            self.add_parity(col,subtract=subtract)
    
    def to_clifford(self):
        """Returns the phase polynomial in terms of Clifford Z-rotations 
        and CZs. If the phase polyomial is not Clifford it raises an ValueError."""
        gates = []
        for t, v in self.l.items():
            if v == 2:
                gates.append(S(t,adjoint=False))
            elif v == 4:
                gates.append(Z(t))
            elif v == 6:
                gates.append(S(t,adjoint=True))
            elif v != 0:
                raise ValueError("PhasePoly is not Clifford")
        for (t1,t2), v in self.q.items():
            if v == 2:
                gates.append(CZ(t1,t2))
            elif v != 0:
                raise ValueError("PhasePoly is not Clifford")
        if self.c:
            raise ValueError("PhasePoly is not Clifford")
        return gates


def par_matrix_to_gates(a):
    """Convert a parity matrix into T gates and ParityPhase gates."""
    gates = []
    phase = Fraction(1,4)
    for col in a.transpose().data:
        targets = [i for i,v in enumerate(col) if v]
        if len(targets) == 1:
            gates.append(T(targets[0]))
        else:
            gates.append(ParityPhase(phase, *targets))
    return gates

def phase_gates_to_poly(gates, qubits):
    """Convert a CNOT+T+CZ circuit into a phase polynomial representation
    using :class:`ParityPolynomial`."""
    phase_poly = ParityPolynomial(qubits)
    expression_polys = []
    for i in range(qubits):
        expression_polys.append(ParitySingle(i))
    
    for g in gates:
        if isinstance(g, ZPhase):
            par = expression_polys[g.target].par
            phase_poly.add_term(par, int(g.phase*4))
        elif isinstance(g, CZ):
            tgt, ctrl = g.target, g.control
            par1 = expression_polys[tgt].par
            par2 = expression_polys[ctrl].par
            phase_poly.add_term(par1, 2)
            phase_poly.add_term(par2, 2)
            phase_poly.add_term(par1.symmetric_difference(par2), 6)
        elif isinstance(g, CNOT):
            tgt, ctrl = g.target, g.control
            expression_polys[tgt].add_par(expression_polys[ctrl])
        else:
            raise TypeError("Unknown gate type {}".format(str(g)))
    
    return phase_poly, expression_polys



def xi(m, z):
    """Constructs the \chi matrix from the TOpt paper."""
    arr = np.asarray(m.data)
    rows = m.rows()
    data = []
    for alpha in range(rows):
        ra = arr[alpha]
        for beta in range(alpha+1, rows):
            rb = arr[beta]
            rab = ra*rb
            for gamma in range(beta+1, rows):
                rg = arr[gamma]
                if z[alpha]:
                    rbg = rb*rg
                    if not z[beta]:
                        if not z[gamma]:
                            data.append(rbg.tolist())
                            continue
                        data.append(((rbg+rab)%2).tolist())
                        continue
                    elif not z[gamma]:
                        rag = ra*rg
                        data.append(((rbg+rag)%2).tolist())
                        continue
                    else: #z[alpha], z[beta] and z[gamma] are all true
                        rag = ra*rg
                        data.append(((rab+rag+rbg)%2).tolist())
                        continue
                elif z[beta]:
                    rag = ra*rg
                    if z[gamma]:
                        data.append(((rab+rag)%2).tolist())
                        continue
                    data.append(rag.tolist())
                    continue
                elif z[gamma]:
                    data.append(rab.tolist())
                    continue
    for r in m.data: data.append(r.copy())            
    return Mat2(data)


def find_todd_match(m):
    """Tries to find a match for the TODD algorithm given a parity matrix."""
    rows = m.rows()
    cols = m.cols()
    for a in range(cols):
        for b in range(a+1, cols):
            z = [0]*rows
            for i in range(rows):
                r = m.data[i]
                if r[a]:
                    if not r[b]:
                        z[i] = 1
                else:
                    if r[b]:
                        z[i] = 1
            bigm = xi(m, z)
            #print(bigm, '.')
            options = bigm.nullspace(should_copy=False)
            #print(bigm)
            for y in options:
                if y[a] + y[b] == 1: return a,b,z,y

    return -1,-1,None,None


def remove_trivial_cols(m):
    """Remove duplicate and zero columns in parity matrix.
    NOTE: the transpose of the matrix should be supplied
    so that the columns are actually the rows."""
    while True:
        newcols = m.rows()
        for a in range(newcols):
            if not any(m.data[a]):
                m.data.pop(a)
                break
            should_break = False
            for b in range(a+1, newcols):
                if m.data[a] == m.data[b]:
                    m.data.pop(b)
                    m.data.pop(a)
                    should_break = True
                    break
            if should_break: break
        else: # Didn't break out of for-loop so didn't find any match
            break
    return newcols

def do_todd_single(m):
    """Find a single TODD match and apply it to the matrix."""
    startcols = m.cols()
    a,b,z,y = find_todd_match(m)
    if not z: return m, 0
    m = m.transpose()
    #odd_y = sum(y) % 2
    for i,c in enumerate(m.data):
        if not y[i]: continue
        for j in range(len(c)):
            if z[j]: c[j] = 0 if c[j] else 1
    if sum(y) % 2 == 1:
        m.data.append(z)
    m.data.pop(b)
    m.data.pop(a)
    
    newcols = remove_trivial_cols(m)
                
    return m.transpose(), startcols - newcols

def todd_iter(m, quiet=True):
    """Keep finding TODD matches until nothing is found anymore.
    If TOPT_LOCATION is given it uses the TOpt implementation of TODD. """
    m = m.transpose()
    remove_trivial_cols(m)
    random.shuffle(m.data) # Randomly shuffle the columns
    m = m.transpose()
    if not m.cols() or not m.rows():
        return m
    if TOPT_LOCATION:
        return call_topt(m, quiet=quiet)
    while True:
        m, reduced = do_todd_single(m)
        if not reduced:
            if not quiet: print()
            return m
        if not quiet: print(reduced, end='.')

def call_topt(m, quiet=True):
    """Calls and parses the output of the TOpt implementation of TODD."""
    if not quiet:
        print("TOpt: ", end="")
    t_start = m.cols()
    s = "\n".join(" ".join(str(i) for i in r) for r in m.data)
    with tempfile.NamedTemporaryFile(suffix='.gsm') as f:
        f.write(s.encode('ascii'))
        f.flush()
        time.sleep(0.01)
        if TOPT_LOCATION[0].find('wsl') != -1:
            fname = "/mnt/c"+f.name.replace("\\", "/")[2:]
        else: fname = f.name
        if USE_REED_MULLER:
            out = subprocess.check_output([*TOPT_LOCATION, "gsm",fname, "-a", "rm"])
        else:
            out = subprocess.check_output([*TOPT_LOCATION, "gsm",fname])
        out = out.decode()
        #print(out)
    rows = out[out.find("Output gate"):out.find("Successful")].strip().splitlines()[2:]
    i = out.find("Total time")
    t = out[i+10: out.find("s",i)]
    if not quiet:
        print(t)
    data = []
    try:
        for row in rows:
            data.append([int(i) for i in row])
    except ValueError:
        print(out)
        print(rows)
        raise
    m2 = Mat2(data)
    if USE_REED_MULLER:
        m = m2.transpose()
        remove_trivial_cols(m)
        m2 = m.transpose()
    t_end = m2.cols()
    if t_end < t_start:
        if not quiet: print("Found reduction: ", t_start - t_end)
        # print("Start:")
        # print(m)
        # print("End:")
        # print(m2)
        #print(out)
    return m2


def todd_simp(gates, qubits, quiet=True):
    """Run the TODD algorithm on a CNOT+CZ+T set of gates and 
    apply the necessary Clifford corrections. Uses the 
    CNOT parity algorithm from https://arxiv.org/pdf/1712.01859.pdf
    to synthesize the necessary parities."""
    phase_poly, parity_polys = phase_gates_to_poly(gates, qubits)
    #print(phase_poly)
    #print(parity_polys)
    m = phase_poly.to_par_matrix()
    m2 = todd_iter(m,quiet=quiet)

    newgates = []
    parities = []
    for col in m2.transpose().data:
        if sum(col) == 1:
            newgates.append(T(next(i for i in range(qubits) if col[i])))
        else:
            parities.append(col)

    p = MultiLinearPoly()
    p.add_par_matrix(m,False)
    p.add_par_matrix(m2,True)
    newgates.extend(p.to_clifford())

    cnots = parity_network(qubits, parities)
    m = Mat2.id(qubits)
    for cnot in cnots:
        m.row_add(cnot.control, cnot.target)
    data = []
    for p in parity_polys:
        l = [int(i in p.par) for i in range(qubits)]
        data.append(l)
    target_matrix = Mat2(data) * m.inverse()
    #perm = column_optimal_swap(target_matrix.transpose())
    perm = {i:i for i in range(qubits)}
    swaps = permutation_as_swaps(perm)
    for a,b in swaps:
        target_matrix.row_swap(a,b)
    gates = target_matrix.to_cnots(optimize=True)
    for gate in reversed(gates):
        cnots.append(CNOT(gate.target,gate.control))

    m = Mat2.id(qubits)
    for i, cnot in enumerate(cnots):
        newgates.append(cnot)
        m.row_add(cnot.control, cnot.target)
        for par in parities:
            if par in m.data: # The parity checks out, so put a phase here
                newgates.append(T(m.data.index(par)))
                parities.remove(par)
                break

    if parities:
        raise ValueError("Still phases left on the stack")

    return newgates, {v:k for k,v in perm.items()}


def todd_on_graph(g):
    """Runs the TODD algorithm on a graph. The variables are determined
    by looking at which vertices have phase gadgets attached to them.
    Note that this produces graphs that can only be transformed into circuits
    using ancilla qubits."""
    gadgets = {}
    t_nodes = []
    for v in g.vertices():
        if v not in g.inputs and v not in g.outputs and len(list(g.neighbours(v)))==1:
            if g.phase(v) != 0 and g.phase(v).denominator != 4: continue
            n = list(g.neighbours(v))[0]
            tgts = frozenset(set(g.neighbours(n)).difference({v}))
            gadgets[tgts] = (n,v)
        if g.phase(v) != 0 and g.phase(v).denominator == 4:
            t_nodes.append(v)
    
    if not gadgets:
        print("No phase gadgets found")
        return
    variables = set()
    for par in gadgets.keys():
        variables.update(par)
    
    for v in variables:
        if v in t_nodes:
            gadgets[frozenset({v})] = (v,v)
    
    targets = list(variables)
    n = len(targets)

    cols = []
    for par, (_,v) in gadgets.items():
        col = [0]*n
        for t in par:
            col[targets.index(t)] = 1
        phase = g.phase(v)
        for i in range(phase.numerator): cols.append(col)
    parmatrix = Mat2(cols).transpose()
    m2 = todd_iter(parmatrix)
    
    newgadgets = []
    phases = dict()
    for col in m2.transpose().data:
        if sum(col) == 1:
            i = next(i for i,a in enumerate(col) if a)
            v = targets[i]
            if v in t_nodes:
                phases[v] = Fraction(1,4)
            else:
                phases[v] = g.phase(v) + Fraction(1,4)
        else:
            newgadgets.append(frozenset([targets[i] for i,a in enumerate(col) if a]))
    
    p = MultiLinearPoly()
    p.add_par_matrix(parmatrix,False)
    p.add_par_matrix(m2,True)
    correction = p.to_clifford()
    add_czs = {}
    for clif in correction:
        if isinstance(clif, ZPhase):
            v = targets[clif.target]
            if v in phases:
                phases[v] += clif.phase
            else:
                if v in t_nodes:
                    phases[v] = clif.phase
                else:
                    phases[v] = g.phase(v) + clif.phase
        elif clif.name == 'CZ':
            v1,v2 = targets[clif.control], targets[clif.target]
            add_czs[(v1,v2)] = (0,1)
        else:
            raise ValueError("Unknown clifford correction:", str(clif))
    
    for v in targets:
        if v in phases:
            g.set_phase(v, phases[v])
        else:
            if v in t_nodes:
                g.set_phase(v, 0)
    g.add_edge_table(add_czs)
    
    rs = g.rows()
    positions = set()
    for gadget, (n,v) in gadgets.items():
        if len(gadget) == 1: continue # T-node
        if gadget in newgadgets:
            positions.add(rs[v])
            g.set_phase(v, Fraction(1,4))
            newgadgets.remove(gadget)
        else:
            g.remove_vertices((n,v))
    
    edges = []
    for par in newgadgets:
        pos = sum(rs[t] for t in par)/len(par) + 0.5
        while pos in positions: pos += 0.5
        n = g.add_vertex(1, -1, pos)
        v = g.add_vertex(1, -2, pos, phase=Fraction(1,4))
        edges.append((n,v))
        positions.add(pos)
        for t in par: edges.append((n,t))
    g.add_edges(edges, 2)# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import json
from fractions import Fraction

from .graph.graph import Graph
from .simplify import id_simp

def _quanto_value_to_phase(s):
    if not s: return Fraction(0)
    if r'\pi' in s:
        try:
            r = s.replace(r'\pi','').strip()
            if r.startswith('-'): r = "-1"+r[1:]
            if r.startswith('/'): r = "1"+r
            return Fraction(str(r)) if r else Fraction(1)
        except ValueError:
            raise ValueError("Invalid phase '{}'".format(s))
    return s

def _phase_to_quanto_value(p):
    if not p: return ""
    if isinstance(p, Fraction):
        if p.numerator == -1: v = "-"
        elif p.numerator == 1: v = ""
        else: v = str(p.numerator)
        d = "/"+str(p.denominator) if p.denominator!=1 else ""
        return r"{}\pi{}".format(v,d)
    else: return p
    # if not n: return ""
    # s = str(float(n))
    # return s + r"\pi"


def json_to_graph(js):
    """Converts the json representation of a .qgraph Quantomatic graph into
    a pyzx graph."""
    j = json.loads(str(js))
    g = Graph()
    v = 0
    names = {}
    hadamards = {}
    for name,attr in j.get('node_vertices',{}).items():
        if 'data' in attr and 'type' in attr['data'] and attr['data']['type'] == "hadamard":
            hadamards[name] = []
            continue
        c = attr['annotation']['coord']
        q, r = -c[1], c[0]
        if q == int(q): q = int(q)
        if r == int(r): r = int(r)
        g.add_vertex(qubit=q, row=r)
        g.set_vdata(v,'name',name)
        names[name] = v
        if 'data' in attr:
            d = attr['data']
            if not 'type' in d or d['type'] == 'Z': g.set_type(v,1)
            elif d['type'] == 'X': g.set_type(v,2)
            else: raise TypeError("unsupported type '{}'".format(d['type']))
            if 'value' in d:
                g.set_phase(v,_quanto_value_to_phase(d['value']))
            else:
                g.set_phase(v,Fraction(0,1))
        else:
            g.set_type(v,1)
            g.set_phase(v,Fraction(0,1))
        
        #g.set_vdata(v, 'x', c[0])
        #g.set_vdata(v, 'y', c[1])
        v += 1
    for name,attr in j.get('wire_vertices',{}).items():
        ann = attr['annotation']
        c = ann['coord']
        q, r = -c[1], c[0]
        if q == int(q): q = int(q)
        if r == int(r): r = int(r)
        g.add_vertex(0,q,r)
        g.set_vdata(v,'name',name)
        names[name] = v
        if "input" in ann and ann["input"]: g.inputs.append(v)
        if "output" in ann and ann["output"]: g.outputs.append(v)
        #g.set_vdata(v, 'x', c[0])
        #g.set_vdata(v, 'y', c[1])
        v += 1

    edges = {}
    for edge in j.get('undir_edges',{}).values():
        n1, n2 = edge['src'], edge['tgt']
        if n1 in hadamards and n2 in hadamards: #Both 
            g.add_vertex(ty=1)
            name = "v"+str(len(names))
            g.set_vdata(v, 'name',name)
            names[name] = v
            hadamards[n1].append(v)
            hadamards[n2].append(v)
            v+=1
            continue
        if n1 in hadamards: 
            hadamards[n1].append(names[n2])
            continue
        if n2 in hadamards:
            hadamards[n2].append(names[n1])
            continue

        v = edges.get((names[n1],names[n2]),[0,0])
        v[0] += 1
        edges[(names[n1],names[n2])] = v

    for l in hadamards.values():
        if len(l) != 2: raise TypeError("Can't parse graphs with irregular Hadamard nodes")
        v = edges.get(tuple(l),[0,0])
        v[1] += 1
        edges[tuple(l)] = v
    g.add_edge_table(edges)

    return g

def graph_to_json(g):
    """Converts a PyZX graph into JSON output compatible with Quantomatic."""
    node_vs = {}
    wire_vs = {}
    edges = {}
    names = {}
    freenamesv = ["v"+str(i) for i in range(g.num_vertices()+g.num_edges())]
    freenamesb = ["b"+str(i) for i in range(g.num_vertices())]
    for v in g.vertices():
        t = g.type(v)
        coord = [g.row(v),-g.qubit(v)]
        name = g.vdata(v, 'name')
        if not name:
            if t == 0: name = freenamesb.pop(0)
            else: name = freenamesv.pop(0)
        else: 
            try:
                freenamesb.remove(name) if t==0 else freenamesv.remove(name)
            except:
                pass
                #print("couldn't remove name '{}'".format(name))
        
        names[v] = name
        if t == 0:
            wire_vs[name] = {"annotation":{"boundary":True,"coord":coord,
                                           "input":(v in g.inputs), "output":(v in g.outputs)}}
        else:
            node_vs[name] = {"annotation": {"coord":coord},"data":{}}
            if t==2: node_vs[name]["data"]["type"] = "X"
            elif t==1:node_vs[name]["data"]["type"] = "Z"
            elif t!=1: raise Exception("Unkown type "+ str(t))
            phase = _phase_to_quanto_value(g.phase(v))
            if phase: node_vs[name]["data"]["value"] = phase
            if not node_vs[name]["data"]: del node_vs[name]["data"]

    i = 0
    for e in g.edges():
        src,tgt = g.edge_st(e)
        t = g.edge_type((src,tgt))
        if t == 1:
            edges["e"+ str(i)] = {"src": names[src],"tgt": names[tgt]}
            i += 1
        elif t==2: #hadamard edge
            x1,y1 = g.row(src), -g.qubit(src)
            x2,y2 = g.row(tgt), -g.qubit(tgt)
            hadname = freenamesv.pop(0)
            node_vs[hadname] = {"annotation": {"coord":[(x1+x2)/2.0,(y1+y2)/2.0]},
                             "data": {"type": "hadamard"}}
            edges["e"+str(i)] = {"src": names[src],"tgt": hadname}
            i += 1
            edges["e"+str(i)] = {"src": names[tgt],"tgt": hadname}
            i += 1
        else:
            raise TypeError("Edge of type 0")


    return json.dumps({"wire_vertices": wire_vs, 
            "node_vertices": node_vs, 
            "undir_edges": edges})# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

from .circuit import Circuit, ZPhase, XPhase, CNOT, CZ, ParityPhase, NOT, HAD, SWAP, S, Z
from .extract import permutation_as_swaps
from .todd import todd_simp

__all__ = ['basic_optimization', 'phase_block_optimize']

def full_optimize(circuit, quiet=True):
    c = basic_optimization(circuit.to_basic_gates())
    c = phase_block_optimize(c, quiet=quiet)
    return basic_optimization(c.to_basic_gates())

def basic_optimization(circuit, do_swaps=True, quiet=True):
    if not isinstance(circuit, Circuit):
        raise TypeError("Input must be a Circuit")
    o = Optimizer(circuit)
    return o.parse_circuit(do_swaps=do_swaps,quiet=quiet)

def toggle_element(l, e):
    if e in l: l.remove(e)
    else: l.append(e)

def swap_element(l, e1, e2):
    if e1 in l and e2 not in l:
        l.remove(e1)
        l.append(e2)
    elif e2 in l and e1 not in l:
        l.remove(e2)
        l.append(e1)

def stats(circ):
    two_qubit = 0
    had = 0
    non_pauli = 0
    for g in circ.gates:
        if g.name in ('CZ', 'CNOT'):
            two_qubit += 1
        elif g.name == 'HAD':
            had += 1
        elif g.name != 'NOT' and g.phase != 1:
            non_pauli += 1
    return had, two_qubit, non_pauli

class Optimizer:
    def __init__(self, circuit):
        self.circuit = circuit
        self.qubits = circuit.qubits
        self.minimize_czs = False
    
    def parse_circuit(self, separate_correction=False, max_iterations=1000, do_swaps=True, quiet=True):
        """Repeatedly does forward and backward passes trough the circuit, 
        until no more improvements are found.
        When ``separate_correction`` is True, it returns the list of NOT, Z and SWAP gates that is 
        has collected at the end separately.

        When ``do_swaps`` is set to False, it does not apply the rule 
        CNOT(r1,r2)CNOT(r2,r1) = CNOT(r1,r2)SWAP, so that the connectivity of the circuit is preserved,
        in case the circuit already had been mapped."""
        self.do_swaps = do_swaps
        self.minimize_czs = False
        self.circuit, correction = self.parse_forward()
        count = stats(self.circuit)
        for g in correction: self.circuit.gates.extend(g.to_basic_gates())
        i = 0
        while True:
            self.circuit.gates = list(reversed(self.circuit.gates))
            self.circuit, correction = self.parse_forward()
            for g in correction: self.circuit.gates.extend(g.to_basic_gates())
            self.circuit.gates = list(reversed(self.circuit.gates))
            self.circuit, correction = self.parse_forward()
            i += 1
            s = stats(self.circuit)
            if self.minimize_czs and (all(s1<=s2 for s1,s2 in zip(count,s)) or i>=max_iterations): break
            for g in correction: self.circuit.gates.extend(g.to_basic_gates())
            if not quiet:
                print(i, end='.')
            count = s
            self.minimize_czs = True
        for g in self.circuit.gates: g.index = 0
        if not separate_correction:
            for g in correction: self.circuit.gates.extend(g.to_basic_gates())
            return self.circuit
        else:
            return self.circuit, correction
    
    def parse_forward(self):
        """Does a single forward pass trough self.circuit.gates."""
        self.gates = {i:list() for i in range(self.qubits)}
        self.available = {i:list() for i in range(self.qubits)}
        self.availty = {i: 1 for i in range(self.qubits)}
        self.parsed = []
        self.parsed_indices = set()
        self.hadamards = []
        self.nots = []
        self.zs = []
        self.permutation = {i:i for i in range(self.qubits)}
        self.gcount = 0
        for g in self.circuit.gates:
            self.parse_gate(g)
        for t in self.hadamards.copy():
            self.add_hadamard(t)
        for t in self.zs:
            z = Z(t)
            z.index = self.gcount
            self.gcount += 1
            self.gates[t].append(z)
        # for t in self.nots:
        #     n = NOT(t)
        #     #correction.append(n)
        #     n.index = self.gcount
        #     self.gcount += 1
        #     self.gates[t].append(n)
        
        c = Circuit(self.qubits)
        c.gates = self.topological_sort_gates()
        
        correction = []
        for t in self.nots:
            n = NOT(t)
            correction.append(n)
            # n.index = self.gcount
            # self.gcount += 1
            # self.gates[t].append(n)
        swaps = permutation_as_swaps(self.permutation)
        for a,b in swaps:
            correction.append(SWAP(a,b))
            #c.gates.extend(SWAP(a,b).to_basic_gates())
        return c, correction

    def topological_sort_gates(self):
        """self.gates is a a {qubit:[list of gates]} dictionary. This function consumes this dictionary and outputs a
        single list of gates, with the gates in the correct order.
        Note that 2-qubit gates are present in two entries in the dictionary and are identified with an ``index`` parameter."""
        output = []
        while any(self.gates.values()):
            available_indices = set()
            for q, gs in self.gates.items():
                while gs:
                    g = gs[0]
                    if g.name not in ('CZ', 'CNOT'):
                        output.append(gs.pop(0))
                    elif g.index in available_indices:
                        available_indices.remove(g.index)
                        q2 = g.target if q == g.control else g.control
                        self.gates[q2].remove(g)
                        output.append(gs.pop(0))
                    else:
                        ty = 1 if (g.name == 'CZ' or g.control == q) else 2
                        available_indices.add(g.index)
                        remove = []
                        for i, g2 in enumerate(gs[1:]):
                            if (ty == 1 and isinstance(g2, ZPhase)) or (ty == 2 and isinstance(g2, XPhase)):
                                output.append(g2)
                                remove.append(i)
                            elif g2.name not in ('CZ', 'CNOT'): break
                            elif (ty == 1 and (g2.name == 'CZ' or g2.control == q)) or (ty == 2 and g2.name == 'CNOT' and g2.target == q):
                                if g2.index in available_indices:
                                    available_indices.remove(g2.index)
                                    q2 = g2.target if q == g2.control else g2.control
                                    self.gates[q2].remove(g2)
                                    output.append(g2)
                                    remove.append(i)
                                else:
                                    available_indices.add(g2.index)
                            else:
                                break
                        for i in reversed(remove):
                            gs.pop(i+1)
                        break
        return output

    
    def add_hadamard(self, t):
        """Called by ``parse_gate`` to add a Hadamard gate to the output."""
        h = HAD(t)
        h.index = self.gcount
        self.gcount += 1
        self.gates[t].append(h)
        self.hadamards.remove(t)
        self.available[t] = list()
        self.availty[t] = 1
    
    def add_gate(self, t, g):
        """Helper function for ``add_cz`` and ``add_cnot`` to add a single qubit gate to the output."""
        g.index = self.gcount
        self.gcount += 1
        self.gates[t].append(g)
        self.available[t].append(g)
    
    def add_cz(self, cz):
        """Called by ``parse_gate`` to add a CZ gate to the output.
        Does some non-trivial logic to see whether the CZ-gate can be cancelled against a CNOT or CZ gate."""
        t1, t2 = cz.control, cz.target
        #We first try to find a matching CNOT gate
        found_match = False
        if self.minimize_czs:
            for c,t in [(t1,t2),(t2,t1)]:
                for g in self.available[c]:
                    if g.name == 'CNOT' and g.control == c and g.target == t:
                        if self.availty[t] == 2:
                            if g in self.available[t]: # The gate is also available on the target qubit
                                found_match = True
                                break
                            else:
                                continue
                        # There are Z-like gates blocking the CNOT from usage
                        # But if the CNOT can be passed all the way up to these Z-like gates
                        # Then we can commute the CZ gate next to the CNOT and hence use it.
                        for h in list(reversed(self.gates[t][:-len(self.available[t])])): # We start looking at the gates behind the Z-like gates
                            if h.name != 'CNOT' or h.target != t: # If any of those gates is not a CNOT of the right type, then we stop our search
                                break
                            if h == g: # But if all the previous gates are fine, than we can use this CNOT.
                                found_match = True
                                break
                        if found_match: break
                if found_match: break
        if found_match: #CNOT-CZ = (S* x id)CNOT (S x S)
            t,c = g.target, g.control
            if self.availty[t] == 2:
                self.availty[t] == 1
                self.available[t] = []
            self.gates[t].remove(g)
            self.gates[c].remove(g)
            self.available[c].remove(g)
            s1 = S(t, adjoint=True)
            s1.index = self.gcount
            self.gcount += 1
            if self.available[t]: # There are gates of non-commuting type on this qubit
                self.gates[t].insert(-len(self.available[t]),s1) # And hence we must insert these gates at
                self.gates[t].insert(-len(self.available[t]),g)  # the correct location
            else: 
                self.gates[t].append(s1)
                self.gates[t].append(g)
            s2 = S(t)
            s2.index = self.gcount
            self.gcount += 1
            self.gates[t].append(s2) # In contrast, these gates appear after the CNOT, necessarily on Z-like phases
            self.available[t].append(s2) # and hence can be added at the end of the list
            s3 = S(c)
            s3.index = self.gcount
            self.gcount += 1
            self.available[c].append(g)
            self.available[c].append(s3)
            self.gates[c].append(g)
            self.gates[c].append(s3)
            return

        if self.availty[t1] == 2:
            self.available[t1] = list()
            self.availty[t1] = 1
        if self.availty[t2] == 2:
            self.available[t2] = list()
            self.availty[t2] = 1

        found_match = False
        for g in reversed(self.available[t1]): # We try to find a CZ with the same control and target
            if g.name == 'CZ' and g.control == t1 and g.target == t2: # Here it is important that we have normalised all CZs
                found_match = True                                    # to have cz.control<cz.target
                break
        if found_match:
            if g not in self.available[t2]: # We still need to check if the CZ is actually available on the other qubit
                found_match = False
            else:
                self.available[t1].remove(g)
                self.gates[t1].remove(g)
                self.available[t2].remove(g)
                self.gates[t2].remove(g)

        if not found_match: # No cancellation found, so we just add the gate
            cz.index = self.gcount
            self.gcount += 1
            self.gates[t1].append(cz)
            self.gates[t2].append(cz)
            self.available[t1].append(cz)
            self.available[t2].append(cz)
    
    def add_cnot(self, cnot):
        """Called by ``parse_gate`` to parse a CNOT gate.
        Does some non-trivial logic to see whether the CNOT gate can be cancelled against another CNOT gate on the same qubits."""
        c, t = cnot.control, cnot.target
        if self.availty[c] == 2:
            if self.availty[t] == 1: # Try to find anti-match
                found_match = False
                for g in reversed(self.available[c]):
                    if g.name == 'CNOT' and g.control == t and g.target == c:
                        found_match = True
                        break
                if found_match and self.do_swaps: # We do the CNOT(t,c)CNOT(c,t) = CNOT(c,t)SWAP(c,t) commutation
                    if g in self.available[t]:
                        self.gates[c].remove(g)
                        self.gates[t].remove(g)
                        self.availty[c] = 1
                        self.availty[t] = 2
                        self.gcount += 1
                        self.gates[c].append(cnot)
                        self.gates[t].append(cnot)
                        self.available[c] = [cnot]
                        self.available[t] = [cnot]
                        a = self.permutation[c]
                        b = self.permutation[t]
                        self.permutation[c] = b
                        self.permutation[t] = a
                        swap_element(self.hadamards, t, c)
                        swap_element(self.nots, t, c)
                        swap_element(self.zs, t, c)
                        return
                
            self.available[c] = list()
            self.availty[c] = 1
        if self.availty[t] == 1:
            self.available[t] = list()
            self.availty[t] = 2
        found_match = False
        for g in reversed(self.available[c]):
            if g.name == 'CNOT' and g.control == c and g.target == t:
                found_match = True
                break
        if found_match: # We do CNOT(c,t)CNOT(c,t) = id
            if g not in self.available[t]:
                found_match = False
            else:
                self.available[c].remove(g)
                self.gates[c].remove(g)
                self.available[t].remove(g)
                self.gates[t].remove(g)
                
        if not found_match:
            cnot.index = self.gcount
            self.gcount += 1
            self.gates[c].append(cnot)
            self.gates[t].append(cnot)
            self.available[c].append(cnot)
            self.available[t].append(cnot)
    
    def parse_gate(self, g):
        """The main function of the optimization. It records whether a gate needs to be placed at the specified location
        'right now', or whether we can postpone the placement until hopefully it is cancelled against some future gate.
        Only supports ZPhase, HAD, CNOT and CZ gates. """
        g = g.copy()
        # If we have some SWAPs recorded we need to change the target/control of the gate accordingly
        g.target = next(i for i in self.permutation if self.permutation[i] == g.target)
        t = g.target
        if g.name in ('CZ', 'CNOT'):
            g.control = next(i for i in self.permutation if self.permutation[i] == g.control)

        if g.name == 'HAD':
            # If we have recorded a NOT or Z gate at the target location, we push it trough the Hadamard and change the type
            if t in self.nots and t not in self.zs:
                self.nots.remove(t)
                self.zs.append(t)
            elif t in self.zs and t not in self.nots:
                self.zs.remove(t)
                self.nots.append(t)
            # See whether we have a HAD-S-HAD situation
            # And turn it into a S*-HAD-S* situation
            if len(self.gates[t])>1 and self.gates[t][-2].name == 'HAD' and isinstance(self.gates[t][-1], ZPhase):
                    g2 = self.gates[t][-1]
                    if g2.phase.denominator == 2:
                        h = self.gates[t][-2]
                        zp = ZPhase(t, (-g2.phase)%2)
                        zp.index = self.gcount
                        self.gcount += 1
                        g2.phase = zp.phase
                        if g2.name == 'S' and g2.phase.numerator > 1:
                            g2.adjoint = True
                        self.gates[t].insert(-2,zp)
                        return
            toggle_element(self.hadamards, t)
        elif g.name == 'NOT':
            toggle_element(self.nots, t)
        elif isinstance(g, ZPhase):
            if t in self.zs: #Consume a Z gate into the phase gate
                g.phase = (g.phase+1)%2
                self.zs.remove(t)
            if g.phase == 0: return
            if t in self.nots: # Push the phase gate trough a NOT
                g.phase = (-g.phase)%2
            if g.phase == 1: # If the resulting phase is a pi, then we record it as a Z gate
                toggle_element(self.zs, t)
                return
            if g.name == 'S':                           # We might have changed the phase, and therefore
                g.adjoint = g.phase.numerator != 1      # Need to adjust whether the adjoint is true
            if t in self.hadamards: # We can't push a phase gate trough a HAD, so we actually place the HAD down
                self.add_hadamard(t)
            if self.availty[t] == 1 and any(isinstance(g2, ZPhase) for g2 in self.available[t]): # There is an available phase gate
                i = next(i for i,g2 in enumerate(self.available[t]) if isinstance(g2, ZPhase))   # That we can fuse with the new one
                g2 = self.available[t].pop(i)
                self.gates[t].remove(g2)
                phase = (g.phase+g2.phase)%2
                if phase == 1:
                    toggle_element(self.zs, t)
                    return
                if phase != 0:
                    p = ZPhase(t, phase)
                    self.add_gate(t,p)
            else:
                if self.availty[t] == 2: # If previous gate was of X-type
                    self.availty[t] = 1  # We reset the available gates on this qubit
                    self.available[t] = list()
                self.add_gate(t, g)
        elif g.name == 'CZ':
            t1, t2 = g.control, g.target
            if t1 > t2: # Normalise so that always g.target<g.control (since CZs are symmetric anyway)
                g.target = t1
                g.control = t2
            # Push NOT gates trough the CZ
            if t1 in self.nots: 
                toggle_element(self.zs, t2)
            if t2 in self.nots:
                toggle_element(self.zs, t1)
            # If there are HADs on both targets, we cannot commute the CZ trough and we place the HADs
            if t1 in self.hadamards and t2 in self.hadamards:
                self.add_hadamard(t1)
                self.add_hadamard(t2)
            if t1 not in self.hadamards and t2 not in self.hadamards:
                self.add_cz(g)
            # Exactly one of t1 and t2 has a hadamard
            # So the CZ commutes trough and becomes a CNOT
            elif t1 in self.hadamards:
                cnot = CNOT(t2, t1)
                self.add_cnot(cnot)
            else:
                cnot = CNOT(t1, t2)
                self.add_cnot(cnot)
            
        elif g.name == 'CNOT':
            c, t = g.control, g.target
            # Commute NOTs and Zs trough the CNOT
            if c in self.nots:
                toggle_element(self.nots, t)
            if t in self.zs:
                toggle_element(self.zs, c)
            # If HADs are on both qubits, we commute the CNOT trough by switching target and control
            if c in self.hadamards and t in self.hadamards:
                g.control = t
                g.target = c
                self.add_cnot(g)
            elif c not in self.hadamards and t not in self.hadamards:
                self.add_cnot(g)
            # If there is a HAD on the target, the CNOT commutes trough to become a CZ
            elif t in self.hadamards:
                cz = CZ(c if c<t else t, c if c>t else t)
                self.add_cz(cz)
            else: # Only the control has a hadamard gate in front of it
                self.add_hadamard(c)
                self.add_cnot(g)
        
        else:
            raise TypeError("Unknown gate {}".format(str(g)))




def greedy_consume_gates(gates, qubits):
    """Tries to consume as many gates as possible into a phase-polynomial block, by pushing gates past hadamards to the beginning
    as long as that is possible.

    ``gates`` should be a {qubits:[list of gates]} dictionary, while ``qubits`` is the amount of qubits in the circuit.
    Returns a tuple (list of gates, list of hadamards)."""
    
    block = [] # The output
    while True:
        had_blocked = dict() # a {qubit: HADgate} dictionary specifying when a HAD blocks further consuming of gates.
        to_be_appended = [] # List of gates that we will add to ``block``.
        available = []      # List of indices of 2-qubit gates to record whether they are available to be added on the other target.
        gatetype = {i: 0 for i in range(qubits)} # 0 = Z-type, 1 = X-type, the two sorts of commutation types.
        for q, gs in gates.items():
            if not gs: continue
            g = gs[0]
            if g.name == 'HAD': # If the first gate on this qubit is a HAD, we stop
                had_blocked[q] = g
                continue
            if isinstance(g, ZPhase) or g.name == 'CZ':
                gatetype[q] = 1
            else: # gate is a CNOT
                if g.control == q:
                    gatetype[q] = 1
                else:
                    gatetype[q] = 2
            for g in gs:
                if g.name == 'HAD': # Stop once we encounter a HAD
                    had_blocked[q] = g
                    break
                if isinstance(g, ZPhase) or g.name == 'CZ': # Z-type gates
                    if gatetype[q] == 1: # Z-type is available
                        if g.name == 'CZ':
                            if g.index in available: # Check whether the target on the other qubit is available
                                to_be_appended.append(g)
                            else: available.append(g.index) # Otherwise we postpone until we have checked that later on
                        else:
                            to_be_appended.append(g)
                    else:
                        break # We have encountered a gate of the wrong type, so we stop delving deeper
                else: #gate is CNOT
                    if (gatetype[q] == 1 and g.target == q) or (gatetype[q] == 2 and g.control == q): # wrong type
                        break
                    else:
                        if g.index in available: # Same 2-qubit gate logic as with CZ
                            to_be_appended.append(g)
                        else: available.append(g.index)
        for g in to_be_appended:
            block.append(g)
            gates[g.target].remove(g)
            if g.name in ('CZ', 'CNOT'):
                gates[g.control].remove(g)  
        if to_be_appended: # We added at least one gate, so we go to the top of the loop to try again.
            continue
        # We couldn't add any easy gates, so now we go looking for gates stuck behind a HAD.
        added_any = False
        candidates = []
        for q, had in had_blocked.items():
            i = gates[q].index(had)
            gs = gates[q][i+1:] # The gates appearing after the HAD
            if not gs: continue
            g = gs[0]
            if g.name == 'HAD': # Double Hadamard
                gates[q].remove(had)
                gates[q].remove(g)
                added_any = True
                break
            left_ty = gatetype[q] # The type of the gates to the left of the HAD. Note that this type must necessarily
                                  #  be the same for all gates, since otherwise it wouldn't be blocked by a HAD.
            if g.name == 'CZ' or isinstance(g, ZPhase) or (g.control == q):
                if gatetype[q] == 0: left_ty = 2 # If no gate is on the left of the HAD we set the type correspondingly.
                right_ty = 1
            else: 
                if gatetype[q] == 0: left_ty = 1
                right_ty = 2
            if left_ty == right_ty: continue # If the types are different, we can't commute things past the HAD into the phase-block.
            for g in gs:
                if g.name == 'HAD': break # If we encounter another HAD, we stop.
                if isinstance(g, ZPhase):
                    if right_ty == 1: continue # We can't commute a ZPhase past a HAD, but we can keep looking further
                    else: break # ZPhase is not of type X, so we must stop looking now.
                if g.name == 'CZ' or g.control == q: # CZ or CNOT with a control on this qubit
                    if right_ty == 2: break
                else:  # CNOT with target on this qubit
                    if right_ty == 1: break
                if g.index not in available:
                    if g.name == 'CNOT':  # We only need to check CNOTs, since CZs must already be in available 
                        available.append(g.index)  # (because otherwise they would be behind 2 HADs)
                else:
                    if g not in candidates:
                        candidates.append(g)
        if added_any: continue # Found double Hadamard

        for g in candidates:
            if g.name == 'CZ':
                if g.target in had_blocked and g.index > had_blocked[g.target].index: # CZ appears after the HAD.
                    q = g.target
                else:
                    q = g.control
                q2 = g.target if g.control == q else g.control
                if q2 in had_blocked and g.index > had_blocked[q2].index:
                    print(g, g.index)
                    raise Exception("CZ behind two Hadamard gates. This is not supposed to happen")
                cnot = CNOT(q2, q)
                cnot.index = g.index
                gates[q].remove(g)
                gates[q2].remove(g)
                block.append(cnot)
                added_any = True
            elif g.name == 'CNOT':
                if (g.target in had_blocked and g.index > had_blocked[g.target].index
                     and g.control in had_blocked and g.index > had_blocked[g.control].index):
                    cnot = CNOT(g.target, g.control)
                    cnot.index = g.index
                    gates[g.target].remove(g)
                    gates[g.control].remove(g)
                    block.append(cnot)
                    added_any = True
                elif g.target in had_blocked and g.index > had_blocked[g.target].index:
                    cz = CZ(g.control, g.target)
                    cz.index = g.index
                    gates[g.target].remove(g)
                    gates[g.control].remove(g)
                    block.append(cz)
                    added_any = True
                else: continue
        if added_any: continue
        else: break

    hadamards = []
    for gs in gates.values():
        if gs and gs[0].name == 'HAD':
            hadamards.append(gs.pop(0))
    return block, hadamards


def phase_block_optimize(circuit, pre_optimize=True, quiet=True):
    qubits = circuit.qubits
    o = Optimizer(circuit)
    if pre_optimize:
        circuit, correction = o.parse_circuit(separate_correction=True, quiet=quiet)
    else:
        circuit = circuit.copy()
        correction = []
    permutation = {i:i for i in range(qubits)}
    nots = []
    for g in correction:
        if g.name == 'SWAP':
            a = permutation[g.control]
            b = permutation[g.target]
            permutation[g.control] = b
            permutation[g.target] = a
        elif g.name == 'NOT':
            nots.append(g)
        else:
            raise TypeError("Illegal correction {}".format(str(g)))

    permutation = {v:k for k,v in permutation.items()}

    gates = {i:list() for i in range(qubits)}

    for i, g in enumerate(circuit.gates):
        g = g.copy()
        g.index = i        
        if g.name in ('CNOT', 'CZ'):
            gates[g.control].append(g)
            gates[g.target].append(g)
        elif g.name != 'HAD':
            if not isinstance(g, ZPhase):
                raise TypeError("Unknown gate {}. Maybe simplify the gates with circuit.to_basic_gates()?".format(str(g)))
            elif g.phase.denominator not in (1,2,4):
                raise TypeError("This method only works on Clifford+T circuits. This circuit contains a {}".format(str(g)))
            gates[g.target].append(g)
        else:
            gates[g.target].append(g)

    consumed = []

    block = []
    hadamards = []
    while any(gates.values()):
        if not quiet: print("new block")
        revgates = {i:list() for i in range(qubits)}
        i = 0
        for g in hadamards:
            g.index = i
            i += 1
            revgates[g.target].append(g)
        for g in reversed(block):
            g.index = i
            i += 1
            revgates[g.target].append(g)
            if g.name in ('CNOT', 'CZ'):
                revgates[g.control].append(g)

        revblock, had2 = greedy_consume_gates(revgates, qubits)
        if len(hadamards) != len(had2):
            raise Exception("Hadamards did not extract correctly")

        notparsed = []
        indices = set()
        for gs in revgates.values():
            for g in gs:
                if g.index not in indices:
                    indices.add(g.index)
                    notparsed.append(g)
        notparsed.sort(key=lambda g: g.index, reverse=True)

        consumed.extend(notparsed)
        consumed.extend(had2)

        newblock, hadamards = greedy_consume_gates(gates, qubits)
        block = list(reversed(revblock))
        block.extend(newblock)
        block, permute = todd_simp(block, qubits, quiet=quiet)
        inverse = {v:k for k,v in permute.items()}
        gates = {inverse[t]:gs for t,gs in gates.items()}
        indices = set()
        for gs in gates.values():
            for g in gs:
                if g.name in ('CNOT', 'CZ'):
                    if g.index in indices:
                        continue
                    indices.add(g.index)
                    g.control = inverse[g.control]
                g.target = inverse[g.target]
        for g in nots:
            g.target = inverse[g.target]
        permutation = {i: permutation[permute[i]] for i in range(qubits)}

    consumed.extend(block)
    consumed.extend(hadamards)
    consumed.extend(nots)
    for a,b in permutation_as_swaps(permutation):
        consumed.append(SWAP(a,b))
    for g in consumed: g.index = 0
    c = Circuit(qubits)
    c.gates = consumed
    return c# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""Implements methods for interacting with Quantomatic. This interaction works in both directions.
When working in Python with PyZX you can edit graphs in the following way::

    import pyzx as zx
    zx.quantomatic.quantomatic_location = "path/to/quantomatic/jar/file.jar"
    g = zx.generate.cliffordT(3,10,0.2)
    g2 = zx.quantomatic.edit_graph(g) # Opens Quantomatic with the graph g opened. Execution is blocked until Quantomatic is closed again.
    # If you have saved the qgraph file in quantomatic, then g2 should now contain your changes.


When running Quantomatic, you can invoke PyZX in the following ways::
    
    #This script generates a random clifford circuit in Quantomatic
    from quanto.util.Scripting import *
    import pyzx.quantomatic as zx
    g = zx.generate.cliffords(3,15)
    j = zx.graph_to_json(g)
    new_graph_from_json(j)

    #This script registers the PyZX clifford_simp simplifier as a simproc in Quantomatic
    from quanto.util.Scripting import *
    import pyzx.quantomatic as zx
    zx.output = output
    zx.register_python_simproc("clifford",zx.simplify.clifford_iter)

"""

import json

from .graph.graph import Graph
from .io import json_to_graph, graph_to_json
from . import simplify
from . import rules
from . import generate

try:
    import quanto.util.Scripting as quanto
except ImportError:
    quanto = None


class RewriteMaker(object):
    """Helper class for generating SimProcs that interact nicely between 
    Quantomatic and PyZX"""
    def __init__(self,rewriter):
        self.rewriter = rewriter
        self.steps = []
        self.names = []

    def start(self, js):
        self.steps = []
        self.names = []
        g = json_to_graph(js)
        for s,n in self.rewriter(g):
            self.steps.append(graph_to_json(s))
            self.names.append(n)

        return len(self.steps)

    def get_step(self, index):
        return self.steps[index]

    def get_name(self, index):
        return self.names[index]



def register_python_simproc(name, rewriter):
    """When called by Quantomatic, registers a Simproc implementing a PyZX
    simplification strategy

    :param str name: Name that the resulting simproc will have
    :param rewriter: Should be a method from :class:`~pyzx.simplify`
    """
    maker = RewriteMaker(rewriter)
    simproc = quanto.JSON_REWRITE_STEPS(maker.start, maker.get_step, maker.get_name)
    quanto.register_simproc(name, simproc)
    output.println("registered simproc " + name)


if not quanto:
    import tempfile
    import os
    import subprocess

    quantomatic_location = None

    def edit_graph(g):
        """Opens Quantomatic with the graph ``g`` loaded. When you are done editing the graph, 
        you save it in Quantomatic and close the executable. The resulting graph is returned by this function.
        Note that this function blocks until the Quantomatic executable is closed. For this function to work
        you must first set ``zx.quantomatic.quantomatic_location`` to point towards the Quantomatic .jar file."""
        if not quantomatic_location or not os.path.exists(quantomatic_location):
            print("Please point towards the Quantomatic jar file with quantomatic.quantomatic_location")
            return

        with tempfile.TemporaryDirectory() as tmpdirname:
            projectname = os.path.join(tmpdirname, "main.qgraph")
            with open(projectname,'w') as f:
                f.write(pyzx_qproject)
            js = graph_to_json(g)
            fname = os.path.join(tmpdirname, "pyzxgraph.qgraph")
            with open(fname,'w') as f:
                f.write(js)
            print("Opening Quantomatic...")
            subprocess.check_call(["java", "-jar",quantomatic_location, projectname, fname])
            print("Done")
            with open(fname, 'r') as f:
                js = f.read()
                g = json_to_graph(js)
        return g


pyzx_qproject = """
{"name":"PyZX",
"theory":{"name":"Red/green theory","core_name":"red_green",
"vertex_types":{
    "X":{"value":{"type":"angle_expr","latex_constants":true,"validate_with_core":false},
        "style":{"label":{"position":"inside","fg_color":[1.0,1.0,1.0]},"stroke_color":[0.0,0.0,0.0],"fill_color":[1.0,0.0,0.0],"shape":"circle","stroke_width":1},"default_data":{"type":"X","value":""}},
    "Z":{"value":{"type":"angle_expr","latex_constants":true,"validate_with_core":false},
        "style":{"label":{"position":"inside","fg_color":[0.0,0.0,0.0]},"stroke_color":[0.0,0.0,0.0],"fill_color":[0.0,0.800000011920929,0.0],"shape":"circle","stroke_width":1},"default_data":{"type":"Z","value":""}},
    "hadamard":{"value":{"type":"string","latex_constants":false,"validate_with_core":false},
        "style":{"label":{"position":"inside","fg_color":[0.0,0.20000000298023224,0.0]},"stroke_color":[0.0,0.0,0.0],"fill_color":[1.0,1.0,0.0],"shape":"rectangle","stroke_width":1},"default_data":{"type":"hadamard","value":""}},
    "var":{"value":{"type":"string","latex_constants":false,"validate_with_core":false},
        "style":{"label":{"position":"inside","fg_color":[0.0,0.0,0.0]},"stroke_color":[0.0,0.0,0.0],"fill_color":[0.6000000238418579,1.0,0.800000011920929],"shape":"rectangle","stroke_width":1},"default_data":{"type":"var","value":""}}
    },
"default_vertex_type":"Z",
"default_edge_type":"string",
"edge_types":{
    "string":{"value":{"type":"string","latex_constants":false,"validate_with_core":false},"style":{"stroke_color":[0.0,0.0,0.0],"stroke_width":1,"label":{"position":"center","fg_color":[0.0,0.0,1.0],"bg_color":[0.800000011920929,0.800000011920929,1.0,0.699999988079071]}},"default_data":{"type":"string","value":""}}}
    }
}"""# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

from .graph.graph import Graph
from .linalg import Mat2
from .drawing import *
from .simplify import *
from .io import *
from .tensor import *
from .circuit import Circuit
from . import quantomatic
from . import generate
from . import todd
from . import linalg
from . import extract
from . import rules
from . import optimize
from . import simplify
from . import d3
from . import tikz

if __name__ == '__main__':
    print("Please execute this as a module by running 'python -m pyzx'")
# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

__all__ = ['cnots','cliffords', 'cliffordT', 'identity']

import random
from fractions import Fraction

from .graph.graph import Graph
from .circuit import Circuit


def identity(qubits, depth=1,backend=None):
    """Generates an identity circuit on a given amount of qubits.
    ``depth`` specifies at which row the outputs should be placed."""
    g = Graph(backend)
    for i in range(qubits):
        v = g.add_vertex(0,i,0)
        w = g.add_vertex(0,i,depth)
        g.inputs.append(v)
        g.outputs.append(w)
        g.add_edge((v,w))

    return g


def CNOT_HAD_PHASE_circuit(qubits, gates, p_had, p_t, clifford=False):
    """Returns a Circuit consisting of CNOT, HAD and phase gates. 
    The default phase gate is the T gate, but if ``clifford=True``, then
    this is replaced by the S gate."""
    p_cnot = 1-p_had-p_t
    c = Circuit(qubits)
    for _ in range(gates):
        r = random.random()
        if r > 1-p_had:
            c.add_gate("HAD",random.randrange(qubits))
        elif r > 1-p_had-p_t:
            if not clifford: c.add_gate("T",random.randrange(qubits))
            else: c.add_gate("S",random.randrange(qubits))
        else:
            tgt = random.randrange(qubits)
            while True:
                ctrl = random.randrange(qubits)
                if ctrl!=tgt: break
            c.add_gate("CNOT",tgt,ctrl)
    return c


def cnots(qubits, depth, backend=None):
    """Generates a circuit consisting of randomly placed CNOT gates.

    :param qubits: Amount of qubits in circuit
    :param depth: Depth of circuit
    :param backend: When given, should be one of the possible :ref:`graph_api` backends.
    :rtype: Instance of graph of the given backend
    """
    # initialise and add input row

    q = list(range(qubits))   # qubit index, initialised with input
    r = 1                     # current rank
    ty = [0] * qubits         # types of vertices
    qs = list(range(qubits))  # tracks qubit indices of vertices
    rs = [0] * qubits         # tracks rank of vertices
    v = qubits                # next vertex to add
    es = [] # edges to add

    # initial row of Z
    for i in range(qubits):
        es.append((q[i], v))
        q[i] = v
        rs.append(r)
        qs.append(i)
        ty.append(1)
        v += 1
    r += 1

    # random CNOTs
    for i in range(depth):
        c = random.randint(0, qubits-1)
        t = random.randint(0, qubits-2)
        if t >= c: t += 1
        es += [(q[c], v), (q[t], v+1), (v, v+1)]
        q[c] = v
        q[t] = v+1
        rs += [r,r]
        qs += [c,t]
        ty += [1,2]
        v += 2
        r += 1

    # final row of Z
    for i in range(qubits):
        es.append((q[i], v))
        q[i] = v
        rs.append(r)
        qs.append(i)
        ty.append(1)
        v += 1
    r += 1

    # outputs
    qs += list(range(qubits))
    rs += [r] * qubits
    ty += [0] * qubits
    es += [(q[i], v+i) for i in range(qubits)]
    v += qubits

    g = Graph(backend)

    for i in range(v):
        g.add_vertex(ty[i],qs[i],rs[i])

    g.add_edges(es)

    for i in range(qubits):
        g.inputs.append(i)
        g.outputs.append(v-i-1)
    return g

def accept(p):
    return p>random.random()

def random_phase(add_t):
    if add_t:
        return Fraction(random.randint(1,8),4)
    return Fraction(random.randint(1,4),2)

def cliffordT(qubits, depth, p_t=None, p_s=None, p_hsh=None, p_cnot=None, backend=None):
    """Generates a circuit consisting of randomly placed Clifford+T gates. Optionally, take
    probabilities of adding T, S, HSH, and CNOT. If probabilities for only a subset of gates
    is given, any remaining probability will be uniformly distributed among the remaining
    gates.

    :param qubits: Amount of qubits in circuit.
    :param depth: Depth of circuit.
    :param p_t: Probability that each gate is a T-gate.
    :param p_s: Probability that each gate is a S-gate.
    :param p_hsh: Probability that each gate is a HSH-gate.
    :param p_cnot: Probability that each gate is a CNOT-gate.
    :param backend: When given, should be one of the possible :ref:`graph_api` backends.
    :rtype: Instance of graph of the given backend.
    """
    g = Graph(backend)
    qs = list(range(qubits))  # tracks qubit indices of vertices
    v = 0                     # next vertex to add
    r = 0                     # current row

    num = 0.0
    rest = 1.0
    if p_t == None: num += 1.0
    else: rest -= p_t
    if p_s == None: num += 1.0
    else: rest -= p_s
    if p_hsh == None: num += 1.0
    else: rest -= p_hsh
    if p_cnot == None: num += 1.0
    else: rest -= p_cnot

    if rest < 0: raise ValueError("Probabilities are >1.")

    if p_t == None: p_t = rest / num
    if p_s == None: p_s = rest / num
    if p_hsh == None: p_hsh = rest / num
    if p_cnot == None: p_cnot = rest / num

    #p_s = (1 - p_t) / 3.0
    #p_hsh = (1 - p_t) / 3.0
    #p_cnot = (1 - p_t) / 3.0
    

    for i in range(qubits):
        g.add_vertex(0,i,r)
        g.inputs.append(v)
        v += 1
    r += 1

    for i in range(qubits):
        g.add_vertex(1,i,r)
        g.add_edge((qs[i], v))
        qs[i] = v
        v += 1
    r += 1

    for i in range(2, depth+2):
        p = random.random()
        q0 = random.randrange(qubits)

        g.add_vertex(1,q0,r)
        g.add_edge((qs[q0], v))
        qs[q0] = v
        v += 1
        r += 1

        if p > 1 - p_cnot:
            # apply CNOT gate
            q1 = random.randrange(qubits-1)
            if q1 >= q0: q1 += 1

            g.add_vertex(2,q1,r-1)
            g.add_edge((qs[q1], v))
            g.add_edge((v-1,v))
            qs[q1] = v
            v += 1
        elif p > 1 - p_cnot - p_hsh:
            # apply HSH gate
            g.set_type(v-1, 2)
            g.set_phase(v-1, Fraction(1,2))
        elif p > 1 - p_cnot - p_hsh - p_s:
            # apply S gate
            g.set_phase(v-1, Fraction(1,2))
        else:
            # apply T gate
            g.set_phase(v-1, Fraction(1,4))

    for i in range(qubits):
        g.add_vertex(1,i,r)
        g.add_edge((qs[i], v))
        qs[i] = v
        v += 1
    r += 1

    for i in range(qubits):
        g.add_vertex(0,i,r)
        g.add_edge((qs[i], v))
        g.outputs.append(v)
        v += 1

    return g



def cliffords(qubits, depth, no_hadamard=False,t_gates=False,backend=None):
    """Generates a circuit consisting of randomly placed Clifford gates.
    Uses a different approach to generating Clifford circuits then :func:`cliffordT`.

    :param qubits: Amount of qubits in circuit.
    :param depth: Depth of circuit.
    :param no_hadamard: Whether hadamard edges are allowed to be placed.
    :param backend: When given, should be one of the possible :ref:`graph_api` backends.
    :rtype: Instance of graph of the given backend.
    """

    #randomness parameters
    p_two_qubit = 0.4 #whether to add a edge between two qubits
    p_cnot = 1 #0.4 # whether to CNOT or to CZ
    p_phase = 0.6 #probability of adding a phase to a node
    p_had = 0.2 # probability of adding a hadamard on a qubit

    # initialise and add input row

    q = list(range(qubits))   # qubit index, initialised with input
    r = 1                     # current rank
    ty = [0] * qubits         # types of vertices
    qs = list(range(qubits))  # tracks qubit indices of vertices
    rs = [0] * qubits         # tracks rank of vertices
    v = qubits                # next vertex to add
    es1 = [] # normal edges to add
    es2 = [] # hadamard edges to add
    phases = {}

    # initial row of Z
    for i in range(qubits):
        es1.append((q[i], v))
        q[i] = v
        rs.append(r)
        qs.append(i)
        ty.append(1)
        v += 1
    r += 1

    # random gates
    for i in range(depth):
        c = random.randint(0, qubits-1)
        t = random.randint(0, qubits-2)
        if t >= c: t += 1
        if accept(p_two_qubit):
            if no_hadamard or accept(p_cnot): 
                es1.append((v, v+1))
                ty += [1,2]
            else: 
                es2.append((v,v+1))
                typ = random.randint(1,2)
                ty += [typ,typ]
            if accept(p_phase): phases[v] = random_phase(t_gates)
            if accept(p_phase): phases[v+1] = random_phase(t_gates)
        else:
            phases[v] = random_phase(t_gates)
            phases[v+1] = random_phase(t_gates)
            ty += [1,2]
        
        if not no_hadamard and accept(p_had): es2.append((q[c],v))
        else: es1.append((q[c],v))
        if not no_hadamard and accept(p_had): es2.append((q[t],v+1))
        else: es1.append((q[t],v+1))

        q[c] = v
        q[t] = v+1
        
        rs += [r,r]
        qs += [c,t]
        v += 2
        r += 1

    # final row of Z
    for i in range(qubits):
        es1.append((q[i], v))
        q[i] = v
        rs.append(r)
        qs.append(i)
        ty.append(1)
        v += 1
    r += 1

    # outputs
    qs += list(range(qubits))
    rs += [r] * qubits
    ty += [0] * qubits
    es1 += [(q[i], v+i) for i in range(qubits)]
    v += qubits

    g = Graph(backend)
    

    for i in range(v):
        g.add_vertex(ty[i],qs[i], rs[i])
    for w, phase in phases.items():
        g.set_phase(w,phase)

    g.add_edges(es1,1)
    g.add_edges(es2,2)

    for i in range(qubits):
        g.inputs.append(i)
        g.outputs.append(v-i-1)
    return g



def circuit_identity_phasepoly():
    """Returns a 4-qubit circuit that is equal to the identity, provable by phase polynomial reductions."""
    c = Circuit(4)
    c.add_gate("ParityPhase",Fraction(1,4),0,1,2,3)
    for i in range(4):
        c.add_gate("ZPhase",i, Fraction(3,4))
        for j in range(i+1,4):
            c.add_gate("ParityPhase", Fraction(5,4),i,j)
            for k in range(j+1,4):
                c.add_gate("ParityPhase", Fraction(7,4),i,j,k)

    return c.to_graph()


def circuit_identity_commuting_controls(alpha,beta):
    """Returns the circuit UVU*V* where U=NCZ(2beta) and V=CX(2alpha).
    Since these operations commute this circuit is equal to the identity.
    See page 13 of https://arxiv.org/pdf/1705.11151.pdf for more details."""
    cb = Circuit(2) 
    cb.add_gate("NOT",0)
    cb.add_gate("ZPhase",0,beta)
    cb.add_gate("ZPhase",1,beta)
    cb.add_gate("ParityPhase", -beta, 0, 1)
    cb.add_gate("NOT",0)

    ca = Circuit(2)
    ca.add_gate("ZPhase", 1, Fraction(3,2))
    ca.add_gate("XPhase", 1, Fraction(3,2))
    ca.add_gate("ZPhase",0,alpha)
    ca.add_gate("ZPhase",1,alpha)
    ca.add_gate("ParityPhase", -alpha, 0, 1)
    ca.add_gate("XPhase", 1, Fraction(1,2))
    ca.add_gate("ZPhase", 1, Fraction(1,2))

    c = cb.copy()
    c.add_circuit(ca)
    c.add_circuit(cb.adjoint())
    c.add_circuit(ca.adjoint())
    
    return c.to_graph()


def circuit_identity_two_qubit1():
    """This returns the first nontrivial circuit identity from Selinger & Bian.
    See https://www.mathstat.dal.ca/~xbian/talks/slide_cliffordt2.pdf"""
    c = Circuit(2)
    c.add_gate("NOT",0)
    c.add_gate("T",1,adjoint=True)
    c.add_gate("S",1,adjoint=True)
    c.add_gate("HAD",1)
    c.add_gate("T",1,adjoint=True)
    c.add_gate("CNOT",0,1)
    c.add_gate("NOT",0)
    c.add_gate("T",1)
    c.add_gate("HAD",1)
    c.add_gate("S",1)
    c.add_gate("T",1)
    c.add_gate("CNOT",0,1)
    c.add_circuit(c)
    return c.to_graph()

def circuit_identity_two_qubit2():
    """This returns the second nontrivial circuit identity from Selinger & Bian.
    See https://www.mathstat.dal.ca/~xbian/talks/slide_cliffordt2.pdf"""
    c = Circuit(2)
    c.add_gate("CNOT",0,1)
    c.add_gate("NOT",0)
    c.add_gate("T",1)
    c.add_gate("HAD",1)
    c.add_gate("T",1)
    c.add_gate("HAD",1)
    c.add_gate("T",1,adjoint=True)
    c.add_gate("CNOT",0,1)
    c.add_gate("NOT",0)
    c.add_gate("T",1)
    c.add_gate("HAD",1)
    c.add_gate("T",1,adjoint=True)
    c.add_gate("HAD",1)
    c.add_gate("T",1,adjoint=True)
    c.add_circuit(c)
    return c.to_graph()# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""Contains simplification procedures based on the rewrite rules in rules_.
The main procedures of interest are :func:``clifford_simp` for simple reductions, 
:func:``full_reduce`` for the full rewriting power of PyZX, and :func:`teleport_reduce` to 
use the power of :func:``full_reduce`` while not changing the structure of the graph.
"""

from __future__ import print_function

try:
    import multiprocessing as mp
except ImportError:
    pass

__all__ = ['bialg_simp','spider_simp', 'id_simp', 'phase_free_simp', 'pivot_simp', 
        'pivot_gadget_simp', 'pivot_boundary_simp', 'gadget_simp',
        'lcomp_simp', 'clifford_simp', 'tcount', 'to_gh', 'to_rg', 'full_reduce', 'teleport_reduce']

from .rules import *

def simp(g, name, match, rewrite, matchf=None, quiet=False):
    """Helper method for generating simplification strategies based on rules in rules_.
    It keeps matching and rewriting with the given methods until it can no longer do so.
    Example usage: ``simp(g, 'spider_simp', rules.match_spider_parallel, rules.spider)``

    :param g: The graph that needs to be simplified.
    :param str name: The name of this rewrite rule.
    :param match: One of the ``match_*`` functions of rules_.
    :param rewrite: One of the rewrite functions of rules_.
    :param matchf: An optional filtering function on candidate vertices or edges, which
       is passed as the second argument to the match function.
    :param quiet: Suppress output on numbers of matches found during simplification."""
    i = 0
    new_matches = True
    while new_matches:
        new_matches = False
        if matchf != None:
            m = match(g, matchf)
        else:
            m = match(g)
        if len(m) > 0:
            i += 1
            if i == 1 and not quiet: print("{}: ".format(name),end='')
            if not quiet: print(len(m), end='')
            #print(len(m), end='', flush=True) #flush only supported on Python >3.3
            etab, rem_verts, rem_edges, check_isolated_vertices = rewrite(g, m)
            g.add_edge_table(etab)
            g.remove_edges(rem_edges)
            g.remove_vertices(rem_verts)
            if check_isolated_vertices: g.remove_isolated_vertices()
            if not quiet: print('. ', end='')
            #print('. ', end='', flush=True)
            new_matches = True
    if not quiet and i>0: print(' {!s} iterations'.format(i))
    return i

def pivot_simp(g, matchf=None, quiet=False):
    return simp(g, 'pivot_simp', match_pivot_parallel, pivot, matchf=matchf, quiet=quiet)

def pivot_gadget_simp(g, matchf=None, quiet=False):
    return simp(g, 'pivot_gadget_simp', match_pivot_gadget, pivot, matchf=matchf, quiet=quiet)

def pivot_boundary_simp(g, matchf=None, quiet=False):
    return simp(g, 'pivot_boundary_simp', match_pivot_boundary, pivot, matchf=matchf, quiet=quiet)

def lcomp_simp(g, matchf=None, quiet=False):
    return simp(g, 'lcomp_simp', match_lcomp_parallel, lcomp, matchf=matchf, quiet=quiet)

def bialg_simp(g, quiet=False):
    return simp(g, 'bialg_simp', match_bialg_parallel, bialg, quiet=quiet)

def spider_simp(g, matchf=None, quiet=False):
    return simp(g, 'spider_simp', match_spider_parallel, spider, matchf=matchf, quiet=quiet)

def id_simp(g, matchf=None, quiet=False):
    return simp(g, 'id_simp', match_ids_parallel, remove_ids, matchf=matchf, quiet=quiet)

def gadget_simp(g, quiet=False):
    return simp(g, 'gadget_simp', match_phase_gadgets, merge_phase_gadgets, quiet=quiet)

def phase_free_simp(g, quiet=False):
    '''Performs the following set of simplifications on the graph:
    spider -> bialg'''
    spider_simp(g, quiet=quiet)
    bialg_simp(g, quiet=quiet)

def interior_clifford_simp(g, quiet=False):
    """Keeps doing the simplifications ``id_simp``, ``spider_simp``, 
    ``pivot_simp`` and ``lcomp_simp`` until none of them can be applied anymore."""
    spider_simp(g, quiet=quiet)
    to_gh(g)
    i = 0
    while True:
        i1 = id_simp(g, quiet=quiet)
        i2 = spider_simp(g, quiet=quiet)
        i3 = pivot_simp(g, quiet=quiet)
        i4 = lcomp_simp(g, quiet=quiet)
        if i1+i2+i3+i4==0: break
        i += 1
    return i

def clifford_simp(g, quiet=False):
    """Keeps doing rounds of :func:`interior_clifford_simp` and
    :func:`pivot_boundary_simp` until they can't be applied anymore."""
    while True:
        interior_clifford_simp(g, quiet=quiet)
        i = pivot_boundary_simp(g, quiet=quiet)
        if i == 0:
            break


def full_reduce(g, quiet=True):
    """The main simplification routine of PyZX. It uses a combination of :func:`clifford_simp` and
    the gadgetization strategies :func:`pivot_gadget_simp` and :func:`gadget_simp`."""
    interior_clifford_simp(g, quiet=quiet)
    pivot_gadget_simp(g,quiet=quiet)
    while True:
        clifford_simp(g,quiet=quiet)
        i = gadget_simp(g, quiet=quiet)
        interior_clifford_simp(g,quiet=quiet)
        j = pivot_gadget_simp(g,quiet=quiet)
        if i+j == 0:
            break

def teleport_reduce(g, quiet=True):
    """This simplification procedure runs :func:`full_reduce` in a way 
    that does not change the graph structure of the resulting diagram.
    The only thing that is different in the output graph are the location and value of the phases.""" 
    s = Simplifier(g)
    s.full_reduce(quiet)
    return s.mastergraph


class Simplifier(object):
    """Class used for :func:`teleport_reduce`."""
    def __init__(self, g):
        g.track_phases = True
        self.mastergraph = g.copy()
        self.simplifygraph = g.copy()
        self.simplifygraph.set_phase_master(self)
        self.phantom_phases = dict()

    def fuse_phases(self,i1, i2):
        try:
            v1 = self.mastergraph.vertex_from_phase_index(i1)
            v2 = self.mastergraph.vertex_from_phase_index(i2)
        except ValueError: return
        #self.mastergraph.phase_index[v2] = i1
        p1 = self.mastergraph.phase(v1)
        p2 = self.mastergraph.phase(v2)
        m1 = self.simplifygraph.phase_mult[i1]
        m2 = self.simplifygraph.phase_mult[i2]
        if (p2 == 0 or p2.denominator <= 2): # Deleted vertex contains Clifford phase
            if v2 in self.phantom_phases:
                v3,i3 = self.phantom_phases[v2]
                m2 = m2*self.simplifygraph.phase_mult[i3]
                v2,i2 = v3,i3
                p2 = self.mastergraph.phase(v2)
            else: return
        if (p1 == 0 or p1.denominator <= 2): # Need to save non-Clifford location
            if v1 in self.phantom_phases: # Already fused with non-Clifford before
                v3,i3 = self.phantom_phases[v1]
                self.mastergraph.phase_index[v3] = i1
                p1 = self.mastergraph.phase(v3)
                if (p1+p2).denominator <= 2:
                    del self.phantom_phases[v1]
                v1,i1 = v3,i3
                m1 = m1*self.simplifygraph.phase_mult[i1]
            else:
                self.phantom_phases[v1] = (v2,i2)
                return
        if p1.denominator <= 2 or p2.denominator <= 2: raise Exception("Clifford phases here??")
        # Both have non-Clifford phase
        if m1*m2 == 1: phase = (p1 + p2)%2
        else: phase = p1 - p2
        self.mastergraph.set_phase(v1,phase)
        self.mastergraph.set_phase(v2,0)
        self.simplifygraph.phase_mult[i1] = 1
        self.simplifygraph.phase_mult[i2] = 1
    
    def full_reduce(self, quiet=True):
        full_reduce(self.simplifygraph,quiet=quiet)



def to_gh(g,quiet=True):
    """Turns every red node into a green node by changing regular edges into hadamard edges"""
    ty = g.types()
    for v in g.vertices():
        if ty[v] == 2:
            g.set_type(v, 1)
            for e in g.incident_edges(v):
                et = g.edge_type(e)
                if et == 2: g.set_edge_type(e,1)
                elif et == 1: g.set_edge_type(e,2)

def to_rg(g, select=None):
    """Turn green nodes into red nodes by colour-changing vertices which satisfy the predicate ``select``.
    By default, the predicate is set to greedily reducing the number of Hadamard-edges.
    :param g: A ZX-graph.
    :param select: A function taking in vertices and returning ``True`` or ``False``."""
    if not select:
        select = lambda v: (
            len([e for e in g.incident_edges(v) if g.edge_type(e) == 1]) <
            len([e for e in g.incident_edges(v) if g.edge_type(e) == 2])
            )

    ty = g.types()
    for v in g.vertices():
        if select(v):
            if ty[v] == 1:
                g.set_type(v, 2)
                for e in g.incident_edges(v):
                    g.set_edge_type(e, 1 if g.edge_type(e) == 2 else 2)
            elif ty[v] == 2:
                g.set_type(v, 1)
                for e in g.incident_edges(v):
                    g.set_edge_type(e, 1 if g.edge_type(e) == 2 else 2)

def tcount(g):
    """Returns the amount of nodes in g that have a non-Clifford phase."""
    if not hasattr(g, "vertices"): # It is probably a circuit
        return g.tcount()
    count = 0
    phases = g.phases()
    for v in g.vertices():
        if phases[v]!=0 and phases[v].denominator > 2:
            count += 1
    return count


# def pivot_double_boundary(g, quiet=False):
#     """Finds Pauli-phase interior non-phase gadget nodes that are connected
#     to the boundary. It changes the boundary nodes so that a pivot can be done
#     to remove the interior Pauli node."""
#     phases = g.phases()
#     ty = g.types()
#     qs = g.qubits()
#     rs = g.rows()
#     pivotable_edges = []
#     skiplist = []
#     for v in list(g.vertices()):
#         if v in skiplist: continue
#         if ty[v] != 1 or phases[v] not in (0,1): continue
#         good_vert = True
#         for w in g.neighbours(v):
#             if ty[w] != 1: 
#                 good_vert = False
#                 break
#             if len(list(g.neighbours(w))) == 1: # v is a phase gadget
#                 good_vert = False
#                 break
#         if not good_vert: continue

#         # v is now an interior edge with a 0/1 phase
#         for e in g.incident_edges(v):
#             s,t = g.edge_st(e)
#             v2 = s if s!=v else t
#             borders = sum(1 for w in g.neighbours(v2) if ty[w]==0)
#             #if phases[v2] not in (0,1): continue
#             if phases[v2] in (Fraction(1,2), Fraction(3,2)):
#                 if borders != 1: continue
#                 # v2 is a node on the border with a pi/2 phase
#                 w = g.add_vertex(1,-1, rs[v2], phase=-phases[v2])
#                 g.add_edge((v2,w),2)
#                 g.set_phase(v2, 0)
#                 skiplist.append(v2)
#                 pivotable_edges.append(e)
#                 continue
#             elif phases[v2] not in (0,1): continue 
#             if borders > 1:
#                 i = next(w for w in g.neighbours(v2) if w in g.inputs)
#                 o = next(w for w in g.neighbours(v2) if w in g.outputs)
#                 w1 = g.add_vertex(1,qs[i], rs[i]+1)
#                 w2 = g.add_vertex(1,qs[o], rs[o]-1)
#                 e1 = g.edge(v2,i)
#                 e2 = g.edge(v2,o)
#                 et1 = g.edge_type(e1)
#                 et2 = g.edge_type(e2)
#                 g.remove_edges([e1,e2])
#                 g.add_edges([(v2,w1),(v2,w2)],2)
#                 g.add_edge((i,w1),3-et1)
#                 g.add_edge((o,w2),3-et2)
#             skiplist.append(v2)
#             pivotable_edges.append(e)
#     if not quiet and pivotable_edges: 
#         print("Boundary Pivot: Unfused {:d} nodes for {:d} possible pivots".format(
#                                 len(skiplist),len(pivotable_edges)))
#     i = pivot_simp(g, matchf=lambda e: e in pivotable_edges, quiet=quiet)
#     return i

# def gadgetize(g):
#     """Un-fuses every node with a non-Pauli phase, so that they act like phase gadgets. 
#     It returns a 2-tuple where the first value is the set of newly made gadgets,
#     and the second is the set of all gadgets in the graph.
#     The vertices returned are the 'hub' part of the phase gadget
#      (the part which can only contain a Pauli-phase)."""
#     phases = g.phases()
#     #qs = g.qubits()
#     rs = g.rows()
#     qs = g.qubits()
#     edges = []
#     allgadgets = []
#     newgadgets = []
#     for v in list(g.vertices()):
#         if phases[v] != 0 and phases[v].denominator > 1:
#             if len(list(g.neighbours(v))) == 1: # It is already a gadget
#                 allgadgets.append(v)
#                 continue
#             v1 = g.add_vertex(1,-1,rs[v]+0.5,0)
#             v2 = g.add_vertex(1,-2,rs[v]+0.5,phases[v])
#             # v1 = g.add_vertex(1,-2*qs[v]-1,rs[v]+0.5,0)
#             # v2 = g.add_vertex(1,-2*qs[v]-2,rs[v]+0.5,phases[v])
#             g.set_phase(v, 0)
#             edges.append((v,v1))
#             edges.append((v1,v2))
#             newgadgets.append(v1)
#             allgadgets.append(v1)
#     g.add_edges(edges, 2)
#     return set(newgadgets), set(allgadgets)

# def full_reduce(g, quiet=True):
#     """This function does a round of :func:`clifford_simp`, :func:`gadgetize` 
#     and then a modified round of `clifford_simp`. It then applies 
#     :func:`gadget_simp`. It keeps doing rounds of these simplifications
#     until no more progress is made."""
#     i = 0
#     gadgetcount = 10**10
#     vertexcount = 10**10
#     while True:
#         clifford_simp(g,quiet=quiet)
#         #if tcount(g) == 24: break
#         newgadgets, allgadgets = gadgetize(g)
#         if i == 0 and not newgadgets: break
#         if len(newgadgets) >= gadgetcount:
#             n = g.num_vertices()
#             if n >= vertexcount:
#                 clifford_simp(g,quiet=quiet)
#                 break
#             vertexcount = n
#         else:
#             vertexcount = g.num_vertices()
#         if not quiet: 
#             print("Vertex count: ", vertexcount)
#             print("T-count: ", tcount(g))

#         gadgetcount = len(newgadgets)
#         if not quiet and gadgetcount: print("Gadgetized {:d} nodes".format(gadgetcount))
#         # don't pivot an edge adjacent to a gadget vertex
#         def matchf(e):
#             s, t = g.edge_st(e)
#             if s in newgadgets or t in newgadgets:
#                 return False
#             if s in allgadgets and t in allgadgets:
#                 return False
#             return True
#         #matchf = lambda e: g.edge_s(e) not in newgadgets and g.edge_t(e) not in newgadgets
#         #matchf = lambda e: not (g.edge_s(e) in gadgets or g.edge_t(e) in gadgets)
#         pivot_simp(g,matchf=matchf,quiet=quiet)
#         lcomp_simp(g,quiet=quiet)
#         pivot_simp(g,matchf=matchf,quiet=quiet)
#         phases = g.phases()
#         for v in g.vertices():
#             if phases[v] != 0 and phases[v].denominator > 2 and len(list(g.neighbours(v)))==1:
#                 n = list(g.neighbours(v))[0]
#                 if phases[n] == 1:
#                     g.set_phase(n, 0)
#                     g.set_phase(v, -1*phases[v])
#                     phases[n] = 0
#         if not quiet and gadgetcount: print("Back to clifford_simp")
#         clifford_simp(g,quiet=quiet)
#         i = gadget_simp(g, quiet=quiet)

#The functions below haven't been updated in a while. Use at your own risk.

def simp_iter(g, name, match, rewrite):
    """Version of :func:`simp` that instead of performing all rewrites at once, returns an iterator."""
    i = 0
    new_matches = True
    while new_matches:
        i += 1
        new_matches = False
        m = match(g)
        if len(m) > 0:
            etab, rem_verts, rem_edges, check_isolated_vertices = rewrite(g, m)
            g.add_edge_table(etab)
            g.remove_edges(rem_edges)
            g.remove_vertices(rem_verts)
            if check_isolated_vertices: g.remove_isolated_vertices()
            yield g, name+str(i)
            new_matches = True

def pivot_iter(g):
    return simp_iter(g, 'pivot', match_pivot_parallel, pivot)

def lcomp_iter(g):
    return simp_iter(g, 'lcomp', match_lcomp_parallel, lcomp)

def bialg_iter(g):
    return simp_iter(g, 'bialg', match_bialg_parallel, bialg)

def spider_iter(g):
    return simp_iter(g, 'spider', match_spider_parallel, spider)

def id_iter(g):
    return simp_iter(g, 'id', match_ids_parallel, remove_ids)

def clifford_iter(g):
    for d in spider_iter(g): yield d
    to_gh(g)
    yield g, "to_gh"
    for d in spider_iter(g): yield d
    for d in pivot_iter(g): yield d
    for d in lcomp_iter(g): yield d
    for d in pivot_iter(g): yield d
    #to_rg(g)
    #yield g, "to_rg"
    for d in id_iter(g): yield d
    for d in spider_iter(g): yield d




def _worker(arg):
    match, rewrite, g, kwargname, kwarg = arg
    m =  match(g, **{kwargname:kwarg})
    if m: return (len(m),rewrite(g, m))
    return None

def simp_threaded(g, name, match, rewrite, uses_verts=False,safe=False,skip_unthreaded_pass=False):
    """Version of :func:`simp` that uses :mod:`multiprocessing`."""
    nthreads = 5
    i = 0
    new_matches = True
    sep = int(g.vindex / nthreads) + 1 #TODO: currently only works on graph_s
    pool = mp.Pool(processes=nthreads)
    #Threaded pass
    print("Starting {} with {} threads".format(name,str(nthreads)))
    while new_matches:
        new_matches = False
        if uses_verts:
            chunks = [set(g.vertices_in_range(j*sep,(j+1)*sep)) for j in range(nthreads)]
            for j in range(nthreads-1):
                if chunks[j] & chunks[j+1]:
                    raise Exception("overlapping chunks")
            results = pool.map(_worker, ((match, rewrite, g, "vertexlist", chunks[j]) for j in range(nthreads)),
                                        #set(g.vertices_in_range(j*sep,(j+1)*sep))) for j in range(nthreads)),
                                chunksize=1)
        else:
            chunks = [set(g.edges_in_range(j*sep,(j+1)*sep,safe)) for j in range(nthreads)]
            for j in range(nthreads-1):
                if chunks[j] & chunks[j+1]:
                    raise Exception("overlapping chunks")
            results = pool.map(_worker, ((match, rewrite, g, "edgelist", chunks[j]) for j in range(nthreads)),
                                        #set(g.edges_in_range(j*sep,(j+1)*sep,safe))) for j in range(nthreads)),
                                chunksize=1)

        check_isolated_vertices = False
        for j,r in enumerate(results):
            if not r: continue
            new_matches = True
            amount, (etab, rem_verts, rem_edges, check) = r
            print(amount, end=',')
            if uses_verts and not chunks[j].issuperset(set(rem_verts)):
                raise Exception("Deleting vertices outside of chunk: ", chunks[j], set(rem_verts))
            else:
                for v in rem_verts:
                    if not (j*sep<v<(j+1)*sep):
                        raise Exception("Deleting vertices outside of chunk")
            g.add_edge_table(etab)
            g.remove_edges(rem_edges)
            g.remove_vertices(rem_verts)
            check_isolated_vertices = check
        if check_isolated_vertices: g.remove_isolated_vertices() 
        if new_matches: i += 1
        print('. ', end='')
    pool.close()
    #Unthreaded pass
    if not skip_unthreaded_pass:
        new_matches = True
        if i!=0: print("\nUnthreaded pass: ", end='')
        else: print("Unthreaded pass: ", end='') 
        while new_matches:
            new_matches = False
            m = match(g)
            if len(m) > 0:
                print(len(m), end='')
                etab, rem_verts, rem_edges, check_isolated_vertices = rewrite(g, m)
                g.add_edge_table(etab)
                g.remove_edges(rem_edges)
                g.remove_vertices(rem_verts)
                if check_isolated_vertices: g.remove_isolated_vertices()
                print('. ', end='')
                new_matches = True
            if new_matches: i += 1
    if i!=0:  print('\nDid ' + str(i) + ' nonzero iterations')
    else: print('Did ' + str(i) + ' nonzero iterations')


def pivot_threaded(g):
    return simp_threaded(g, 'pivot_simp', match_pivot_parallel, pivot, uses_verts=False,safe=True)

def lcomp_threaded_old(g):
    simp_threaded(g, 'lcomp_simp', match_lcomp_parallel, lcomp, uses_verts=True)

def lcomp_threaded(g):
    simp_threaded(g, 'lcomp_simp', match_lcomp_parallel, lcomp, uses_verts=True,skip_unthreaded_pass=True)
    print("Full pass: ",end='')
    nthreads = 5
    pool = mp.Pool(processes=nthreads)
    i = 0
    new_matches = True
    while new_matches:
        i += 1
        new_matches = False
        matches = match_lcomp_parallel(g)
        if len(matches) > 0:
            print(len(matches), end='')
            vs, ns = [], []
            for v, neighbours in matches:
                a = g.phase(v)
                for v2 in neighbours: g.add_to_phase(v2, -a)
                vs.append(v)
                ns.append(neighbours)
            for etab in pool.map(_lcomp_do, (ns[i:i + 10] for i in range(0, len(ns), 10))):
                g.add_edge_table(etab)
            g.remove_vertices(vs)
            print('. ', end='')
            new_matches = True
    pool.close()
    print('\nfinished in ' + str(i) + ' iterations')

def _lcomp_do(matches):
    etab = dict()
    for neighbours in matches:
        for i in range(len(neighbours)):
            for j in range(i+1, len(neighbours)):
                e = (neighbours[i],neighbours[j])
                if (e[0] > e[1]): e = (e[1],e[0])
                if e not in etab: etab[e] = [0,1]
                else: etab[e][1] += 1

    return etab

def bialg_threaded(g):
    return simp_threaded(g, 'bialg_simp', match_bialg_parallel, bialg, uses_verts=False)

def spider_threaded(g):
    return simp_threaded(g, 'spider_simp', match_spider_parallel, spider, uses_verts=False)

def id_threaded(g):
    return simp_threaded(g, 'id_simp', match_ids_parallel, remove_ids, uses_verts=True)

def clifford_threaded(g):
    spider_threaded(g)
    to_gh(g)
    lcomp_threaded(g)
    pivot_threaded(g)
    to_rg(g)
    id_threaded(g)


from pyquil import Program, get_qc
from pyquil.gates import CNOT
from pyquil.quil import Pragma
from pyquil.api import LocalQVMCompiler
from pyquil.parser import parse as parse_quil
from pyquil.quilbase import Pragma, Gate

from pyzx.parity_maps import CNOT_tracker
from pyzx.circuit import Circuit

class PyQuilCircuit(CNOT_tracker):

    def __init__(self, architecture, **kwargs):
        """
        Class to represent a PyQuil program to run on/be compiled for the given architecture
        Currently, it assumes the architecture given by create_9x9_square_architecture()

        :param architecture: The Architecture object to adhere to
        """

        super().__init__(**kwargs)
        self.qc = get_qc('9q-square-qvm')
        device = architecture.to_quil_device()
        compiler = LocalQVMCompiler(endpoint=self.qc.compiler.endpoint, device=device)
        self.qc.device = device
        self.qc.compiler = compiler
        self.n_qubits = architecture.n_qubits
        self.program = Program()
        super().__init__(self.n_qubits)
        self.retries = 0
        self.max_retries = 5
        self.compiled_program = None

    def row_add(self, q0, q1):
        """
        Adds a CNOT gate between the given qubit indices q0 and q1
        :param q0: 
        :param q1: 
        """
        self.program += CNOT(q0, q1)
        super().row_add(q0, q1)

    def col_add(self, q0, q1):
        # TODO prepend the CNOT!
        self.program += CNOT(q1, q0)
        super().col_add(q0, q1)

    def count_cnots(self):
        if self.compiled_program is None:
            return super().count_cnots()
        else:
            return self.compiled_cnot_count()

    def compiled_cnot_count(self):
        if self.compiled_program is None:
            self.compile()
        return len([g for g in self.compiled_program if isinstance(g, Gate) and g.name == "CZ"])

    def to_qasm(self):
        if self.compiled_program is None:
            return super().to_qasm()
        circuit = Circuit(self.n_qubits)
        comments = []
        for g in self.compiled_program:
            if isinstance(g, Pragma):
                wiring = " ".join(["//", g.command, "["+g.freeform_string[2:-1]+"]"])
                comments.append(wiring)
            elif isinstance(g, Gate):
                if g.name == "CZ":
                    circuit.add_gate("CZ", g.qubits[0].index, g.qubits[1].index)
                elif g.name == "RX":
                    circuit.add_gate("XPhase", g.qubits[0].index, g.params[0])
                elif g.name == "RZ":
                    circuit.add_gate("ZPhase", g.qubits[0].index, g.params[0])
                else:
                    print("Unsupported gate found!", g)

        qasm = circuit.to_qasm()
        return '\n'.join(comments+[qasm])


    def update_program(self):
        self.program = Program()
        for gate in self.gates:
            if hasattr(gate, "name") and gate.name == "CNOT":
                self.program += CNOT(gate.control, gate.target)
            else:
                print("Warning: PyquilCircuit can only be used for circuits with only CNOT gates for now.")

    @staticmethod
    def from_CNOT_tracker(circuit, architecture):
        new_circuit = PyQuilCircuit(architecture, n_qubits=circuit.qubits, name=circuit.name)
        new_circuit.gates = circuit.gates
        new_circuit.update_matrix()
        new_circuit.update_program()
        return new_circuit

    def compile(self):
        """
        Compiles the circuit/program for created quantum computer
        :return: A string that describes the compiled program in quil
        """
        try:
            ep = self.qc.compile(self.program)
            self.retries = 0
            self.compiled_program = parse_quil(ep.program)
            return ep.program
        except KeyError as e:
            print('Oops, retrying to compile.', self.retries)
            if self.retries < self.max_retries:
                self.retries += 1
                return self.compile()
            else:
                raise e
# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import json
from fractions import Fraction

__all__ = ['init', 'draw']

try:
    from IPython.display import display, HTML
    in_notebook = True
except ImportError:
    in_notebook = False
    try:
        from browser import document, html
        in_webpage = True
    except ImportError:
        in_webpage = False

# Provides functions for displaying pyzx graphs in jupyter notebooks using d3

_d3_display_seq = 0
javascript_location = '/js'

# TODO: avoid duplicate (copied from drawing.py)
def phase_to_s(a):
    if not a: return ''
    if not isinstance(a, Fraction):
        a = Fraction(a)
    ns = '' if a.numerator == 1 else str(a.numerator)
    ds = '' if a.denominator == 1 else '/' + str(a.denominator)

    # unicode 0x03c0 = pi
    return ns + '\u03c0' + ds

def draw(g, scale=None):
    global _d3_display_seq

    if not in_notebook and not in_webpage: 
        raise Exception("This method only works when loaded in a webpage or Jupyter notebook")

    if not hasattr(g, 'vertices'):
        g = g.to_graph()

    _d3_display_seq += 1
    seq = _d3_display_seq

    if scale == None:
        scale = 800 / (g.depth() + 2)
        if scale > 50: scale = 50
        if scale < 20: scale = 20

    node_size = 0.2 * scale
    if node_size < 2: node_size = 2

    w = (g.depth() + 2) * scale
    h = (g.qubit_count() + 3) * scale

    nodes = [{'name': str(v),
              'x': (g.row(v) + 1) * scale,
              'y': (g.qubit(v) + 2) * scale,
              't': g.type(v),
              'phase': phase_to_s(g.phase(v)) }
             for v in g.vertices()]
    links = [{'source': str(g.edge_s(e)),
              'target': str(g.edge_t(e)),
              't': g.edge_type(e) } for e in g.edges()]
    graphj = json.dumps({'nodes': nodes, 'links': links})
    text = """
        <div style="overflow:auto" id="graph-output-{0}"></div>
        <script type="text/javascript">
        require.config({{ baseUrl: "{1}",
                         paths: {{d3: "d3.v4.min"}} }});
        require(['pyzx'], function(pyzx) {{
            pyzx.showGraph('#graph-output-{0}',
            JSON.parse('{2}'), {3}, {4}, {5});
        }});
        </script>
        """.format(seq, javascript_location, graphj, w, h, node_size)
    if in_notebook:
        display(HTML(text))
    elif in_webpage:
        d = html.DIV(style={"overflow": "auto"}, id="graph-output-{}".format(seq))
        source = """
        require(['pyzx'], function(pyzx) {{
            pyzx.showGraph('#graph-output-{0}',
            JSON.parse('{2}'), {3}, {4}, {5});
        }});
        """.format(seq, javascript_location, graphj, w, h, node_size)
        s = html.SCRIPT(source, type="text/javascript")
        return d,s
# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

__all__ = ['draw', 'pack_circuit_nf']

try:
    import matplotlib.pyplot as plt
    from matplotlib import patches, lines, path
except:
    plt = None
from fractions import Fraction
import math

from .graph.base import BaseGraph

def phase_to_s(a):
    if not a: return ''
    if not isinstance(a, Fraction):
        a = Fraction(a)
    ns = '' if a.numerator == 1 else str(a.numerator)
    ds = '' if a.denominator == 1 else '/' + str(a.denominator)

    # unicode 0x03c0 = pi
    return ns + '\u03c0' + ds

def vcol(t):
    if not t: return 'black'
    if t == 1: return 'green'
    if t == 2: return 'red'
    return 'black'
    
def ecol(t):
    if not t: return 'black'
    if t == 1: return 'magenta'
    return 'black'


#TODO: Update this to work again
def simple_layers(g, sort):
    topo = g.as_directed(mutual=False).topological_sorting() if sort else range(len(g.vs))
    layers = len(g.vs) * [-1]
    for i in topo:
        nlayers = [layers[n.index] for n in g.vs[topo[i]].neighbors()]
        layers[topo[i]] = max(nlayers)+1 if len(nlayers) > 0 else 0
    return layers

def dag_layout(g, sort=True):
    if g.backend != 'igraph':
        raise NotImplementedError("Drawing not implemented on backend " + g.backend)
    topo = g.graph.as_directed(mutual=False).topological_sorting() if sort else range(g.num_vertices())
    layers = g.num_vertices() * [-1]
    for i in topo:
        nlayers = [layers[n.index] for n in g.graph.vs[topo[i]].neighbors()]
        layers[topo[i]] = max(nlayers)+1 if len(nlayers) > 0 else 0
    layout = g.graph.layout_sugiyama(layers=layers)
    layout.transform(lambda t: (t[1],-t[0]))
    layout.fit_into([len(layers)/(max(layers)+1),max(layers)+1])
    return layout


def pack_circuit_nf(g, nf='grg'):
    x_index = 0
    ty = g.types()

    if nf == 'grg':
        for v in g.vertices():
            if v in g.inputs:
                g.set_row(v, 0)
            elif v in g.outputs:
                g.set_row(v, 4)
            elif ty[v] == 2:
                g.set_row(v, 2)
                g.set_qubit(v, x_index)
                x_index += 1
            elif ty[v] == 1:
                for w in g.neighbours(v):
                    if w in g.inputs:
                        g.set_row(v,1)
                        g.set_qubit(v, g.qubit(w))
                        break
                    elif w in g.outputs:
                        g.set_row(v,3)
                        g.set_qubit(v, g.qubit(w))
                        break
    elif nf == 'gslc':
        for v in g.vertices():
            if v in g.inputs:
                g.set_row(v,0)
            elif v in g.outputs:
                g.set_row(v, 4)
            elif ty[v] == 1:
                for w in g.neighbours(v):
                    if w in g.inputs:
                        g.set_row(v,1)
                        #g.set_vdata(v, 'q', g.get_vdata(w, 'q'))
                        break
                    elif w in g.outputs:
                        g.set_row(v,3)
                        #g.set_vdata(v, 'q', g.get_vdata(w, 'q'))
                        break
    else:
        raise ValueError("Unknown normal form: " + str(nf))

def circuit_layout(g,keys = ('r','q')):
    return {v:(g.row(v),-g.qubit(v)) for v in g.vertices()}

def draw(g, layout=None, labels=False, figsize=(8,2), h_edge_draw='blue', rows=None):
    if not isinstance(g, BaseGraph):
        g = g.to_graph()
    fig1 = plt.figure(figsize=figsize)
    ax = fig1.add_axes([0, 0, 1, 1], frameon=False)
    ax.xaxis.set_visible(False)
    ax.yaxis.set_visible(False)
    vs_on_row = dict()  # count the vertices on each row
    for v in g.vertices():
        vs_on_row[g.row(v)] = vs_on_row.get(g.row(v), 0) + 1

    if not layout:
        layout = circuit_layout(g)

    if rows:
        minrow,maxrow = rows
        vertices = [v for v in g.vertices() if (minrow<=g.row(v) and g.row(v) <=maxrow)]
        edges = [e for e in g.edges() if g.edge_s(e) in vertices and g.edge_t(e) in vertices]
    else:
        vertices = g.vertices()
        edges = g.edges()
    
    for e in edges:
        sp = layout[g.edge_s(e)]
        tp = layout[g.edge_t(e)]
        et = g.edge_type(e)
        n_row = vs_on_row.get(g.row(g.edge_s(e)), 0)

        
        dx = tp[0] - sp[0]
        dy = tp[1] - sp[1]
        bend_wire = (dx == 0) and h_edge_draw == 'blue' and n_row > 2
        ecol = '#0099ff' if h_edge_draw == 'blue' and et == 2 else 'black'

        if bend_wire:
            bend = 0.25
            mid = (sp[0] + 0.5 * dx + bend * dy, sp[1] + 0.5 * dy - bend * dx)

            pth = path.Path([sp,mid,tp], [path.Path.MOVETO, path.Path.CURVE3, path.Path.LINETO])
            patch = patches.PathPatch(pth, edgecolor=ecol, linewidth=0.8, fill=False)
            ax.add_patch(patch)
        else:
            pos = 0.5 if dx == 0 or dy == 0 else 0.4
            mid = (sp[0] + pos*dx, sp[1] + pos*dy)
            ax.add_line(lines.Line2D([sp[0],tp[0]],[sp[1],tp[1]], color=ecol, linewidth=0.8, zorder=0))

        if h_edge_draw == 'box' and et == 2: #hadamard edge
            w = 0.2
            h = 0.15
            diag = math.sqrt(w*w+h*h)
            angle = math.atan2(dy,dx)
            angle2 = math.atan2(h,w)
            centre = (mid[0] - diag/2*math.cos(angle+angle2),
                      mid[1] - diag/2*math.sin(angle+angle2))
            ax.add_patch(patches.Rectangle(centre,w,h,angle=angle/math.pi*180,facecolor='yellow',edgecolor='black'))

        #plt.plot([sp[0],tp[0]],[sp[1],tp[1]], 'k', zorder=0, linewidth=0.8)
    
    for v in vertices:
        p = layout[v]
        t = g.type(v)
        a = g.phase(v)
        
        sz = 0.2
        col = 'black'
        if t == 1: col = 'green'
        elif t == 2: col = 'red'
        else: sz = 0.1
            
        ax.add_patch(patches.Circle(p, sz, facecolor=col, edgecolor='black', zorder=1))
        if labels: plt.text(p[0]+0.25, p[1]+0.25, str(v), ha='center', color='gray', fontsize=5)
        if a: plt.text(p[0], p[1]-0.5, phase_to_s(a), ha='center', color='blue', fontsize=8)
    
    ax.axis('equal')
    plt.close()
    return fig1
    #plt.show()

cimport cython

import math

import numpy as np
cimport numpy as np
from cpython cimport array
import array

TYPE = np.uint8
ctypedef np.uint8_t TYPE_t

cdef class Mat2:
    cpdef np.uint8_t[:,:] data
    def __init__(self, np.ndarray[TYPE_t, ndim=2] data):
        self.data = data
    
    cpdef get_data(self):
        return self.data
    
    def __str__(self):
        return "\n".join(str(list(r)) for r in self.data)
    
    cpdef Mat2 copy(self):
        return Mat2(np.asarray(self.data.copy()))
    
    cpdef Mat2 transpose(self):
        return Mat2(np.asarray(self.data).transpose().copy())
    
    cpdef int rows(self):
        return self.data.shape[0]
    
    cpdef int cols(self):
        return self.data.shape[1]
    
    @cython.boundscheck(False)
    @cython.wraparound(False)
    cdef row_add(self, int r0, int r1):
        cdef int i
        cdef np.uint8_t[:] a, b
        a = self.data[r0]
        b = self.data[r1]
        for i in range(self.cols()):
            if a[i]:
                b[i] = 0 if b[i] else 1
    
    @cython.boundscheck(False)
    @cython.wraparound(False)
    cdef col_add(self, int c0, int c1):
        cdef int i
        cdef np.uint8_t[:] d
        for i in range(self.rows()):
            d = self.data[i]
            if d[c0]:
                d[c1] = 0 if d[c1] else 1
    
    @cython.boundscheck(False)
    @cython.wraparound(False)
    cpdef int gauss(self, int full_reduce=0, int blocksize=6):
        cdef int pivot_row, sec, i0, i1, r, p, r0, r1, rank, pcol, rows, cols
        cdef array.array pcols = array.array('i',[])
        cdef dict chunks
        cdef tuple t
        
        rows = self.rows()
        cols = self.cols()
        #pcols = array.array('i',[])
        pivot_row = 0
        for sec in range(math.ceil(float(cols) / blocksize)):
            i0 = sec * blocksize
            i1 = min(cols, (sec+1) * blocksize)
            # search for duplicate chunks of 'blocksize' bits and eliminate them
            chunks = dict()
            for r in range(pivot_row, rows):
                t = tuple(self.data[r][i0:i1])
                if not any(t): continue
                if t in chunks:
                    #print('hit (down)', r, chunks[t], t, i0, i1)
                    self.row_add(chunks[t], r)
                    #if x != None: x.row_add(chunks[t], r)
                    #if y != None: y.col_add(r, chunks[t])
                else:
                    chunks[t] = r
            p = i0
            while p < i1:
                for r0 in range(pivot_row, rows):
                    if self.data[r0][p] != 0:
                        if r0 != pivot_row:
                            self.row_add(r0, pivot_row)
                            #if x != None: x.row_add(r0, pivot_row)
                            #if y != None: y.col_add(pivot_row, r0)

                        for r1 in range(pivot_row+1, rows):
                            if pivot_row != r1 and self.data[r1][p] != 0:
                                self.row_add(pivot_row, r1)
                                #if x != None: x.row_add(pivot_row, r1)
                                #if y != None: y.col_add(r1, pivot_row)
                        if full_reduce: pcols.append(p)
                        pivot_row += 1
                        break
                p += 1
        rank = pivot_row
        if full_reduce:
            pivot_row -= 1
            for sec in range(math.ceil(float(cols) / blocksize) - 1, -1, -1):
                i0 = sec * blocksize
                i1 = min(self.cols(), (sec+1) * blocksize)
                # search for duplicate chunks of 'blocksize' bits and eliminate them
                chunks = dict()
                for r in range(pivot_row, -1, -1):
                    t = tuple(self.data[r][i0:i1])
                    if not any(t): continue
                    if t in chunks:
                        #print('hit (up)', r, chunks[t], t, i0, i1)
                        self.row_add(chunks[t], r)
                        #if x != None: x.row_add(chunks[t], r)
                        #if y != None: y.col_add(r, chunks[t])
                    else:
                        chunks[t] = r
                while len(pcols) and (i0 <= pcols[len(pcols)-1] < i1):
                    pcol = pcols.pop()
                    for r in range(0, pivot_row):
                        if self.data[r][pcol]:
                            self.row_add(pivot_row, r)
                            #if x != None: x.row_add(pivot_row, r)
                            #if y != None: y.col_add(r, pivot_row)
                    pivot_row -= 1
        return rank
    
    @cython.boundscheck(False)
    @cython.wraparound(False)
    cpdef np.ndarray[TYPE_t,ndim=2] nullspace(self, int should_copy=1):
        """Returns a list of non-zero vectors that span the nullspace
        of the matrix. If the matrix has trivial kernel it returns the empty list."""
        cdef int cols, i, j
        cdef list nonpivots, pivots
        cdef Mat2 m
        cdef np.uint8_t[:] r
        cdef np.ndarray[TYPE_t,ndim=1] v
        cdef np.ndarray[TYPE_t,ndim=2] vectors
        if should_copy:
            m = self.copy()
        else:
            m = self
        m.gauss(full_reduce=True)
        cols = self.cols()
        nonpivots = list(range(cols))
        pivots = []
        for i, r in enumerate(m.data):
            for j in range(cols):
                if r[j]:
                    nonpivots.remove(j)
                    pivots.append(j)
                    break
        vectors = np.ndarray([0,cols], dtype=TYPE)
        for i in nonpivots:
            v = np.zeros(cols,dtype=TYPE)
            v[i] = 1
            for r, j in zip(m.data, pivots):
                if r[i]: v[j] = 1
            vectors = np.insert(vectors, vectors.shape[0], v, 0)
        return vectors

# cpdef ident(n):
#     i = np.identity(n, TYPE)
#     return Mat2(i)
    
# @cython.boundscheck(False)
# @cython.wraparound(False)
# cdef Mat2 xi(Mat2 m, np.ndarray[TYPE_t,ndim=1] z):
#     cdef int rows, alpha, beta, gamma, v1,v2, i, j
#     cdef np.ndarray[TYPE_t, ndim=1] ra, rb, rab, rg, rag, rbg
#     cdef np.ndarray[TYPE_t, ndim=2] data
#     cdef np.uint8_t[:] r
#     rows = m.rows()
#     data = np.ndarray([0,m.cols()], dtype=TYPE)
#     for alpha in range(rows):
#         ra = np.asarray(m.data[alpha])
#         for beta in range(alpha+1, rows):
#             rb = np.asarray(m.data[beta])
#             rab = ra*rb
#             #rab = [i*j for i,j in zip(ra,rb)]
#             for gamma in range(beta+1, rows):
#                 rg = np.asarray(m.data[gamma])
#                 rag = ra*rg
#                 rbg = rb*rg
#                 #rag = [i*j for i,j in zip(ra,rg)]
#                 #rbg = [i*j for i,j in zip(rb,rg)]
                
#                 if z[alpha]:
#                     if not z[beta]:
#                         if not z[gamma]:
#                             data = np.insert(data, data.shape[0], rbg, 0)
#                             #data.append(rbg)
#                             continue
#                         data = np.insert(data, data.shape[0], (rbg+rab)%2, 0)
#                         #data.append([0 if v1==v2 else 1 for v1,v2 in zip(rbg,rab)])
#                         continue
#                     elif not z[gamma]:
#                         data = np.insert(data, data.shape[0], (rbg+rag)%2, 0)
#                         #data.append([0 if v1==v2 else 1 for v1,v2 in zip(rbg,rag)])
#                         continue
#                     else: #z[alpha], z[beta] and z[gamma] are all true
#                         data = np.insert(data, data.shape[0], (rbg+rab+rag)%2, 0)
#                         #r = [0 if v1==v2 else 1 for v1,v2 in zip(rab,rag)]
#                         #data.append([0 if v1==v2 else 1 for v1,v2 in zip(r,rbg)])
#                         continue
#                 elif z[beta]:
#                     if z[gamma]:
#                         data = np.insert(data, data.shape[0], (rab+rag)%2, 0)
#                         #data.append([0 if v1==v2 else 1 for v1,v2 in zip(rab,rag)])
#                         continue
#                     data = np.insert(data, data.shape[0], rag, 0)
#                     #data.append(rag)
#                     continue
#                 elif z[gamma]:
#                     data = np.insert(data, data.shape[0], rab, 0)
#                     #data.append(rab.copy())
#                     continue
#     for r in m.data: 
#         data = np.insert(data, data.shape[0], np.asarray(r).copy(), 0)
#         #data.append(r.copy())            
#     return Mat2(data)

# cdef class ToddReturn:
#     cpdef int a, b
#     cpdef np.uint8_t[:] z, y
#     def __init__(self, int a, int b, np.ndarray[TYPE_t, ndim=1] z, np.ndarray[TYPE_t, ndim=1] y):
#         self.a = a
#         self.b = b
#         self.z = z
#         self.y = y

# @cython.boundscheck(False)
# @cython.wraparound(False)
# cdef ToddReturn find_todd_match(Mat2 m):
#     cdef int rows, cols, a, b, i
#     cdef np.ndarray[TYPE_t,ndim=1] z, y, r
#     cdef np.ndarray[TYPE_t,ndim=2] options
#     cdef Mat2 bigm
#     rows = m.rows()
#     cols = m.cols()
#     for a in range(cols):
#         for b in range(a+1, cols):
#             z = np.zeros(rows, dtype=TYPE)
#             #z = [0]*rows
#             for i in range(rows):
#                 r = np.asarray(m.data[i])
#                 if r[a]:
#                     if not r[b]:
#                         z[i] = 1
#                 else:
#                     if r[b]:
#                         z[i] = 1
#             bigm = xi(m, z)
#             #print(bigm, '.')
#             options = bigm.nullspace(should_copy=0)
#             #print(bigm)
#             for y in options:
#                 if y[a] + y[b] == 1: return ToddReturn(a,b,z,y)

#     return ToddReturn(-1,-1,z,y)

# @cython.boundscheck(False)
# @cython.wraparound(False)
# cdef int remove_trivial_cols(Mat2 m):
#     cdef int newcols, should_break, a, b
#     while True:
#         newcols = m.rows()
#         for a in range(newcols):
#             if not any(m.data[a]):
#                 m.data = np.delete(m.data, a, 0)
#                 #m.data.pop(a)
#                 break
#             should_break = 0
#             for b in range(a+1, newcols):
#                 if np.alltrue(np.asarray(m.data[a]) == np.asarray(m.data[b])):
#                     m.data = np.delete(m.data, b, 0)
#                     m.data = np.delete(m.data, a, 0)
#                     #m.data.pop(b)
#                     #m.data.pop(a)
#                     should_break = 1
#                     break
#             if should_break: break
#         else: # Didn't break out of for-loop so didn't find any match
#             break
#     return newcols

# @cython.boundscheck(False)
# @cython.wraparound(False)
# cdef Mat2 do_todd_single(Mat2 m):
#     cdef int a, b, i
#     cdef np.ndarray[TYPE_t, ndim=1] z, y, 
#     cdef np.uint8_t[:] c
#     cdef ToddReturn treturn
#     #startcols = m.cols()
#     treturn = find_todd_match(m)
#     a = treturn.a
#     b = treturn.b
#     z = np.asarray(treturn.z)
#     y = np.asarray(treturn.y) 
#     if a == -1: return m
#     m = m.transpose()
#     #odd_y = sum(y) % 2
#     for i,c in enumerate(m.data):
#         if not y[i]: continue
#         for j in range(len(c)):
#             if z[j]: c[j] = 0 if c[j] else 1
#     if sum(y) % 2 == 1:
#         m.data = np.insert(m.data, m.data.shape[0], z, 0)
#         #m.data.append(z)
#     m.data = np.delete(m.data,b,0)
#     m.data = np.delete(m.data,a,0)
#     #m.data.pop(b)
#     #m.data.pop(a)
    
#     remove_trivial_cols(m)
                
#     return m.transpose()

# @cython.boundscheck(False)
# @cython.wraparound(False)
# cpdef Mat2 todd_iter(Mat2 m, int quiet=1):
#     cdef int oldcols, newcols
#     m = m.transpose()
#     remove_trivial_cols(m)
#     m = m.transpose()
#     oldcols = m.cols()
#     while True:
#         m = do_todd_single(m)
#         newcols = m.cols()
#         if oldcols == newcols:
#             return m
#         if not quiet: print(oldcols-newcols)
#         oldcols = newcols
        

# cpdef f():
#     cdef Mat2 a
#     cdef np.ndarray[TYPE_t, ndim=2] l
#     l = np.random.randint(2,size=[50,200],dtype="uint8")
#     a = Mat2(l)
#     #print(a.data[0][0])
#     a.gauss(full_reduce=True)

def do_gauss(m, full_reduce=0, blocksize=6):
    m = np.asarray(m,dtype=TYPE)
    a = Mat2(m)
    a.gauss(full_reduce,blocksize)
    return np.asarray(a.get_data()).tolist()# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.


# Based on algorithm by Perdrix and Mhalla. Here is the pseudocode from
# dx.doi.org/10.1007/978-3-540-70575-8_70
#
# input : An open graph
# output: A generalised flow
#
# gFlow (V,Gamma,In,Out) =
# begin
#   for all v in Out do
#     l(v) := 0
#   end
#   return gFlowaux (V,Gamma,In,Out,1)
# end
#
# gFlowaux (V,Gamma,In,Out,k) =
# begin
#   C := {}
#   for all u in V \ Out do
#     Solve in F2 : Gamma[V \ Out, Out \ In] * I[X] = I[{u}]
#     if there is a solution X0 then
#       C := C union {u}
#       g(u) := X0
#       l(u) := k
#     end
#   end
#   if C = {} then
#     return (Out = V,(g,l))
#   else
#     return gFlowaux (V, Gamma, In, Out union C, k + 1)
#   end
# end
#

from .extract import bi_adj
from .linalg import Mat2

def gflow(g):
    l = dict()
    gflow = dict()
    for v in g.outputs:
        l[v] = 0

    inputs = set(g.inputs)
    processed = set(g.outputs)
    vertices = set(g.vertices())
    k = 1
    while True:
        correct = set()
        #unprocessed = list()
        processed_prime = [v for v in processed.difference(inputs) if any(w not in processed for w in g.neighbours(v))]
        candidates = [v for v in vertices.difference(processed) if any(w in processed_prime for w in g.neighbours(v))]
        
        zerovec = Mat2([[0] for i in range(len(candidates))])
        #print(unprocessed, processed_prime, zerovec)
        m = bi_adj(g, processed_prime, candidates)
        for u in candidates:
            vu = zerovec.copy()
            vu.data[candidates.index(u)] = [1]
            x = m.solve(vu)
            if x:
                correct.add(u)
                gflow[u] = {processed_prime[i] for i in range(x.rows()) if x.data[i][0]}
                l[u] = k

        if not correct:
            if not candidates:
                return l, gflow, k
            return None
        else:
            processed.update(correct)
            k += 1
# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

__all__ = ['tensorfy', 'compare_tensors', 'compose_tensors', 'adjoint', 'is_unitary']

try:
    import numpy as np
    np.set_printoptions(suppress=True)
except:
    np = None
from math import pi, sqrt

def Z_to_tensor(arity, phase):
    m = np.zeros([2]*arity, dtype = complex)
    m[(0,)*arity] = 1
    m[(1,)*arity] = np.exp(1j*phase)
    return m

def X_to_tensor(arity, phase):
    m = np.ones(2**arity, dtype = complex)
    for i in range(2**arity):
        if bin(i).count("1")%2 == 0: 
            m[i] += np.exp(1j*phase)
        else:
            m[i] -= np.exp(1j*phase)
    return np.power(np.sqrt(0.5),arity)*m.reshape([2]*arity)


def pop_and_shift(verts, indices):
    res = []
    for v in verts:
        res.append(indices[v].pop())
    for i in sorted(res,reverse=True):
        for w,l in indices.items():
            l2 = []
            for j in l:
                if j>i: l2.append(j-1)
                else: l2.append(j)
            indices[w] = l2
    return res

def tensorfy(g):
    """Takes in a Graph and outputs a multidimensional numpy array
    representing the linear map the ZX-diagram implements.
    Beware that quantum circuits take exponential memory to represent."""
    rows = g.rows()
    phases = g.phases()
    types = g.types()
    depth = g.depth()
    verts_row = {}
    for v in g.vertices():
        r = rows[v]
        if r in verts_row: verts_row[r].append(v)
        else: verts_row[r] = [v]
    
    had = 1/sqrt(2)*np.mat([[1,1],[1,-1]])
    id2 = np.identity(2)
    tensor = np.array(1.0)
    qubits = len(g.inputs)
    for i in range(qubits): tensor = np.tensordot(tensor,id2,axes=0)
    inputs = sorted(g.inputs,key=g.qubit)
    indices = {}
    for i, v in enumerate(inputs):
        indices[v] = [1 + 2*i]
    
    for i,r in enumerate(sorted(verts_row.keys())):
        for v in sorted(verts_row[r]):
            neigh = list(g.neighbours(v))
            d = len(neigh)
            if v in g.inputs:
                if types[v] != 0: raise ValueError("Wrong type for input:", v, types[v])
                continue # inputs already taken care of
            if v in g.outputs: 
                #print("output")
                if d != 1: raise ValueError("Weird output")
                if types[v] != 0: raise ValueError("Wrong type for output:",v, types[v])
                d += 1
                t = id2
            else:
                if types[v] == 0: raise ValueError("Non-ZX internal vertex", v)
                phase = pi*phases[v]
                t = Z_to_tensor(d,phase) if types[v] == 1 else X_to_tensor(d,phase)
            nn = list(filter(lambda n: rows[n]<r or (rows[n]==r and n<v), neigh))
            ety = {n:g.edge_type(g.edge(v,n)) for n in nn}
            nn.sort(key=lambda n: ety[n])
            for n in nn:
                if ety[n] == 2: #Hadamard edge
                    t = np.tensordot(t,had,(0,0)) # Hadamard edges are moved to the last index of t
            contr = pop_and_shift(nn,indices) #the last indices in contr correspond to hadamard contractions
            tensor = np.tensordot(tensor,t,axes=(contr,list(range(len(t.shape)-len(contr),len(t.shape)))))
            indices[v] = list(range(len(tensor.shape)-d+len(contr), len(tensor.shape)))
            
            if i % 10 == 0:
                if np.abs(tensor).max() < 10**-6: # Values are becoming too small
                    tensor *= 10**4 # So scale all the numbers up
    perm = []
    for o in sorted(g.outputs,key=g.qubit):
        perm.append(indices[o][0])
    for i in range(len(g.inputs)):
        perm.append(i)

    tensor = np.transpose(tensor,perm)
        
    return tensor

def tensor_to_matrix(t, inputs, outputs):
    """Takes a tensor generated by ``tensorfy`` and turns it into a matrix.
    The ``inputs`` and ``outputs`` arguments specify the final shape of the matrix:
    2^(outputs) x 2^(inputs)"""
    rows = []
    for r in range(2**outputs):
        o = [int(i) for i in bin(r)[2:].zfill(outputs)]
        row = []
        for c in range(2**inputs):
            a = o.copy()
            a.extend([int(i) for i in bin(c)[2:].zfill(inputs)])
            #print(a)
            #print(t[tuple(a)])
            row.append(t[tuple(a)])
        rows.append(row)
    return np.matrix(rows)

def compare_tensors(t1,t2):
    """Returns true if ``t1`` and ``t2`` are tensors equal up to a nonzero number.

    Example: To check whether two ZX-graphs are semantically the same you would do::

        t1 = tensorfy(g1)
        t2 = tensorfy(g2)
        compare_tensors(t1,t2) # True if g1 and g2 represent the same circuit
    """
    if not isinstance(t1, np.ndarray):
        t1 = t1.to_tensor()
    if not isinstance(t2, np.ndarray):
        t2 = t2.to_tensor()
    epsilon = 10**-14
    if np.allclose(t1,t2): return True
    for i,a in enumerate(t1.flat):
        if abs(a)>epsilon: 
            if abs(t2.flat[i])<epsilon: return False
            break
    else:
        raise ValueError("Tensor is too close to zero")
    return np.allclose(t1/a,t2/t2.flat[i])


def compose_tensors(t1,t2):
    """Returns a tensor that is the result of composing the tensors together as if they
    were representing circuits::

        t1 = tensorfy(circ1)
        t2 = tensorfy(circ2)
        circ1.compose(circ2)
        t3 = tensorfy(circ1)
        t4 = compose_tensors(t1,t2)
        compare_tensors(t3,t4) # This is True

    """

    if len(t1.shape) != len(t2.shape):
        raise TypeError("Tensors represent circuits of different amount of qubits, "
                        "{!s} vs {!s}".format(len(t1.shape)//2,len(t2.shape)//2))
    q = len(t1.shape)//2
    contr2 = [q+i for i in range(q)]
    contr1 = [i for i in range(q)]
    t = np.tensordot(t1,t2,axes=(contr1,contr2))
    transp = []
    for i in range(q):
        transp.append(q+i)
    for i in range(q):
        transp.append(i)
    return np.transpose(t,transp)


def adjoint(t):
    """Returns the adjoint of the tensor as if it were representing
    a circuit::

        t = tensorfy(circ)
        tadj = tensorfy(circ.adjoint())
        compare_tensors(adjoint(t),tadj) # This is True

    """
    
    q = len(t.shape)//2
    transp = []
    for i in range(q):
        transp.append(q+i)
    for i in range(q):
        transp.append(i)
    return np.transpose(t.conjugate(),transp)


def is_unitary(g):
    """Returns whether the given ZX-graph is equal to a unitary (up to a number)."""
    from .generate import identity # Imported here to prevent circularity
    adj = g.adjoint()
    adj.compose(g)
    return compare_tensors(adj.to_tensor(), identity(len(g.inputs),2).to_tensor())# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""Supplies methods to convert ZX-graphs to tikz files.
These tikz files are designed to be easily readable by the program `Tikzit <https://tikzit.github.io>`_.
"""


import tempfile
import os
import subprocess
import time

tikzit_location = None

TIKZ_BASE = """
\\begin{{tikzpicture}}
    \\begin{{pgfonlayer}}{{nodelayer}}
{vertices}
    \\end{{pgfonlayer}}
    \\begin{{pgfonlayer}}{{edgelayer}}
{edges}
    \\end{{pgfonlayer}}
\\end{{tikzpicture}}
"""

def to_tikz(g, xoffset=0, yoffset=0, idoffset=0, full_output=True):
    """Converts a ZX-graph ``g`` to a string representing a tikz diagram.
    The optional arguments are used by :func:`to_tikz_sequence`.
    """
    verts = []
    maxindex = idoffset
    for v in g.vertices():
        phase = g.phase(v)
        ty = g.type(v)
        if ty == 0:
            style = "none"
        else:
            style = 'Z' if ty==1 else 'X'
            if phase != 0: style += " phase"
            style += " dot"
        if phase == 0: phase = ""
        else:
            ns = '' if phase.numerator == 1 else str(phase.numerator)
            dn = '' if phase.denominator == 1 else str(phase.denominator)
            if dn: phase = r"$\frac{%s\pi}{%s}$" % (ns, dn)
            else: phase = r"$%s\pi$" % ns
        x = g.row(v) + xoffset
        y = - g.qubit(v) - yoffset
        s = "        \\node [style={}] ({:d}) at ({:.2f}, {:.2f}) {{{:s}}};".format(style,v+idoffset,x,y,phase)
        verts.append(s)
        maxindex = max([v+idoffset,maxindex])
    edges = []
    for e in g.edges():
        v,w = g.edge_st(e)
        ty = g.edge_type(e)
        s = "        \\draw "
        if ty == 2: 
            if g.type(v) != 0 and g.type(w) != 0:
                s += "[style=hadamard edge] "
            else:
                x = (g.row(v) + g.row(w))/2.0 +xoffset
                y = -(g.qubit(v)+g.qubit(w))/2.0 -yoffset
                t = "        \\node [style=hadamard] ({:d}) at ({:.2f}, {:.2f}) {{}};".format(maxindex+1, x,y)
                verts.append(t)
                maxindex += 1
        s += "({:d}) to ({:d});".format(v+idoffset,w+idoffset)
        edges.append(s)
    if full_output: return TIKZ_BASE.format(vertices="\n".join(verts), edges="\n".join(edges))
    else: return (verts, edges)

def to_tikz_sequence(graphs, maxwidth=10):
    """Given a list of ZX-graphs, outputs a single tikz diagram with the graphs presented in a grid.
    ``maxwidth`` is the maximum width of the diagram, before a graph is put on a new row in the tikz diagram."""
    xoffset = -maxwidth
    yoffset = -10
    idoffset = 0
    total_verts, total_edges = [],[]
    for g in graphs:
        max_index = max(g.vertices()) + 2*len(g.inputs) + 1
        verts, edges = to_tikz(g,xoffset,yoffset,idoffset,False)
        total_verts.extend(verts)
        total_edges.extend(edges)
        if xoffset + g.depth() + 2> maxwidth:
            xoffset = -maxwidth
            yoffset += g.qubit_count() + 2
        else:
            xoffset += g.depth() + 2
        idoffset += max_index

    return TIKZ_BASE.format(vertices="\n".join(total_verts), edges="\n".join(total_edges))



def tikzit(g):
    """Opens Tikzit with the graph ``g`` opened as a tikz diagram. 
    For this to work, ``zx.tikz.tikzit_location`` must be pointed towards the Tikzit executable.
    Even though this function is intended to be used with Tikzit, ``zx.tikz.tikzit_location``
    can point towards any executable that takes a tikz file as an input, such as a text processor."""

    if not tikzit_location or not os.path.exists(tikzit_location):
        print("Please point towards the Tikzit executable with tikz.tikzit_location")
        return

    with tempfile.TemporaryDirectory() as tmpdirname:
        tz = to_tikz(g)
        #print(tz)
        fname = os.path.join(tmpdirname, "graph.tikz")
        with open(fname,'w') as f:
            f.write(tz)
        print("Opening Tikzit...")
        #print(fname)
        subprocess.check_call([tikzit_location, fname])
        print("Done")
        # with open(fname, 'r') as f:
        #     js = f.read()
        #     g = json_to_graph(js)# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import os
from fractions import Fraction
import copy
import math

from .graph import Graph
from .drawing import phase_to_s

__all__ = ['Circuit', 'determine_file_type']

class Circuit(object):
    """Class for representing quantum circuits.

    This class is mostly just a wrapper for a list of gates with methods for converting
    between different representations of a quantum circuit.

    The methods in this class that convert a specification of a circuit into an instance of this class,
    generally do not check whether the specification is well-defined. If a bad input is given, 
    the behaviour is undefined."""
    def __init__(self, qubit_amount, name=''):
        self.qubits = qubit_amount
        self.gates = []
        self.name = name

    def __str__(self):
        return "Circuit({!s} qubits, {!s} gates)".format(self.qubits,len(self.gates))

    def __repr__(self):
        return str(self)

    def copy(self):
        c = Circuit(self.qubits, self.name)
        c.gates = [g.copy() for g in self.gates]
        return c

    def adjoint(self):
        c = Circuit(self.qubits, self.name + 'Adjoint')
        for g in reversed(self.gates):
            c.gates.append(g.to_adjoint())
        return c

    @staticmethod
    def from_graph(g, split_phases=True):
        """Produces a :class:`Circuit` containing the gates of the given ZX-graph.
        If the ZX-graph is not circuit-like then the behaviour of this function
        is undefined.
        ``split_phases`` governs whether nodes with phases should be split into
        Z,S, and T gates or if generic ZPhase/XPhase gates should be used."""
        c = Circuit(g.qubit_count())
        qs = g.qubits()
        rs = g.rows()
        ty = g.types()
        phases = g.phases()
        rows = {}
        for v in g.vertices():
            if v in g.inputs: continue
            r = g.row(v)
            if r in rows: rows[r].append(v)
            else: rows[r] = [v]
        for r in sorted(rows.keys()):
            for v in rows[r]:
                q = qs[v]
                phase = phases[v]
                t = ty[v]
                neigh = [w for w in g.neighbours(v) if rs[w]<r]
                if len(neigh) != 1:
                    raise TypeError("Graph doesn't seem circuit like: multiple parents")
                n = neigh[0]
                if qs[n] != q:
                    raise TypeError("Graph doesn't seem circuit like: cross qubit connections")
                if g.edge_type(g.edge(n,v)) == 2:
                    c.add_gate("HAD", q)
                if t == 0: #vertex is an output
                    continue
                if phase!=0 and not split_phases:
                    if t == 1: c.add_gate("ZPhase", q, phase=phase)
                    else: c.add_gate("XPhase", q, phase=phase)
                elif t == 1 and phase.denominator == 2:
                    c.add_gate("S", q, adjoint=(phase.numerator==3))
                elif t == 1 and phase.denominator == 4:
                    if phase.numerator in (1,7): c.add_gate("T", q, adjoint=(phase.numerator==7))
                    if phase.numerator in (3,5):
                        c.add_gate("Z", q)
                        c.add_gate("T", q, adjoint=(phase.numerator==3))
                elif phase == 1:
                    if t == 1: c.add_gate("Z", q)
                    else: c.add_gate("NOT", q)
                elif phase != 0:
                    if t == 1: c.add_gate("ZPhase", q, phase=phase)
                    else: c.add_gate("XPhase", q, phase=phase)

                neigh = [w for w in g.neighbours(v) if rs[w]==r and w<v]
                for n in neigh:
                    t2 = ty[n]
                    q2 = qs[n]
                    if t == t2:
                        if g.edge_type(g.edge(v,n)) != 2:
                            raise TypeError("Invalid vertical connection between vertices of the same type")
                        if t == 1: c.add_gate("CZ", q2, q)
                        else: c.add_gate("CX", q2, q)
                    else:
                        if g.edge_type(g.edge(v,n)) != 1:
                            raise TypeError("Invalid vertical connection between vertices of different type")
                        if t == 1: c.add_gate("CNOT", q, q2)
                        else: c.add_gate("CNOT", q2, q)
        return c

    @staticmethod
    def from_quipper_file(fname):
        """Produces a :class:`Circuit` based on a Quipper ASCII description of a circuit."""
        f = open(fname, 'r')
        text = f.read()
        lines = text.strip().splitlines()
        f.close()
        if text.find('Subroutine') == -1:
            c = parse_quipper_block(lines)
            c.name = os.path.basename(fname)
            return c
        else:
            raise TypeError("Subroutines are not supported")
        

    @staticmethod
    def from_qasm_file(fname):
        """Produces a :class:`Circuit` based on a QASM description of a circuit.
        It ignores all the non-unitary instructions like measurements in the file. 
        It currently doesn't support custom gates that have parameters."""
        f = open(fname, 'r')
        s = f.read()
        f.close()
        p = QASMParser()
        c = p.parse(s)
        c.name = os.path.basename(fname)
        return c

    @staticmethod
    def from_qc_file(fname):
        """Produces a :class:`Circuit` based on a .qc description of a circuit.
        If a Tofolli gate with more than 2 controls is encountered, ancilla qubits are added.
        Currently up to 5 controls are supported."""
        f = open(fname, 'r')
        data = f.read()
        f.close()
        preamble = data[:data.find("BEGIN")].strip().splitlines()
        labels = {}
        for l in preamble:
            if l.startswith('#'): continue
            if l.startswith('.'):
                for v in l[2:].replace(',',' ').strip().split():
                    s = v.strip()
                    if s not in labels: labels[s] = len(labels)
            else:
                raise TypeError("Unknown Expression: " + l)

        ancillas = {}
        gates = []
        qcount = len(labels)

        for l in data[data.find("BEGIN")+6:data.find("END")].splitlines():
            if l.startswith('#'): continue
            l = l.strip()
            if not l: continue
            try: gname, targets = l.split(' ',1)
            except ValueError:
                raise ValueError("Couldn't parse line {} in file {}".format(l, fname))
            gname = gname.strip().lower()
            targets = [labels[v.strip()] for v in targets.replace(',',' ').strip().split(' ') if v.strip()]
            if len(targets) == 1:
                t = targets[0]
                if gname in ('tof', 't1', 'not', 'x'): gates.append(NOT(t))
                elif gname == 'z': gates.append(Z(t))
                elif gname in ('s', 'p'): gates.append(S(t))
                elif gname in ('s*', 'p*'): gates.append(S(t,adjoint=True))
                elif gname == 't': gates.append(T(t))
                elif gname == 't*': gates.append(T(t,adjoint=True))
                elif gname == 'h': gates.append(HAD(t))
                else:
                    raise TypeError("Unknown gate with single target: " + l)
            elif len(targets) == 2:
                c,t = targets
                if gname in ('cnot', 'tof', 't2'):
                    gates.append(CNOT(c,t))
                elif gname in ('cz', 'z'):
                    gates.append(CZ(c,t))
                else:
                    raise TypeError("Unknown gate with control: " + l)
            elif len(targets) == 3:
                c1,c2,t = targets
                if gname in ('t3', 'tof'):
                    gates.append(Tofolli(c1,c2,t))
                elif gname in ('ccz', 'z'):
                    gates.append(CCZ(c1,c2,t))
                else:
                    raise TypeError("Unknown gate with control: " + l)
            else:
                if gname not in ('t4', 't5', 't6', 't7', 'tof'):
                    raise TypeError("Unknown gate with multiple controls: " + l)
                *ctrls, t = targets
                if len(ctrls) > 6: raise TypeError("No more than 5 ctrls supported")
                while len(ancillas) < len(ctrls) - 2:
                    ancillas[len(ancillas)] = qcount
                    qcount += 1
                gates.append(Tofolli(ctrls[0],ctrls[1],ancillas[0]))
                if len(ctrls) == 3:
                    gates.append(Tofolli(ctrls[2],ancillas[0],t))
                else:
                    gates.append(Tofolli(ctrls[2],ctrls[3],ancillas[1]))
                    if len(ctrls) == 4:
                        gates.append(Tofolli(ancillas[0],ancillas[1],t))
                    elif len(ctrls) == 5:
                        gates.append(Tofolli(ancillas[0],ancillas[1],ancillas[2]))
                        gates.append(Tofolli(ctrls[4],ancillas[2],t))
                        gates.append(Tofolli(ancillas[0],ancillas[1],ancillas[2]))
                    else: # len(ctrls) == 6
                        gates.append(Tofolli(ctrls[4],ctrls[5],ancillas[2]))
                        gates.append(Tofolli(ancillas[0],ancillas[1],ancillas[3]))
                        gates.append(Tofolli(ancillas[2],ancillas[3],t))
                        gates.append(Tofolli(ancillas[0],ancillas[1],ancillas[3]))
                        gates.append(Tofolli(ctrls[4],ctrls[5],ancillas[2]))
                    gates.append(Tofolli(ctrls[2],ctrls[3],ancillas[1]))
                gates.append(Tofolli(ctrls[0],ctrls[1],ancillas[0]))

        c = Circuit(qcount)
        c.gates = gates
        return c

    @staticmethod
    def load(circuitfile):
        """Tries to detect the circuit description language from the filename and its contents,
        and then tries to load the file into a circuit."""
        ext = determine_file_type(circuitfile)
        if ext == 'qc':
            return Circuit.from_qc_file(circuitfile)
        if ext == 'qasm':
            return Circuit.from_qasm_file(circuitfile)
        if ext == 'qgraph':
            raise TypeError(".qgraph files are not Circuits. Please load them as graphs using json_to_graph")
        if ext == 'quipper':
            try:
                return Circuit.from_quipper_file(circuitfile)
            except:
                return quipper_center_block(circuitfile)
        raise TypeError("Couldn't determine filetype")

    def to_basic_gates(self):
        """Returns a new circuit with every gate expanded in terms of X/Z phases, Hadamards
        and the 2-qubit gates CNOT, CZ, CX."""
        c = Circuit(self.qubits, name=self.name)
        for g in self.gates:
            c.gates.extend(g.to_basic_gates())
        return c

    def split_phase_gates(self):
        c = Circuit(self.qubits, name=self.name)
        for g in self.gates:
            if isinstance(g, (ZPhase, XPhase)):
                if not g.phase: continue
                if g.phase == 1:
                    if isinstance(g, ZPhase): c.add_gate("Z", g.target)
                    else: c.add_gate("NOT", g.target)
                    continue
                if isinstance(g, XPhase):
                    c.add_gate("HAD", g.target)
                if g.phase.denominator == 2:
                    if g.phase.numerator % 4 == 1:
                        c.add_gate("S", g.target)
                    else: c.add_gate("S", g.target, adjoint=True)
                elif g.phase.denominator == 4:   
                    n = g.phase.numerator % 8
                    if n == 3 or n == 5:
                        c.add_gate("Z", g.target)
                        n = (n-4)%8
                    if n == 1: c.add_gate("T", g.target)
                    if n == 7: c.add_gate("T", g.target, adjoint=True)
                else:
                    c.add_gate("ZPhase", g.target, g.phase)
                if isinstance(g, XPhase):
                    c.add_gate("HAD", g.target) 
            else:
                c.add_gate(g)
        return c

    def to_graph(self, compress_rows=True, backend=None):
        """Turns the circuit into a ZX-Graph.
        If ``compress_rows`` is set, it tries to put single qubit gates on different qubits,
        on the same row."""
        g = Graph(backend)
        qs = {}
        rs = {}
        for i in range(self.qubits):
            v = g.add_vertex(0,i,0)
            g.inputs.append(v)
            qs[i] = v
            rs[i] = 1

        labels = {i:i for i in range(self.qubits)}

        for gate in self.gates:
            if gate.name == 'InitAncilla':
                l = gate.label
                if l in labels:
                    raise ValueError("Ancilla label {} already in use".format(str(l)))
                q = len(labels)
                labels[l] = q
                r = max(rs.values())
                for i in rs: rs[i] = r
                rs[l] = r+1
                v = g.add_vertex(1, q, r)
                qs[l] = v
            elif gate.name == 'PostSelect':
                l = gate.label
                if l not in labels:
                    raise ValueError("PostSelect label {} is not in use".format(str(l)))
                v = g.add_vertex(1, labels[l], rs[l])
                g.add_edge((qs[l],v),1)
                r = max(rs.values())
                for i in rs: rs[i] = r+1
                del qs[l]
                del rs[l]
                del labels[l]
            else:
                if not compress_rows: #or not isinstance(gate, (ZPhase, XPhase, HAD)):
                    r = max(rs.values())
                    for i in rs: rs[i] = r
                gate.to_graph(g,labels, qs,rs)
                if not compress_rows: # or not isinstance(gate, (ZPhase, XPhase, HAD)):
                    r = max(rs.values())
                    for i in rs: rs[i] = r

        r = max(rs.values())
        for l, o in labels.items():
            v = g.add_vertex(0,o,r)
            g.outputs.append(v)
            g.add_edge((qs[l],v))

        return g

    def to_quipper(self):
        """Produces a Quipper ASCII description of the circuit."""
        s = "Inputs: " + ", ".join("{!s}Qbit".format(i) for i in range(self.qubits)) + "\n"
        for g in self.gates:
            s += g.to_quipper() + "\n"
        s += "Outputs: " + ", ".join("{!s}Qbit".format(i) for i in range(self.qubits))
        return s

    def to_qasm(self):
        """Produces a QASM description of the circuit."""
        s = """OPENQASM 2.0;\ninclude "qelib1.inc";\n"""
        s += "qreg q[{!s}];\n".format(self.qubits)
        for g in self.gates:
            s += g.to_qasm() + "\n"
        return s

    def to_qc(self):
        """Produces a .qc description of the circuit."""
        s = ".v " + " ".join("q{:d}".format(i) for i in range(self.qubits))
        s += "\n\nBEGIN\n"
        c = self.split_phase_gates()
        for g in c.gates:
            s += g.to_qc() + "\n"
        s += "END\n"
        return s


    def to_tensor(self):
        """Returns a numpy tensor describing the circuit."""
        return self.to_graph().to_tensor()
    def to_matrix(self):
        """Returns a numpy matrix describing the circuit."""
        return self.to_graph().to_matrix()

    def verify_equality(self, other):
        """Composes the other circuit with the adjoint of this circuit, and tries to reduce
        it to the identity using :func:`simplify.full_reduce``. If successful returns True,
        if not returns None. 

        Note that while a successful reduction to the identity is strong evidence that the two
        circuits are equal, if this function is not able to reduce the graph to the identity
        this does not prove anything. """
        from .simplify import full_reduce
        c = self.adjoint()
        c.add_circuit(other)
        g = c.to_graph()
        full_reduce(g)
        if g.num_vertices() == self.qubits*2:
            return True
        else:
            return False
                    

    def add_gate(self, gate, *args, **kwargs):
        """Adds a gate to the circuit. ``gate`` can either be 
        an instance of a :class:`Gate`, or it can be the name of a gate,
        in which case additional arguments should be given.

        Example::
            
            circuit.add_gate("CNOT", 1, 4) # adds a CNOT gate with control 1 and target 4
            circuit.add_gate("ZPhase", 2, phase=Fraction(3,4)) # Adds a ZPhase gate on qubit 2 with phase 3/4
        """
        if isinstance(gate, str):
            gate_class = gate_types[gate]
            gate = gate_class(*args, **kwargs)
        self.gates.append(gate)

    def add_gates(self, gates, qubit):
        """Adds a series of single qubit gates on the same qubit.
        ``gates`` should be a space-separated string of gatenames.

        Example::

            circuit.add_gates("S T H T H", 1)
        """
        for g in gates.split(" "):
            self.add_gate(g, qubit)

    def add_circuit(self, circ, mask=None):
        """Adds the gate of another circuit to this one. If ``mask`` is not given,
        then they must have the same amount of qubits and they are mapped one-to-one.
        If mask is given then it must be a list specifying to which qubits the qubits
        in the given circuit correspond. 

        Example::

            c1 = Circuit(qubit_amount=4)
            c2 = Circuit(qubit_amount=2)
            c2.add_gate("CNOT",0,1)
            c1.add_circuit(c2, mask=[0,3]) # Now c1 has a CNOT from the first to the last qubit

        """
        if not mask:
            if self.qubits != circ.qubits: raise TypeError("Amount of qubits do not match")
            self.gates.extend(circ.gates)
            return
        elif len(mask) != circ.qubits: raise TypeError("Mask size does not match qubits")
        for gate in circ.gates:
            g = gate.reposition(mask)
            self.add_gate(g)

    def tcount(self):
        """Returns the amount of T-gates necessary to implement this circuit."""
        return sum(g.tcount() for g in self.gates)
        #return sum(1 for g in self.gates if isinstance(g, (ZPhase, XPhase, ParityPhase)) and g.phase.denominator >= 4)
    
    def twoqubitcount(self):
        """Returns the amount of 2-qubit gates necessary to implement this circuit."""
        c = self.to_basic_gates()
        return sum(1 for g in c.gates if g.name in ('CNOT','CZ'))

    def stats(self):
        """Returns statistics on the amount of gates in the circuit, separated into different classes 
        (such as amount of T-gates, two-qubit gates, Hadamard gates)."""
        total = 0
        tcount = 0
        twoqubit = 0
        hadamard = 0
        clifford = 0
        other = 0
        for g in self.gates:
            total += 1
            tcount += g.tcount()
            if isinstance(g, (ZPhase, XPhase)):
                if g.phase.denominator <= 2: clifford += 1
            elif isinstance(g, HAD):
                hadamard += 1
                clifford += 1
            elif isinstance(g, (CZ,CX, CNOT)):
                twoqubit += 1
                clifford += 1
            else:
                other += 1
        s = """Circuit {} on {} qubits with {} gates.
        {} is the T-count
        {} Cliffords among which 
        {} 2-qubit gates and {} Hadamard gates.""".format(self.name, self.qubits, total, 
                tcount, clifford, twoqubit, hadamard)
        if other > 0:
            s += "\nThere are {} gates of a different type".format(other)
        return s

def determine_file_type(circuitfile):
        """Tries to figure out in which format the file is given (quipper, qasm or qc)"""
        fname = circuitfile
        ext = os.path.splitext(fname)[-1]
        if ext in ('.qc', '.tfc'):
            return "qc"
        if ext.find('qasm') != -1:
            return "qasm"
        if ext == '.qgraph':
            return "qgraph"
        if ext.find('quip') != -1:
            return "quipper"
        f = open(fname, 'r')
        data = f.read(128)
        f.close()
        if data.startswith('Inputs:'):
            return "quipper"
        if data.find('.v') != -1 or data.find('.i') != -1 or data.find('.o') != -1:
            return "qc"
        if data.find('QASM') != -1:
            return "qasm"

        raise TypeError("Couldn't determine circuit format.")

def parse_quipper_block(lines):
    start = lines[0]
    end = lines[-1]
    gates = lines[1:-1]
    if not start.startswith("Inputs: "):
        raise TypeError("File does not start correctly: " + start)
    if start.endswith(','): start = start[:-1]
    inputs = start[8:].split(",")
    
    for i in inputs:
        n, t = i.split(":")
        if t.strip() != "Qbit":
            raise TypeError("Unsupported type " + t)

    c = Circuit(len(inputs))
    for gate in gates:
        if gate.startswith("Comment"): continue
        if gate.startswith("QInit0"):
            t = int(gate[gate.find('(')+1:gate.find(')')])
            if t>=c.qubits: c.qubits = t+1
            continue
        if gate.startswith("QTerm0"): continue
        if gate.startswith("QRot"):
            i = gate.find("exp(")
            if gate[i+4:i+8] == '-i%Z':
                gtype = "ZPhase"
            elif gate[i+4:i+8] == '-i%X':
                gtype = "XPhase"
            else:
                raise TypeError("Unsupported expression: " + gate) 
            f = gate[gate.find(',')+1: gate.find(']')]
            try:
                f = float(f)
            except ValueError:
                raise TypeError("Unsupported expression: " + gate)
            phase = Fraction(f/math.pi)
            target = gate[gate.rfind('(')+1:gate.rfind(')')]
            try: 
                target = int(target)
            except ValueError:
                raise TypeError("Unsupported expression: "+ gate)
            c.add_gate(gtype, target, 2*phase)
            continue
        elif not gate.startswith("QGate"):
            raise TypeError("Unsupported expression: " + gate)
        l = gate.split("with")
        g = l[0]
        gname = g[g.find('[')+2:g.find(']')-1]
        target = int(g[g.find('(')+1:g.find(')')])
        adjoint = g.find("*")!=-1
        if len(l) == 2 and l[1].find('nocontrol')!=-1: #no controls
            if gname == "H": c.add_gate("HAD", target)
            elif gname == "not": c.add_gate("NOT", target)
            elif gname == "Z": c.add_gate("Z", target)
            elif gname == "S": c.add_gate("S", target, adjoint=adjoint)
            elif gname == "T": c.add_gate("T", target, adjoint=adjoint)
            else:
                raise TypeError("Unsupported gate: " + gname)
            continue
        elif len(l) > 3: raise TypeError("Unsupported expression: " + gate)
        ctrls = l[1]
        ctrls = ctrls[ctrls.find('[')+1:ctrls.find(']')]
        if ctrls.find(',')!=-1:
            if ctrls.count(',') != 1: raise TypeError("Maximum two controls on gate allowed: " + gate)
            if gname not in ("not", "Z"): raise TypeError("Two controls only allowed on 'not' and 'Z': "+ gate)
            c1, c2 = ctrls.split(',',1)
            ctrl1 = int(c1.strip()[1:])
            ctrl2 = int(c2.strip()[1:])
            nots = []
            if c1.find('+') == -1:
                nots.append(ctrl1)
            if c2.find('+') == -1:
                nots.append(ctrl2)
            #if ctrl1.find('+') == -1 or ctrl2.find('+') == -1: raise TypeError("Unsupported controls: " + ctrls)
            for t in nots: c.add_gate("NOT", t)
            if gname == "not": c.add_gate("TOF", ctrl1, ctrl2, target)
            elif gname == "Z": c.add_gate("CCZ", ctrl1, ctrl2, target)
            for t in nots: c.add_gate("NOT", t)
            continue
        elif ctrls.find('+')==-1:
            raise TypeError("Unsupported control: " + ctrls)
        ctrl = int(ctrls[1:])
        if gname == "not": c.add_gate("CNOT", ctrl, target)
        elif gname == "Z": c.add_gate("CZ", ctrl, target)
        elif gname == "X": c.add_gate("CX", ctrl, target)
        else:
            raise TypeError("Unsupported controlled gate: " + gname)
    return c

def quipper_center_block(fname):
    """Function to load the PF files of the NRSCM paper."""
    f = open(fname, 'r')
    text = f.read()
    f.close()
    i = text.find('Subroutine: "C"')
    if i == -1: 
        i = text.find('Subroutine: "S1"')
        if i == -1: raise Exception("Not a valid format")
        text = text[i:].strip()
    else:
        j = text.find('Subroutine: "R"',i)
        if j == -1: raise Exception("Not a valid format")
        text = text[i:j].strip()
    lines = text.splitlines()[3:]
    return parse_quipper_block(lines)

class QASMParser(object):
    """Class for parsing QASM source files into circuit descriptions."""
    def __init__(self):
        self.gates = []
        self.customgates = {}
        self.registers = {}
        self.qubit_count = 0
        self.circuit = None

    def parse(self, s):
        lines = s.splitlines()
        r = []
        #strip comments
        for s in lines:
            if s.find("//")!=-1:
                t = s[0:s.find("//")].strip()
            else: t = s.strip()
            if t: r.append(t)
        if not r[0].startswith("OPENQASM"):
            raise TypeError("File does not start with OPENQASM descriptor")
        if not r[1].startswith('include "qelib1.inc";'):
            raise TypeError("File is not importing standard library")
        data = "\n".join(r[2:])
        # Strip the custom command definitions from the normal commands
        while True:
            i = data.find("gate ")
            if i == -1: break
            j = data.find("}", i)
            self.parse_custom_gate(data[i:j+1])
            data = data[:i] + data[j+1:]
        #parse the regular commands
        commands = [s.strip() for s in data.split(";") if s.strip()]
        gates = []
        for c in commands:
            self.gates.extend(self.parse_command(c, self.registers))

        circ = Circuit(self.qubit_count)
        circ.gates = self.gates
        self.circuit = circ
        return self.circuit

    def parse_custom_gate(self, data):
        data = data[5:]
        spec, body = data.split("{",1)
        if "(" in spec:
            i = spec.find("(")
            j = spec.find(")")
            if spec[i+1:j].strip():
                raise TypeError("Arguments for custom gates are currently"
                                " not supported: {}".format(data))
            spec = spec[:i] + spec[j+1:]
        spec = spec.strip()
        if " " in spec:
            name, args = spec.split(" ",1)
            name = name.strip()
            args = args.strip()
        else:
            raise TypeError("Custom gate specification doesn't have any "
                            "arguments: {}".format(data))
        registers = {}
        qubit_count = 0
        for a in args.split(","):
            a = a.strip()
            if a in registers:
                raise TypeError("Duplicate variable name: {}".format(data))
            registers[a] = (qubit_count,1)
            qubit_count += 1

        body = body[:-1].strip()
        commands = [s.strip() for s in body.split(";") if s.strip()]
        circ = Circuit(qubit_count)
        for c in commands:
            for g in self.parse_command(c, registers):
                circ.add_gate(g)
        self.customgates[name] = circ

    def parse_command(self, c, registers):
        gates = []
        name, rest = c.split(" ",1)
        if name in ("barrier","creg","measure", "id"): return gates
        if name in ("opaque", "if"):
            raise TypeError("Unsupported operation {}".format(c))
        args = [s.strip() for s in rest.split(",") if s.strip()]
        if name == "qreg":
            regname, size = args[0].split("[",1)
            size = int(size[:-1])
            registers[regname] = (self.qubit_count, size)
            self.qubit_count += size
            return gates
        qubit_values = []
        is_range = False
        dim = 1
        for a in args:
            if "[" in a:
                regname, val = a.split("[",1)
                val = int(val[:-1])
                if not regname in registers: raise TypeError("Invalid register {}".format(regname))
                qubit_values.append([registers[regname][0]+val])
            else:
                if is_range:
                    if registers[a][1] != dim:
                        raise TypeError("Error in parsing {}: Register sizes do not match".format(c))
                else:
                    dim = registers[a][1]
                is_range = True
                s = registers[a][0]
                qubit_values.append(list(range(s,s + dim)))
        if is_range:
            for i in range(len(qubit_values)):
                if len(qubit_values[i]) != dim:
                    qubit_values[i] = [qubit_values[i][0]]*dim
        for j in range(dim):
            argset = [q[j] for q in qubit_values]
            if name in self.customgates:
                circ = self.customgates[name]
                if len(argset) != circ.qubits:
                    raise TypeError("Argument amount does not match gate spec: {}".format(c))
                for g in circ.gates:
                    gates.append(g.reposition(argset))
                continue
            if name in ("x", "z", "s", "t", "h", "sdg", "tdg"):
                if name in ("sdg", "tdg"): g = qasm_gate_table[name](argset[0],adjoint=True)
                else: g = qasm_gate_table[name](argset[0])
                gates.append(g)
                continue
            if name.startswith("rx") or name.startswith("rz"):
                i = name.find('(')
                j = name.find(')')
                if i == -1 or j == -1: raise TypeError("Invalid specification {}".format(name))
                val = name[i+1:j]
                try:
                    phase = float(val)/math.pi
                except ValueError:
                    if val.find('pi') == -1: raise TypeError("Invalid specification {}".format(name))
                    val = val.replace('pi', '')
                    val = val.replace('*','')
                    try: phase = float(val)
                    except: raise TypeError("Invalid specification {}".format(name))
                phase = Fraction(phase).limit_denominator(100000000)
                if name.startswith('rx'): g = XPhase(argset[0],phase=phase)
                else: g = ZPhase(argset[0],phase=phase)
                gates.append(g)
                continue
            if name in ("cx","CX","cz"):
                g = qasm_gate_table[name](control=argset[0],target=argset[1])
                gates.append(g)
                continue
            if name in ("ccx", "ccz"):
                g = qasm_gate_table[name](ctrl1=argset[0],ctrl2=argset[1],target=argset[2])
                gates.append(g)
                continue
            raise TypeError("Unknown gate name: {}".format(c))
        return gates


class InitAncilla:
    name = 'InitAncilla'
    def __init__(self, label):
        self.label = label

class PostSelect:
    name = 'PostSelect'
    def __init__(self, label):
        self.label = label


class Gate(object):
    """Base class for representing quantum gates."""
    index = 0
    def __str__(self):
        attribs = []
        if hasattr(self, "control"): attribs.append(str(self.control))
        if hasattr(self, "target"): attribs.append(str(self.target))
        if hasattr(self, "phase") and self.printphase: attribs.append("phase={!s}".format(self.phase))
        return "{}{}({})".format(self.name,("*" if (hasattr(self,"adjoint") and self.adjoint) else ""), ",".join(attribs))

    def __repr__(self):
        return str(self)

    def __eq__(self, other):
        if type(self) != type(other): return False
        for a in ["target","control","phase","adjoint"]:
            if hasattr(self,a):
                if not hasattr(other,a): return False
                if getattr(self,a) != getattr(other,a): return False
            elif hasattr(other,a): return False
        if self.index != other.index: return False
        return True

    def copy(self):
        return copy.copy(self)

    def to_adjoint(self):
        g = self.copy()
        if hasattr(g, "phase"):
            g.phase = -g.phase
        if hasattr(g, "adjoint"):
            g.adjoint = not g.adjoint
        return g

    def tcount(self):
        return 0

    def reposition(self, mask):
        g = self.copy()
        if hasattr(g, "target"):
            g.target = mask[g.target]
        if hasattr(g, "control"):
            g.control = mask[g.control]
        return g

    def to_basic_gates(self):
        return [self]

    def to_quipper(self):
        n = self.name if not hasattr(self, "quippername") else self.quippername
        if n == 'undefined':
            raise TypeError("Gate {} doesn't have a Quipper description".format(str(self)))
        s = 'QGate["{}"]{}({!s})'.format(n,("*" if (hasattr(self,"adjoint") and self.adjoint) else ""),self.target)
        if hasattr(self, "control"):
            s += ' with controls=[+{!s}]'.format(self.control)
        s += ' with nocontrol'
        return s

    def to_qasm(self):
        n = self.qasm_name
        if n == 'undefined':
            raise TypeError("Gate {} doesn't have a QASM description".format(str(self)))
        if hasattr(self, "adjoint") and self.adjoint:
            n = self.qasm_name_adjoint

        args = []
        for a in ["ctrl1","ctrl2", "control", "target"]:
            if hasattr(self, a): args.append("q[{:d}]".format(getattr(self,a)))
        param = ""
        if hasattr(self, "printphase") and self.printphase:
            param = "({}*pi)".format(float(self.phase))
        return "{}{} {};".format(n, param, ", ".join(args))

    def to_qc(self):
        n = self.qc_name
        if hasattr(self, "adjoint") and self.adjoint:
            n += "*"
        if n == 'undefined':
            raise TypeError("Gate {} doesn't have a .qc description".format(str(self)))
        args = []
        for a in ["ctrl1","ctrl2", "control", "target"]:
            if hasattr(self, a): args.append("q{:d}".format(getattr(self,a)))
        
        # if hasattr(self, "printphase") and self.printphase:
        #     args.insert(0, phase_to_s(self.phase))
        return "{} {}".format(n, " ".join(args))

    def graph_add_node(self, g, labels, qs, t, q, r, phase=0):
        v = g.add_vertex(t,labels[q],r,phase)
        g.add_edge((qs[q],v))
        qs[q] = v
        return v

class ZPhase(Gate):
    name = 'ZPhase'
    printphase = True
    qasm_name = 'rz'
    qc_name = 'undefined'
    def __init__(self, target, phase):
        self.target = target
        self.phase = phase
        self.name 

    def to_graph(self, g, labels, qs, rs):
        self.graph_add_node(g,labels, qs,1,self.target,rs[self.target],self.phase)
        rs[self.target] += 1

    def to_quipper(self):
        if not self.printphase:
            return super().to_quipper()
        return 'QRot["exp(-i%Z)",{!s}]({!s})'.format(math.pi*self.phase/2,self.target)

    def tcount(self):
        return 1 if self.phase.denominator > 2 else 0


class Z(ZPhase):
    name = 'Z'
    qasm_name = 'z'
    qc_name = 'Z'
    printphase = False
    def __init__(self, target):
        super().__init__(target, Fraction(1,1))

class S(ZPhase):
    name = 'S'
    qasm_name = 's'
    qasm_name_adjoint = 'sdg'
    qc_name = 'S'
    printphase = False
    def __init__(self, target, adjoint=False):
        super().__init__(target, Fraction(1,2)*(-1 if adjoint else 1))
        self.adjoint = adjoint

class T(ZPhase):
    name = 'T'
    qasm_name = 't'
    qasm_name_adjoint = 'tdg'
    qc_name = 'T'
    printphase = False
    def __init__(self, target, adjoint=False):
        super().__init__(target, Fraction(1,4)*(-1 if adjoint else 1))
        self.adjoint = adjoint

class XPhase(Gate):
    name = 'XPhase'
    printphase = True
    qasm_name = 'rx'
    qc_name = 'undefined'
    def __init__(self, target, phase=0):
        self.target = target
        self.phase = phase

    def to_graph(self, g, labels, qs, rs):
        self.graph_add_node(g,labels, qs,2,self.target,rs[self.target],self.phase)
        rs[self.target] += 1

    def to_quipper(self):
        if not self.printphase:
            return super().to_quipper()
        return 'QRot["exp(-i%X)",{!s}]({!s})'.format(math.pi*self.phase/2,self.target)

    def tcount(self):
        return 1 if self.phase.denominator > 2 else 0


class NOT(XPhase):
    name = 'NOT'
    quippername = 'not'
    qasm_name = 'x'
    qc_name = 'X'
    printphase = False
    def __init__(self, target):
        super().__init__(target, phase = Fraction(1,1))

class HAD(Gate):
    name = 'HAD'
    quippername = 'H'
    qasm_name = 'h'
    qc_name = 'H'
    def __init__(self, target):
        self.target = target

    def to_graph(self, g, labels, qs, rs):
        v = g.add_vertex(1,labels[self.target],rs[self.target])
        g.add_edge((qs[self.target],v),2)
        qs[self.target] = v
        rs[self.target] += 1

class CNOT(Gate):
    name = 'CNOT'
    quippername = 'not'
    qasm_name = 'cx'
    qc_name = 'Tof'
    def __init__(self, control, target):
        self.target = target
        self.control = control
    def to_graph(self, g, labels, qs, rs):
        r = max(rs[self.target],rs[self.control])
        t = self.graph_add_node(g,labels, qs,2,self.target,r)
        c = self.graph_add_node(g,labels, qs,1,self.control,r)
        g.add_edge((t,c))
        rs[self.target] = r+1
        rs[self.control] = r+1

class CZ(Gate):
    name = 'CZ'
    quippername = 'Z'
    qasm_name = 'cz'
    qc_name = 'Z'
    def __init__(self, control, target):
        self.target = target
        self.control = control
    def __eq__(self,other):
        if self.index != other.index: return False
        if (isinstance(other, type(self)) and (
            (self.target == other.target and self.control == other.control) or
            (self.target == other.control and self.control == other.target))):
            return True
        return False

    def to_graph(self, g, labels, qs, rs):
        r = max(rs[self.target],rs[self.control])
        t = self.graph_add_node(g,labels, qs,1,self.target,r)
        c = self.graph_add_node(g,labels, qs,1,self.control,r)
        g.add_edge((t,c),2)
        rs[self.target] = r+1
        rs[self.control] = r+1


class ParityPhase(Gate):
    name = 'ParityPhase'
    quippername = 'undefined'
    qasm_name = 'undefined'
    qc_name = 'undefined'
    printphase = True
    def __init__(self, phase, *targets):
        self.targets = targets
        self.phase = phase

    def __eq__(self, other):
        if self.index != other.index: return False
        if isinstance(other, type(self)) and set(self.targets) == set(other.targets) and self.phase == other.phase:
            return True
        return False

    def __str__(self):
        return "ParityPhase({!s}, {!s})".format(self.phase, ", ".join(str(t) for t in self.targets))

    def reposition(self, mask):
        g = self.copy()
        g.targets = [mask[t] for t in g.targets]
        return g

    def to_basic_gates(self):
        cnots = [CNOT(self.targets[i],self.targets[i+1]) for i in range(len(self.targets)-1)]
        p = ZPhase(self.targets[-1], self.phase)
        return cnots + [p] + list(reversed(cnots))

    def to_graph(self, g, labels, qs, rs):
        for gate in self.to_basic_gates():
            gate.to_graph(g, labels, qs, rs)

    def tcount(self):
        return 1 if self.phase.denominator > 2 else 0


class CX(CZ):
    name = 'CX'
    quippername = 'X'
    qasm_name = 'undefined'
    def to_graph(self, g, labels, qs, rs):
        r = max(rs[self.target],rs[self.control])
        t = self.graph_add_node(g,labels, qs,2,self.target,r)
        c = self.graph_add_node(g,labels, qs,2,self.control,r)
        g.add_edge((t,c),2)
        rs[self.target] = r+1
        rs[self.control] = r+1

class SWAP(CZ):
    name = 'SWAP'
    quippername = 'undefined'
    qasm_name = 'undefined'

    def to_basic_gates(self):
        c1 = CNOT(self.control, self.target)
        c2 = CNOT(self.target, self.control)
        return [c1,c2,c1]

    def to_graph(self, g, labels, qs, rs):
        for gate in self.to_basic_gates():
            gate.to_graph(g, labels, qs,rs)

class Tofolli(Gate):
    name = 'Tof'
    quippername = 'not'
    qasm_name = 'ccx'
    qc_name = 'Tof'
    def __init__(self, ctrl1, ctrl2, target):
        self.target = target
        self.ctrl1 = ctrl1
        self.ctrl2 = ctrl2
    def __str__(self):
        return "{}(c1={!s},c2={!s},t={!s})".format(self.name,self.ctrl1,self.ctrl2,self.target)
    def __eq__(self, other):
        if self.index != other.index: return False
        if type(self) != type(other): return False
        if (self.target == other.target and 
            ((self.ctrl1 == other.ctrl1 and self.ctrl2 == other.ctrl2) or
             (self.ctrl1 == other.ctrl2 and self.ctrl2 == other.ctrl1))): return True
        return False

    def tcount(self):
        return 7

    def reposition(self, mask):
        g = self.copy()
        g.target = mask[g.target]
        g.ctrl1 = mask[g.ctrl1]
        g.ctrl2 = mask[g.ctrl2]
        return g

    def to_basic_gates(self):
        mask = [self.ctrl1, self.ctrl2, self.target]
        return [g.reposition(mask) for g in self.circuit_rep.gates]

    def to_graph(self, g, labels, qs, rs):
        for gate in self.to_basic_gates():
            gate.to_graph(g, labels, qs, rs)

    def to_quipper(self):
        s = 'QGate["{}"]({!s})'.format(self.quippername,self.target)
        s += ' with controls=[+{!s},+{!s}]'.format(self.ctrl1,self.ctrl2)
        s += ' with nocontrol'
        return s


class CCZ(Tofolli):
    name = 'CCZ'
    quippername = 'Z'
    qasm_name = 'ccz'
    qc_name = 'Z'

gate_types = {
    "XPhase": XPhase,
    "NOT": NOT,
    "ZPhase": ZPhase,
    "Z": Z,
    "S": S,
    "T": T,
    "CNOT": CNOT,
    "CZ": CZ,
    "ParityPhase": ParityPhase,
    "CX": CX,
    "SWAP": SWAP,
    "HAD": HAD,
    "TOF": Tofolli,
    "CCZ": CCZ,
    "InitAncilla": InitAncilla,
    "PostSelect": PostSelect
}

qasm_gate_table = {
    "x": NOT,
    "z": Z,
    "s": S,
    "t": T,
    "sdg": S,
    "tdg": T,
    "h": HAD,
    "cx": CNOT,
    "CX": CNOT,
    "cz": CZ,
    "ccx": Tofolli,
    "ccz": CCZ,
}

QASM_TOFOLLI = """OPENQASM 2.0;
include "qelib1.inc";

gate ccx a,b,c
{
h c;
cx b,c; tdg c;
cx a,c; t c;
cx b,c; tdg c;
cx a,c; t b; t c; h c;
cx a,b; t a; tdg b;
cx a,b;
}

qreg q[3];
ccx q[0], q[1], q[2];
"""

QASM_CCZ = """OPENQASM 2.0;
include "qelib1.inc";

gate ccx a,b,c
{
cx b,c; tdg c;
cx a,c; t c;
cx b,c; tdg c;
cx a,c; t b; t c; h c;
cx a,b; t a; tdg b;
cx a,b;
h c;
}

qreg q[3];
ccx q[0], q[1], q[2];
"""

Tofolli.circuit_rep = QASMParser().parse(QASM_TOFOLLI)
CCZ.circuit_rep = QASMParser().parse(QASM_CCZ)
# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import math
try:
    from .linalg_c import do_gauss as gauss_fast
except ImportError:
   gauss_fast = None

class Mat2(object):
    """A matrix over Z2, with methods for multiplication, primitive row and column
    operations, Gaussian elimination, rank, and epi-mono factorisation."""
    
    @staticmethod
    def id(n):
        return Mat2([[1 if i == j else 0
            for j in range(n)] 
              for i in range(n)])

    def __init__(self, data):
        self.data = data
    def __mul__(self, m):
        return Mat2([[sum(self.data[i][k] * m.data[k][j] for k in range(len(m.data))) % 2
                      for j in range(len(m.data[0]))] for i in range(len(self.data))])
    def __eq__(self, other):
        if not isinstance(other, Mat2): return False
        if self.rows() != other.rows() or self.cols() != other.cols(): return False
        return all(self.data[i][j] == other.data[i][j] for i in range(len(self.data)) for j in range(len(self.data[i])))
    def __str__(self):
        return "\n".join("[ " + 
            "  ".join(str(value) for value in row) +
            " ]" for row in self.data)
    def __repr__(self):
        return str(self)
    def copy(self):
        return Mat2([list(row) for row in self.data])
    def transpose(self):
        return Mat2([[self.data[i][j] for i in range(self.rows())] for j in range(self.cols())])
    def rows(self):
        return len(self.data)
    def cols(self):
        return len(self.data[0]) if (len(self.data) != 0) else 0
    def row_add(self, r0, r1):
        """Add r0 to r1"""
        row1 = self.data[r0]
        row2 = self.data[r1]
        for i, v in enumerate(row1):
            if v:
                row2[i] = 0 if row2[i] else 1
        # for i in range(len(row1)): row1[i] = (row)
        # for i in range(self.cols()):
        #     self.data[r1][i] = (self.data[r0][i] + self.data[r1][i]) % 2
    def col_add(self, c0, c1):
        """Add r0 to r1"""
        for i in range(self.rows()):
            d = self.data[i]
            if d[c0]:
                d[c1] = 0 if d[c1] else 1
            #self.data[i][c1] = (self.data[i][c0] + self.data[i][c1]) % 2
    def row_swap(self, r0, r1):
        """Swap the rows r0 and r1"""
        r = self.data[r0]
        self.data[r0] = self.data[r1]
        self.data[r1] = r
    def col_swap(self, c0, c1):
        """Swap the columns c0 and c1"""
        for r in range(self.rows()):
            v = self.data[r][c0]
            self.data[r][c0] = self.data[r][c1]
            self.data[r][c1] = v

    
    def gauss(self, full_reduce=False, x=None, y=None, blocksize=6):
        """Compute the echelon form. Returns the number of non-zero rows in the result, i.e.
        the rank of the matrix.

        The parameter 'full_reduce' determines whether to compute the full row-reduced form,
        useful e.g. for matrix inversion and CNOT circuit synthesis.

        The parameter 'blocksize' gives the size of the blocks in a block matrix for
        performing Patel/Markov/Hayes optimisation, see:

        K. Patel, I. Markov, J. Hayes. Optimal Synthesis of Linear Reversible
        Circuits. QIC 2008

        If blocksize is given as self.cols(), then
        this is equivalent to just eliminating duplicate rows before doing normal
        Gaussian elimination.

        Contains two convenience parameters for saving the primitive row operations. Suppose
        the row-reduced form of m is computed as:

        g * m = m'

        Then, x --> g * x and y --> y * g^-1.

        Note x and y need not be matrices. x can be any object that implements the method
        row_add(), and y any object that implements col_add().
        """

        rows = self.rows()
        cols = self.cols()
        pcols = []
        pivot_row = 0
        for sec in range(math.ceil(cols / blocksize)):
            i0 = sec * blocksize
            i1 = min(cols, (sec+1) * blocksize)

            # search for duplicate chunks of 'blocksize' bits and eliminate them
            chunks = dict()
            for r in range(pivot_row, rows):
                t = tuple(self.data[r][i0:i1])
                if not any(t): continue
                if t in chunks:
                    #print('hit (down)', r, chunks[t], t, i0, i1)
                    self.row_add(chunks[t], r)
                    if x != None: x.row_add(chunks[t], r)
                    if y != None: y.col_add(r, chunks[t])
                else:
                    chunks[t] = r

            p = i0
            while p < i1:
                for r0 in range(pivot_row, rows):
                    if self.data[r0][p] != 0:
                        if r0 != pivot_row:
                            self.row_add(r0, pivot_row)
                            if x != None: x.row_add(r0, pivot_row)
                            if y != None: y.col_add(pivot_row, r0)

                        for r1 in range(pivot_row+1, rows):
                            if pivot_row != r1 and self.data[r1][p] != 0:
                                self.row_add(pivot_row, r1)
                                if x != None: x.row_add(pivot_row, r1)
                                if y != None: y.col_add(r1, pivot_row)
                        if full_reduce: pcols.append(p)
                        pivot_row += 1
                        break
                p += 1
        
        rank = pivot_row

        if full_reduce:
            pivot_row -= 1

            for sec in range(math.ceil(cols / blocksize) - 1, -1, -1):
                i0 = sec * blocksize
                i1 = min(cols, (sec+1) * blocksize)

                # search for duplicate chunks of 'blocksize' bits and eliminate them
                chunks = dict()
                for r in range(pivot_row, -1, -1):
                    t = tuple(self.data[r][i0:i1])
                    if not any(t): continue
                    if t in chunks:
                        #print('hit (up)', r, chunks[t], t, i0, i1)
                        self.row_add(chunks[t], r)
                        if x != None: x.row_add(chunks[t], r)
                        if y != None: y.col_add(r, chunks[t])
                    else:
                        chunks[t] = r

                while len(pcols) != 0 and i0 <= pcols[-1] < i1:
                    pcol = pcols.pop()
                    for r in range(0, pivot_row):
                        if self.data[r][pcol] != 0:
                            self.row_add(pivot_row, r)
                            if x != None: x.row_add(pivot_row, r)
                            if y != None: y.col_add(r, pivot_row)
                    pivot_row -= 1

        return rank

    def rank(self):
        """Returns the rank of the matrix."""
        m = self.copy()
        return m.gauss()

    def factor(self):
        """Produce a factorisation m = m0 * m1, where

        m0.cols() = m1.rows() = m.rank()
        """
        
        # identity matrix
        m0 = Mat2.id(self.rows())
        
        # copy of m (aka self)
        m1 = self.copy()
        
        # produce m1 := g * m and m0 := g^-1. Hence, m0 * m1 = m.
        rank = m1.gauss(y = m0)
        
        # throw away zero rows in m1, and their corresponding columns in m0
        m0 = Mat2([[row[i] for i in range(rank)] for row in m0.data])
        m1 = Mat2([m1.data[i] for i in range(rank)])
        return (m0, m1)

    def inverse(self):
        """Returns the inverse of m is invertible and None otherwise."""
        if self.rows() != self.cols(): return None
        m = self.copy()
        inv = Mat2.id(self.rows())
        rank = m.gauss(x=inv, full_reduce=True)
        if rank < self.rows(): return None
        else: return inv

    def solve(self, b):
        """Return a vector x such that M * x = b, or None if there is no solution."""
        m = self.copy()
        x = b.copy()
        rank = m.gauss(x=x, full_reduce=True)

        # check for inconsistencies, i.e. zero LHS with non-zero RHS
        i = x.rows() - 1
        while i > rank - 1:
            if x.data[i][0] != 0:
                return None
            i -= 1
        if x.rows() > m.cols():
            x.data[0] = x.data[0][:m.cols()]
        else:
            x.data[0] = x.data[0] + [[0]]*(m.cols()-x.rows())
        return x

    def nullspace(self, should_copy=True):
        """Returns a list of non-zero vectors that span the nullspace
        of the matrix. If the matrix has trivial kernel it returns the empty list."""
        if gauss_fast:
            data = gauss_fast(self.data,1)
            m = Mat2(data)
        elif should_copy:
            m = self.copy()
            m.gauss(full_reduce=True)
        else:
            m = self
            m.gauss(full_reduce=True)
        cols = self.cols()
        nonpivots = list(range(cols))
        pivots = []
        for i, r in enumerate(m.data):
            for j in range(cols):
                if r[j]:
                    nonpivots.remove(j)
                    pivots.append(j)
                    break
        vectors = []
        for n in nonpivots:
            v = [0]*cols
            v[n] = 1
            for r, p in zip(m.data, pivots):
                if r[n]: v[p] = 1
            vectors.append(v)
        return vectors

    def to_cnots(self, optimize=False):
        """Returns a list of CNOTs that implements the matrix as a reversible circuit of qubits."""
        if not optimize:
            cn = CNOTMaker()
            self.copy().gauss(full_reduce=True,x=cn, blocksize=5)
        else:
            best = 1000000
            best_cn = None
            for size in range(1,self.rows()):
                cn = CNOTMaker()
                self.copy().gauss(full_reduce=True,x=cn, blocksize=size)
                if len(cn.cnots) < best:
                    best = len(cn.cnots)
                    best_cn = cn
            cn = best_cn
        return cn.cnots # list(reversed(cn.cnots)) 

from .circuit import CNOT
class CNOTMaker:
    def __init__(self):
        self.cnots = []
    def row_add(self, r1, r2):
        self.cnots.append(CNOT(r2,r1))



def xor_rows(l1, l2):
    return [0 if l1[i]==l2[i] else 1 for i in range(len(l1))]

def find_minimal_sums(m):
    """Returns a list of rows in m that can be added together to reduce one of the rows so that
    it only contains a single 1. Used in :func:`greedy_reduction`"""
    r = m.rows()
    d = m.data
    if any(sum(r)==1 for r in d): return []
    combs = {(i,):d[i] for i in range(r)}
    combs2 = {}
    iterations = 0
    while True:
        combs2 = {}
        for index,l in combs.items():
            for k in range(max(index)+1,r):
                #Unrolled xor_rows(combs[index],d[k])
                row = [0 if v1==v2 else 1 for v1,v2 in zip(combs[index],d[k])]
                #row = xor_rows(combs[index],d[k])
                if sum(row) == 1:
                    return (*index,k)
                combs2[(*index,k)] = row
                iterations += 1
            if iterations > 100000:
                return None
        if not combs2:
            return None
            #raise ValueError("Irreducible input has been given")
        combs = combs2

def greedy_reduction(m):
    """Returns a list of tuples (r1,r2) that specify which row should be added to which other row
    in order to reduce one row of m to only contain a single 1. 
    Used in :func:`extract.streaming_extract`"""
    indices = find_minimal_sums(m)
    if not isinstance(indices, (list,tuple)): return indices
    indices = list(indices)
    rows = {i:m.data[i] for i in indices}
    weights = {i: sum(r) for i,r in rows.items()}
    result = []
    while len(indices)>1:
        best = (-1,-1)
        reduction = -10000
        for i in indices:
            for j in indices:
                if j <= i: continue
                w = sum(xor_rows(rows[i],rows[j]))
                if weights[i] - w > reduction:
                    best = (j,i) # "Add row j to i"
                    reduction = weights[i] - w
                if weights[j] - w > reduction:
                    best = (i,j)
                    reduction = weights[j] - w
        result.append(best)
        control, target = best
        rows[target] = xor_rows(rows[control],rows[target])
        weights[target] = weights[target] - reduction
        indices.remove(control)
    return result



def column_optimal_swap(m):
    qubits = min([m.rows(), m.cols()])
    connections = {i: set() for i in range(qubits)}
    connectionsr= {j: set() for j in range(qubits)}

    for i in range(qubits):
            for j in range(qubits):
                if m.data[i][j]: 
                    connections[i].add(j)
                    connectionsr[j].add(i)

    target = _find_targets(connections, connectionsr)
    target = {v:k for k,v in target.items()}
    left = list(set(range(qubits)).difference(target.keys()))
    right = list(set(range(qubits)).difference(target.values()))
    for i in range(len(left)):
        target[left[i]] = right[i]
    return target


def _find_targets(conn, connr, target={}):
    target = target.copy()
    qubits = len(conn)
    claimedr = set(target.values())
    claimed = set(target.keys())
    
    while True:
        min_index = -1
        min_options = set(range(1000))
        for i in range(qubits):
            if i in claimed: continue
            s = conn[i] - claimedr
            for i2 in s.copy(): # Go trough the possible options
                for j1 in (connr[i2] - claimed): 
                    if j1 != i and j1 in target and i in connr[target[j1]]: # i connected to j2
                        #This is not allowed
                        #print("not allowed1:", i, i2)
                        s.remove(i2)
                        break
            if len(s) == 0: return None # No possible options, start backtracking
            if len(s) == 1:
                j = s.pop()
                #print("forced1", i,j)
                target[i] = j
                claimed.add(i)
                claimedr.add(j)
                break
            should_break = False
            for i2 in s:
                t = connr[i2] - claimed
                for i1 in t.copy():
                    for j1 in connr[i2]:
                        if j1 != i1 and j1 in target and i1 in connr[target[j1]]: 
                            #print("not allowed2:", i1, j1)
                            t.remove(i1)
                            break
                if len(t) == 0: return None
                if len(t) == 1: # we must connect them together
                    i1 = t.pop()
                    #print("forced2", i1,i2)
                    target[i1] = i2
                    claimed.add(i1)
                    claimedr.add(i2)
                    should_break = True
                    break
            if should_break: break
            if len(s) < len(min_options):
                min_index = i
                min_options = s
        else: # No forced decisions
            if not (conn.keys() - claimed): # we are done
                return target
            if min_index == -1: raise ValueError("This shouldn't happen ever")
            # Start depth-first search
            tgt = target.copy()
            #print("backtracking on", min_index)
            for i2 in min_options:
                #print("trying option", i2)
                tgt[min_index] = i2
                r = _find_targets(conn, connr, tgt)
                if r: return r
            #print("Unsuccessful")
            return target
            # PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

from __future__ import print_function

__all__ = ['clifford_extract', 'streaming_extract']

from fractions import Fraction
import itertools

from .linalg import Mat2, greedy_reduction, column_optimal_swap
from .graph import Graph
from .simplify import id_simp, tcount
from .rules import match_spider_parallel, spider
from .circuit import Circuit, ParityPhase, CNOT, HAD, ZPhase, CZ, InitAncilla


def bi_adj(g, vs, ws):
    return Mat2([[1 if g.connected(v,w) else 0 for v in vs] for w in ws])

def cut_rank(g, left, right):
    return bi_adj(g, left, right).rank()

def cut_edges(g, left, right, available=None):
    m = bi_adj(g, left, right)
    max_r = max(g.row(v) for v in left)
    for v in g.vertices():
        r = g.row(v)
        if (r > max_r):
            g.set_row(v, r+2)
    x,y = m.factor()

    for v1 in left:
        for v2 in right:
            if (g.connected(v1,v2)):
                g.remove_edge(g.edge(v1,v2))
    
    cut_rank = y.rows()

    #g.add_vertices(2*cut_rank)
    left_verts = []
    right_verts = []
    
    if available == None:
        qs = range(cut_rank)
    else:
        qs = available

    for i in qs:
        v1 = g.add_vertex(1,i,max_r+1)
        v2 = g.add_vertex(1,i,max_r+2)
        #v = vi+cut_rank+i
        #g.add_edge((vi+i,v))
        g.add_edge((v1,v2),2)
        left_verts.append(v1)
        right_verts.append(v2)
        #g.set_edge_type(g.edge(vi+i,v), 2)

    for i in range(y.rows()):
        for j in range(y.cols()):
            if (y.data[i][j]):
                g.add_edge((left[j],left_verts[i]),2)
                #g.add_edge((left[j], vi + i))
                #g.set_edge_type(g.edge(left[j], vi + i), 2)
    for i in range(x.rows()):
        for j in range(x.cols()):
            if (x.data[i][j]):
                g.add_edge((right_verts[j],right[i]),2)
                #g.add_edge((vi + cut_rank + j, right[i]))
                #g.set_edge_type(g.edge(vi + cut_rank + j, right[i]), 2)
    return left_verts


def unspider_by_row(g, v):
    r = g.row(v)
    w = g.add_vertex(1,g.qubit(v),r-1)
    for n in list(g.neighbours(v)):
        if g.row(n) < r:
            e = g.edge(n,v)
            g.add_edge((n,w), edgetype=g.edge_type(e))
            g.remove_edge(e)
    g.add_edge((w, v))
    return w

def connectivity_from_biadj(g, m, left, right, edgetype=2):
    for i in range(len(right)):
        for j in range(len(left)):
            if m.data[i][j] and not g.connected(right[i],left[j]):
                g.add_edge((right[i],left[j]),edgetype)
            elif not m.data[i][j] and g.connected(right[i],left[j]):
                g.remove_edge((right[i],left[j]))

def streaming_extract(g, allow_ancillae=False, quiet=True, stopcount=-1):
    """Given a graph put into semi-normal form by :func:`simplify.full_reduce`, 
    it extracts its equivalent set of gates into an instance of :class:`circuit.Circuit`.
    """
    g.normalise()
    qs = g.qubits() # We are assuming that these are objects that update...
    rs = g.rows()   # ...to reflect changes to the graph, so that when...
    ty = g.types()  # ... g.set_row/g.set_qubit is called, these things update directly to reflect that
    phases = g.phases()
    c = Circuit(g.qubit_count())
    leftrow = 1
    maxq = max(qs.values()) + 1

    nodestotal = tcount(g)
    nodesparsed = 0
    nodesmarker = 10

    # special_nodes contains the ParityPhase like nodes
    special_nodes = {}
    for v in g.vertices():
        if len(list(g.neighbours(v))) == 1 and v not in g.inputs and v not in g.outputs:
            n = list(g.neighbours(v))[0]
            special_nodes[n] = v
        if rs[v] > 1:
            g.set_row(v, rs[v]+20)
    
    tried_id_simp = False
    while True:
        left = [v for v in g.vertices() if rs[v] == leftrow]
        boundary_verts = []
        right = set()
        good_verts = []
        good_neighs = []
        postselects = []
        for v in left:
            # First we add the gates to the circuit that can be processed now,
            # and we simplify the graph to represent this.
            q = qs[v]
            phase = phases[v]
            t = ty[v]
            neigh = [w for w in g.neighbours(v) if rs[w]<leftrow]
            if len(neigh) != 1:
                raise TypeError("Graph doesn't seem circuit like: multiple parents")
            n = neigh[0]
            if qs[n] != q:
                raise TypeError("Graph doesn't seem circuit like: cross qubit connections")
            if g.edge_type(g.edge(n,v)) == 2:
                c.add_gate("HAD", q)
                g.set_edge_type(g.edge(n,v),1)
            if t == 0: continue # it is an output
            if phase != 0:
                if phase.denominator > 2: nodesparsed += 1
                if t == 1: c.add_gate("ZPhase", q, phase=phase)
                else: c.add_gate("XPhase", q, phase=phase)
                g.set_phase(v, 0)
        for v in left:
            q = qs[v]
            t = ty[v]
            neigh = [w for w in g.neighbours(v) if rs[w]==leftrow and w<v]
            for n in neigh:
                t2 = ty[n]
                q2 = qs[n]
                if t == t2:
                    if g.edge_type(g.edge(v,n)) != 2:
                        raise TypeError("Invalid vertical connection between vertices of the same type")
                    if t == 1: c.add_gate("CZ", q2, q)
                    else: c.add_gate("CX", q2, q)
                else:
                    if g.edge_type(g.edge(v,n)) != 1:
                        raise TypeError("Invalid vertical connection between vertices of different type")
                    if t == 1: c.add_gate("CNOT", q, q2)
                    else: c.add_gate("CNOT", q2, q)
                g.remove_edge(g.edge(v,n))
            
            # Done processing gates, now we look to see if we can shift the frontier
            d = [w for w in g.neighbours(v) if rs[w]>leftrow]
            right.update(d)
            if len(d) == 0: 
                if not allow_ancillae: raise TypeError("Not circuit like")
                else:
                    postselects.append(v)
            if len(d) == 1: # Only connected to one node in its future
                if ty[d[0]] != 0: # which is not an output
                    good_verts.append(v) # So we can make progress
                    good_neighs.append(d[0])
                else:  # This node is done processing, since it is directly (and only) connected to an output
                    boundary_verts.append(v)
                    right.remove(d[0])
        for v in postselects:
            if not quiet: print("postselect", v, qs[v])
            c.add_gate("PostSelect", qs[v])
            left.remove(v)
            g.set_row(v, leftrow-0.5)
            if qs[v] == maxq - 1:
                maxq = maxq -1
        if not good_verts:  # There are no 'easy' nodes we can use to progress
            if all(ty[v] == 0 for v in right): break # Actually we are done, since only outputs are left
            for v in boundary_verts: left.remove(v) # We don't care about the nodes only connected to outputs
            have_removed_gadgets = False
            for n in right.intersection(special_nodes): # Neighbours that are phase gadgets
                targets = set(g.neighbours(n))
                targets.remove(special_nodes[n])
                if targets.issubset(left): # Only connectivity on the lefthandside, so we can extract it
                    nphase = phases[n]
                    if nphase not in (0,1):
                        raise Exception("Can't parse ParityPhase with non-Pauli Phase")
                    phase = phases[special_nodes[n]]
                    c.add_gate("ParityPhase", phase*(-1 if nphase else 1), *[qs[t] for t in targets])
                    g.remove_vertices([special_nodes[n],n])
                    nodesparsed += 1
                    right.remove(n)
                    del special_nodes[n]
                    have_removed_gadgets = True
            if stopcount != -1 and len(c.gates) > stopcount: return c
            if have_removed_gadgets: continue
            right = list(right)
            m = bi_adj(g,right,left)
            m2 = m.copy()
            m2.gauss(full_reduce=True)
            if not any(sum(l)==1 for l in m2.data):
                if not tried_id_simp:
                    tried_id_simp = True
                    i = id_simp(g, matchf=lambda v: rs[v]>leftrow, quiet=True)
                    if i: 
                        if not quiet: print("id_simp found some matches")
                        m = match_spider_parallel(g, matchf=lambda e: rs[g.edge_s(e)]>=leftrow and rs[g.edge_t(e)]>=leftrow)
                        m = [(v1,v2) if v1 in left else (v2,v1) for v1,v2 in m]
                        if not quiet and m: print("spider fusion found some matches")
                        etab, rem_verts, not_needed1, not_needed2 = spider(g, m)
                        g.add_edge_table(etab)
                        g.remove_vertices(rem_verts)
                        continue
                try:
                    gates, lr = handle_phase_gadget(g, left, set(right), special_nodes, quiet=quiet)
                except ValueError:
                    if not allow_ancillae:
                        raise
                    raise Exception
                    gates, maxq = find_ancilla_qubits(g, left, set(right), special_nodes, maxq, quiet=quiet)
                    c.gates.extend(gates)
                    continue
                c.gates.extend(gates)
                nodesparsed += 1
                tried_id_simp = False
                if lr > leftrow:
                    for v in boundary_verts:
                        g.set_row(v, lr)
                    leftrow = lr
                continue
            sequence = greedy_reduction(m) # Find the optimal set of CNOTs we can apply to get a frontier we can work with
            if not isinstance(sequence, list): # Couldn't find any reduction, hopefully we can fix this
                right = set(right)
                gates, success = try_greedy_cut(g, left, right, right.difference(special_nodes), quiet=quiet)
                if success:
                    c.gates.extend(gates)
                    continue
                raise Exception("We should never get here")
                
            if not quiet: print("Greedy reduction with {:d} CNOTs".format(len(sequence)))
            for control, target in sequence:
                c.add_gate("CNOT", qs[left[target]], qs[left[control]])
                # If a control is connected to an output, we need to add a new node.
                for v in g.neighbours(left[control]):
                    if v in g.outputs:
                        #print("Adding node before output")
                        q = qs[v]
                        r = rs[v]
                        w = g.add_vertex(1,q,r-1)
                        e = g.edge(left[control],v)
                        et = g.edge_type(e)
                        g.remove_edge(e)
                        g.add_edge((left[control],w),2)
                        g.add_edge((w,v),3-et)
                        k = right.index(v)
                        right[k] = w
                        break
                for k in range(len(m.data[control])): # We update the graph to represent the extraction of a CNOT
                    if not m.data[control][k]: continue
                    if m.data[target][k]: g.remove_edge((left[target],right[k]))
                    else: g.add_edge((left[target],right[k]), 2)
                m.row_add(control, target)
            for v in left:
                d = [w for w in g.neighbours(v) if rs[w]>leftrow]
                if len(d) == 1 and ty[d[0]] != 0:
                    good_verts.append(v)
                    good_neighs.append(d[0])
            if not good_verts: continue
        
        for v in g.vertices():
            if rs[v] < leftrow: continue
            if v in good_verts: continue
            g.set_row(v,rs[v]+1) # Push the frontier one layer up
        for i,v in enumerate(good_neighs): 
            g.set_row(v,leftrow+1) # Bring the new nodes of the frontier to the correct position
            g.set_qubit(v,qs[good_verts[i]])

        tried_id_simp = False

        if not quiet and nodesparsed > nodesmarker:
            print("{:d}/{:d}".format(nodesparsed, nodestotal))
            nodesmarker = int(round(nodesparsed-5,-1))
            nodesmarker += 10
        leftrow += 1
        if stopcount != -1 and len(c.gates) > stopcount: return c
            
    swap_map = {}
    leftover_swaps = False
    for v in left: # Finally, check for the last layer of Hadamards, and see if swap gates need to be applied.
        q = qs[v]
        neigh = [w for w in g.neighbours(v) if rs[w]>leftrow]
        if len(neigh) != 1: 
            raise TypeError("Algorithm failed: Not fully reducable")
            return c
        n = neigh[0]
        if ty[n] != 0: 
            raise TypeError("Algorithm failed: Not fully reducable")
            return c
        if g.edge_type(g.edge(n,v)) == 2:
            c.add_gate("HAD", q)
            g.set_edge_type(g.edge(n,v),1)
        if qs[n] != q: leftover_swaps = True
        swap_map[q] = qs[n]
    if leftover_swaps: 
        for t1, t2 in permutation_as_swaps(swap_map):
            c.add_gate("SWAP", t1, t2)
    return c


def try_greedy_cut(g, left, right, candidates, quiet=True):
    q = len(left)
    left = list(left)
    # Take care nothing is connected directly to an output
    for w in right.copy():
        if w in g.outputs:
            w2 = g.add_vertex(1, g.qubit(w), g.row(w)-1)
            n = list(g.neighbours(w))[0] # Outputs should have unique neighbours
            e = g.edge(n,w)
            et = g.edge_type(e)
            g.remove_edge(e)
            g.add_edge((n,w2),2)
            g.add_edge((w2,w),3-et)
            right.remove(w)
            right.add(w2)
            if w in candidates:
                candidates.remove(w)
                candidates.add(w2)

    right = list(right)
    # We want to figure out which vertices in candidates are 'pivotable'
    # That is, that removing them will decrease the cut rank of the remainder
    m = bi_adj(g, right, left)
    m.gauss(full_reduce=True) # Gaussian elimination doesn't change this property
    good_nodes = []
    for r in m.data:
        if sum(r) == 1: # Exactly one nonzero value, so removing the column with the nonzero value...
            i = next(i for i in range(len(r)) if r[i]) # ...decreases the rank of the matrix
            w = right[i]
            if w in candidates:
                good_nodes.append(w)
    if not good_nodes:
        return [], False
    right = [w for w in right if w not in good_nodes]

    new_right = cut_edges(g, left, right)
    leftrow = g.row(left[0])
    for w in good_nodes: 
        g.set_row(w, leftrow+2)
        new_right.append(unspider_by_row(g, w))

    left.sort(key=g.qubit)
    qs = [g.qubit(v) for v in left]
    m = bi_adj(g, new_right, left)
    target = column_optimal_swap(m)
    for i, j in target.items():
        g.set_qubit(new_right[i],qs[j])
    new_right.sort(key=g.qubit)
    m = bi_adj(g, new_right, left)
    gates = m.to_cnots(optimize=True)
    for cnot in gates:
        cnot.target = qs[cnot.target]
        cnot.control = qs[cnot.control]
    for i in range(q):
        for j in range(q):
            if g.connected(left[i],new_right[j]):
                if i != j:
                    g.remove_edge(g.edge(left[i],new_right[j]))
            elif i == j:
                g.add_edge((left[i],new_right[j]), 2)
    if not quiet: print("Greedy extract with {:d} nodes and {:d} CNOTs".format(len(good_nodes),len(gates)))
    return gates, True



def handle_phase_gadget(g, left, neigh, special_nodes, quiet=True):
    """Tries to find a cut of the graph at the given leftrow so that a single phase-gadget can be extracted.
    Returns a list of extracted gates and modifies the graph g in place. Used by :func:`streaming_extract`"""
    q = len(left)
    qs = g.qubits() # We are assuming this thing automatically updates
    rs = g.rows()
    leftrow = rs[left[0]]
    gadgets = neigh.intersection(special_nodes) # These are the phase gadgets that are attached to the left row
    if len(gadgets) == 0: raise ValueError("No phase gadget connected to this row")
    all_verts = neigh.union(left).union(special_nodes.values())
    right = list(neigh)
    options = []
    for gadget in gadgets:
        if all(w in all_verts for w in g.neighbours(gadget)):
            options.append(gadget)
    #print(options)
    for o in options: # We move the candidates gadgets to the end of the list
        right.remove(o)
        right.append(o)
    #print(right)
    m = bi_adj(g, right, left+options)
    r = reduce_bottom_rows(m, q)
    gadget = options[r-len(left)] # This is a gadget that works
    right.remove(gadget)

    g.set_row(gadget,leftrow+1)
    g.set_row(special_nodes[gadget],leftrow+1)

    # Take care nothing is connected directly to an output
    for i in range(len(right)):
        w = right[i]
        if w in g.outputs:
            w2 = g.add_vertex(1, qs[w], rs[w]-1)
            n = list(g.neighbours(w))[0] # Outputs should have unique neighbours
            e = g.edge(n,w)
            et = g.edge_type(e)
            g.remove_edge(e)
            g.add_edge((n,w2),2)
            g.add_edge((w2,w),3-et)
            right[i] = w2

    if len(right) == q:
        if not quiet: print("No cutting necessary")
        for w in right:
            g.set_row(w, leftrow+2)
    else:
        right = cut_edges(g, left+[gadget], right)
    # We have now prepared the stage to do the extraction of the phase gadget
    
    phase = g.phase(special_nodes[gadget])
    phase = -1*phase if g.phase(gadget) != 0 else phase
    left.sort(key=g.qubit)
    qv = [qs[v] for v in left]
    m = bi_adj(g, right, left)
    target = column_optimal_swap(m)
    for i, j in target.items():
        g.set_qubit(right[i],qv[j])
    right.sort(key=g.qubit)

    m = bi_adj(g, right, left)
    if m.rank() != q:
        raise Exception("Rank in phase gadget reduction too low.")
    operations = Circuit(q)
    operations.row_add = lambda r1,r2: operations.gates.append((r1,r2))
    m.gauss(full_reduce=True,x=operations)
    gates = [CNOT(qv[r2],qv[r1]) for r1,r2 in operations.gates]
    m = bi_adj(g, right+[gadget], left)
    for r1,r2 in operations.gates:
        m.row_add(r1,r2)
    connectivity_from_biadj(g, m, right+[gadget], left)

    # Now the connections from the left to the right are like the identity
    # with some wires coming to the gadget from the left and from the right
    gadget_left = [v for v in left if g.connected(gadget, v)]
    gadget_right = [w for w in right if g.connected(gadget, w)]
    targets = [qs[v] for v in gadget_left]
    # We bring as many connections on the right to the left
    for i in reversed(range(len(gadget_right))): # The following checks if every phase connected node is on the right
        w = gadget_right[i]
        v = next(v for v in left if g.connected(w,v))
        g.set_edge_type((v,w),1)
        g.set_qubit(w, qs[v])
        if qs[w] not in targets:
            gates.append(HAD(qs[w]))
            gadget_right.pop(i)
            targets.append(qs[w])
            gadget_left.append(v)
        else:
            g.set_row(w, leftrow+1)

    if not gadget_right: #Only connected on leftside so we are done
        if not quiet: print("Simple phase gadget")
        gate = ParityPhase(phase, *targets)
        g.remove_vertices([special_nodes[gadget],gadget])
        gates.append(gate)
        return gates, leftrow
    
    if not quiet: print("Complicated phase gadget") # targets on left and right, so need to do more
    if len(gadget_right) % 2 != 0 or len(gadget_left) == 1:
        raise Exception("Gadget seems non-unitary")
    
    #Now we can finally extract the phase gadget
    rtargets = []
    for w in gadget_right: 
        t = qs[w]
        rtargets.append(t)
        gates.extend([HAD(t),ZPhase(t,Fraction(-1,2)),HAD(t)])
    if len(gadget_right)%4 != 0: # This is either 2 or 0
        phase = (-phase)%2
    gates.append(ParityPhase(phase, *targets))
    for t in rtargets:
        gates.extend([HAD(t),ZPhase(t, Fraction(1,2))])
    for v in left:
        if qs[v] not in rtargets:
            g.set_row(v, leftrow+1)

    g.remove_vertices([special_nodes[gadget],gadget])
    return gates, leftrow+1

def reduce_bottom_rows(m, qubits):
    """Using just row_add's from the first qubit rows in m, tries to find a row that can be 
    completely zero'd out. Returns the rownumber of this row when successful."""
    cols = m.cols()
    leading_one = {}
    adds = []
    for r in range(qubits):
        while True:
            i = next(i for i in range(cols) if m.data[r][i])
            if i in leading_one:
                m.row_add(leading_one[i],r)
                adds.append((leading_one[i],r))
            else:
                leading_one[i] = r
                break
    for r in range(qubits, m.rows()):
        while True:
            if not any(m.data[r]): 
                return r
            i = next(i for i in range(cols) if m.data[r][i])
            if i not in leading_one: break
            m.row_add(leading_one[i], r)
            adds.append((leading_one[i],r))
    raise ValueError("Did not find any completely reducable row")

def find_ancilla_qubits(g, left, right, gadgets, maxq, quiet=True):
    leftrow = g.row(left[0])
    nodes = list(right.difference(gadgets))
    right = list(right)
    for w in nodes:
        right.remove(w)
        right.append(w)
    m = bi_adj(g, right, left)
    m.gauss(full_reduce=True)
    candidates = []
    ancilla_count = 100000
    for row in m.data:
        if not any(row[:-len(nodes)]):
            verts = [right[i] for i,a in enumerate(row) if a]
            if len(verts) < ancilla_count:
                candidates = [verts]
                ancilla_count = len(verts)
            elif len(verts) == ancilla_count:
                candidates.append(verts)
    if not candidates:
        raise ValueError("No valid ancilla vertices found")
    if not quiet: print("Adding {:d} ancillas".format(ancilla_count-1))
    if len(candidates) == 1:
        ancillas = candidates[0][:-1]
    else:
        all_candidates = set()
        for cand in candidates: all_candidates.update(cand)
        best_set = None
        best_count = 100000
        for poss in itertools.combinations(all_candidates, ancilla_count-1):
            s = sum(1 for cand in candidates if all(v in cand for v in poss))
            if s < best_count:
                best_count = s
                best_set = poss
        ancillas = best_set

    gates = []
    for i, v in enumerate(ancillas):
        g.set_row(v, leftrow)
        g.set_qubit(v, maxq+i)
        w = g.add_vertex(1, maxq+i, leftrow-1)
        g.add_edge((v,w),1)
        gates.append(InitAncilla(maxq+i))
    #raise Exception
    return gates, maxq+len(ancillas)




def permutation_as_swaps(perm):
    """Returns a series of swaps the realises the given permutation. 
    Permutation should be a dictionary with both keys and values taking values in 0,1,...,n."""
    swaps = []
    l = [perm[i] for i in range(len(perm))]
    pinv = {v:k for k,v in perm.items()}
    linv = [pinv[i] for i in range(len(pinv))]
    for i in range(len(perm)):
        if l[i] == i: continue
        t1 = l[i]
        t2 = linv[i]
        swaps.append((i,t2))
        #l[i] = i
        #linv[i] = i
        l[t2] = t1
        linv[t1] = t2
    return swaps




class CNOTMaker(object):
    def __init__(self, qubits, cnot_swaps=False):
        self.qubits = qubits
        self.cnot_swaps = cnot_swaps
        self.g = Graph()
        self.qs = list(range(qubits))  # tracks qubit indices of vertices
        self.v = 0                     # next vertex to add
        self.r = 0                     # current row
        
        for i in range(qubits):
            self.add_node(i, 0, False)
            self.g.inputs.append(self.v)
            self.v += 1
        self.r += 1
    
    def finish(self):
        for i in range(self.qubits):
            self.add_node(i, 0)
            self.g.outputs.append(self.v-1)
        self.r += 1
    
    def add_node(self, q, t, update_index=True):
        self.g.add_vertex(t,q,self.r)
        if update_index:
            self.g.add_edge((self.qs[q],self.v))
            self.qs[q] = self.v
            self.v += 1
    
    def row_swap(self, r1, r2):
        #print("row_swap", r1,r2)
        if self.cnot_swaps:
            self.row_add(r1, r2)
            self.row_add(r2, r1)
            self.row_add(r1, r2)
        else:
            self.add_node(r1, 1)
            self.add_node(r2, 1)
            self.r += 1
            self.add_node(r1, 1, False)
            self.g.add_edge((self.qs[r2],self.v))
            self.v += 1
            self.add_node(r2, 1, False)
            self.g.add_edge((self.qs[r1],self.v))
            self.qs[r1] = self.v - 1
            self.qs[r2] = self.v
            self.v += 1
            self.r += 1
    
    def row_add(self, r1, r2):
        #print("row_add", r1,r2)
        self.add_node(r1, 1)
        self.add_node(r2, 2)
        self.g.add_edge((self.qs[r1],self.qs[r2]))
        self.r += 1


def clifford_extract(g, left_row, right_row, cnot_blocksize=2):
    """When ``left_row`` and ``right_row`` are adjacent rows of green nodes
    that are interconnected with Hadamard edges, that section of the graph
    is equal to some permutation matrix. This permutation matrix can be 
    decomposed as a series of CNOT gates. That is what this function does. """
    qubits = g.qubit_count()
    qleft = [v for v in g.vertices() if g.row(v)==left_row]
    qright= [v for v in g.vertices() if g.row(v)==right_row]
    qleft.sort(key=g.qubit)
    qright.sort(key=g.qubit)
    for q in range(qubits):
        no_left = False
        if len(qleft) <= q or g.qubit(qleft[q]) != q: #missing vertex
            vert = max((v for v in g.vertices() if g.qubit(v)==q and g.row(v)<left_row), key=g.row)
            neigh = [n for n in g.neighbours(vert) if g.qubit(n)==q and g.row(n)>=right_row]
            if neigh:
                conn = min(neigh,key=g.row)
            else:
                neigh = [n for n in g.neighbours(vert) if g.row(n)>=right_row]
                if len(neigh) > 1: raise TypeError("Too many neighbours")
                conn = neigh[0]
            e = g.edge(vert, conn)
            t = g.edge_type(e)
            g.remove_edge(e)
            v1 = g.add_vertex(1,q,left_row)
            g.add_edge((vert,v1),3-t)
            g.add_edge((v1,conn), 2)
            qleft.insert(q,v1)
            no_left = True
        else:
            v1 = qleft[q]
        if len(qright) <= q or g.qubit(qright[q]) != q: #missing vertex
            if no_left: vert = conn
            else: vert = min((v for v in g.vertices() if g.qubit(v)==q and g.row(v)>right_row), key=g.row)
            neigh = [n for n in g.neighbours(vert) if g.qubit(n)==q and g.row(n)<=left_row]
            if neigh:
                conn2 = max(neigh,key=g.row)
                if v1 != conn2: raise TypeError("vertices mismatching")
            else:
                neigh = [n for n in g.neighbours(vert) if g.row(n)==left_row]
                if len(neigh) > 1: raise TypeError("Too many neighbours")
                conn2 = neigh[0]
            e = g.edge(conn2,vert)
            t = g.edge_type(e)
            g.remove_edge(e)
            v2 = g.add_vertex(1,q,right_row)
            g.add_edge((conn2,v2),2)
            g.add_edge((v2,vert),3-t)
            qright.insert(q,v2)

    if len(qleft) != len(qright):
        raise ValueError("Amount of qubits should match on left and right side")
    m = bi_adj(g,qleft,qright)
    if m.rank() != qubits:
        raise ValueError("Adjency matrix rank does not match amount of qubits")
    for v in qright:
       g.set_type(v,2)
       for e in g.incident_edges(v):
           if (g.row(g.edge_s(e)) <= right_row
               and g.row(g.edge_t(e)) <= left_row): continue
           g.set_edge_type(e,3-g.edge_type(e)) # 2 -> 1, 1 -> 2
    c = CNOTMaker(qubits, cnot_swaps=True)
    m.gauss(full_reduce=True,x=c,blocksize=cnot_blocksize)
    c.finish()

    g.replace_subgraph(left_row, right_row, c.g.adjoint())



def simple_extract(g, quiet=True):
    g.normalise()
    qs = g.qubits() # We are assuming that these are objects that update...
    rs = g.rows()   # ...to reflect changes to the graph, so that when...
    ty = g.types()  # ... g.set_row/g.set_qubit is called, these things update directly to reflect that
    phases = g.phases()
    
    h = Graph()
    
    qindex = {}
    depth = 0
    for i in range(len(g.inputs)):
        v = h.add_vertex(0,i,depth)
        h.inputs.append(v)
        qindex[i] = v
    depth = 1
    
    def add_phase_gate(q, phase):
        nonlocal depth
        v = h.add_vertex(1, q, depth, phase)
        h.add_edge((qindex[q],v),1)
        qindex[q] = v
        depth += 1
        return v
    def add_hadamard(q):
        nonlocal depth
        v = h.add_vertex(1, q, depth)
        h.add_edge((qindex[q],v),2)
        qindex[q] = v
        depth += 1
        return v
    def add_cnot(ctrl, tgt):
        nonlocal depth
        v1 = h.add_vertex(1, ctrl, depth)
        v2 = h.add_vertex(2, tgt, depth)
        h.add_edges([(qindex[ctrl],v1),(qindex[tgt],v2),(v1,v2)],1)
        qindex[ctrl] = v1
        qindex[tgt] = v2
        depth += 1
        return v1,v2
    def add_cz(ctrl, tgt):
        nonlocal depth
        v1 = h.add_vertex(1, ctrl, depth)
        v2 = h.add_vertex(1, tgt, depth)
        h.add_edges([(qindex[ctrl],v1),(qindex[tgt],v2)],1)
        h.add_edge((v1,v2),2)
        qindex[ctrl] = v1
        qindex[tgt] = v2
        depth += 1
        return v1,v2
    
    def add_gadget(targets, phase):
        nonlocal depth
        verts = {q:h.add_vertex(1,q,depth) for q in targets}
        axel = h.add_vertex(2,-1,depth+0.5)
        leaf = h.add_vertex(1,-2,depth+0.5,phase)
        h.add_edges([(qindex[q],verts[q]) for q in targets] + [(verts[q],axel) for q in targets] + [(axel,leaf)], 1)
        for q in targets: qindex[q] = verts[q]
        depth += 1
        return targets, axel, leaf
    
    def add_nonlocal_gadget(qubits, vertices, phase):
        nonlocal depth
        new_verts = {q:h.add_vertex(1,q,depth) for q in qubits}
        axel = h.add_vertex(2,-1,depth+0.5)
        leaf = h.add_vertex(1,-2,depth+0.5,phase)
        h.add_edges([(qindex[q],new_verts[q]) for q in qubits] + [(new_verts[q],axel) for q in qubits] + 
                    [(v,axel) for v in vertices] + [(axel,leaf)], 1)
        for q in qubits: qindex[q] = new_verts[q]
        depth += 1
        return new_verts, axel, leaf
    
    leftrow = 1
    #maxq = max(qs.values()) + 1
    
    gadgets = {}
    nodes = [] # Non phase-gadgets
    for v in g.vertices(): # Find which vertices are gadgets
        if rs[v] > 1: g.set_row(v, rs[v]+20)
        if v in g.inputs or v in g.outputs: continue
        if len(list(g.neighbours(v))) == 1: #phase gadget
            n = list(g.neighbours(v))[0]
            gadgets[n] = v
        elif all(w in g.inputs or w in g.outputs or len(list(g.neighbours(w)))!=1 for w in g.neighbours(v)): # regular vertex
            nodes.append(v)
    
    nodestotal = len(nodes)
    nodesparsed = 0
    nodestotal = 19
    
    processed_targets = {}
    while True:
        left = [v for v in g.vertices() if rs[v] == leftrow]
        for v in left:
            # First we add the gates to the circuit that can be processed now,
            # and we simplify the graph to represent this.
            q = qs[v]
            phase = phases[v]
            t = ty[v]
            if t != 1: raise TypeError("Only supports zx-diagrams in graph-like state")
            neigh = [w for w in g.neighbours(v) if rs[w]<leftrow]
            if len(neigh) != 1:
                raise TypeError("Graph doesn't seem circuit like: multiple parents")
            n = neigh[0]
            if qs[n] != q:
                raise TypeError("Graph doesn't seem circuit like: cross qubit connections")
            if g.edge_type(g.edge(n,v)) == 2:
                add_hadamard(q)
                g.set_edge_type(g.edge(n,v),1)
            #if t == 0: continue # it is an output
            if phase != 0:
                add_phase_gate(q, phase)
                g.set_phase(v, 0)
        
        boundary_verts = []
        neighbours = set()
        for v in left: # Parse CZ gates between frontier
            q = qs[v]
            neigh = [w for w in g.neighbours(v) if rs[w]==leftrow and w<v]
            for n in neigh:
                q2 = qs[n]
                if g.edge_type(g.edge(v,n)) != 2:
                    raise TypeError("Invalid vertical connection between vertices of the same type")
                add_cz(q2, q)
                g.remove_edge(g.edge(v,n))
            d = [w for w in g.neighbours(v) if rs[w]>leftrow]
            neighbours.update(d)
        
        for w in neighbours: # Phase gadget stuff
            if w in gadgets:
                tgts = set(g.neighbours(w))
                tgts.remove(gadgets[w])
                if tgts.issubset(left):
                    add_gadget([qs[v] for v in tgts], phases[gadgets[w]])
                    g.remove_vertex(gadgets[w])
                    g.remove_vertex(w)
                elif tgts.issubset(left+list(processed_targets.keys())):
                    qubits = [qs[v] for v in left if v in tgts]
                    verts = [processed_targets[v] for v in tgts if v in processed_targets]
                    add_nonlocal_gadget(qubits,verts, phases[gadgets[w]])
                    g.remove_vertex(gadgets[w])
                    g.remove_vertex(w)
        neighbours = set()
        for v in left.copy(): # Deal with frontier connected to outputs
            d = [w for w in g.neighbours(v) if rs[w]>leftrow]
            if any(w in g.outputs for w in d):
                if len(d) == 1:
                    left.remove(v)
                    continue
                b = [w for w in d if w in g.outputs][0]
                if all(w in gadgets or w==b for w in d):
                    processed_targets[v] = add_phase_gate(qs[v],0)
                    left.remove(v)
                    continue
                else:
                    q = qs[b]
                    r = rs[b]
                    w = g.add_vertex(1,q,r-1)
                    nodes.append(w)
                    e = g.edge(v,b)
                    et = g.edge_type(e)
                    g.remove_edge(e)
                    g.add_edge((v,w),2)
                    g.add_edge((w,b),3-et)
                    d.remove(b)
                    d.append(w)
            neighbours.update(d)
                
        if not left: break # We are done
        right = [w for w in neighbours if w in nodes] # Only get non-phase-gadget neighbours
        m = bi_adj(g,right,left)
        #print(m)
#         target = column_optimal_swap(m)
#         right = [right[j] for (i,j) in sorted(target,key=lambda x:x[0])]
#         m = bi_adj(g,right,left)
#         print()
#         print(m)
        neighbours.difference_update(right)
        neighbours = right + list(neighbours)
        cnots = m.to_cnots()
        m2 = bi_adj(g, neighbours, left)
        for cnot in cnots:
            m.row_add(cnot.target,cnot.control)
            m2.row_add(cnot.target, cnot.control)
            add_cnot(qs[left[cnot.control]],qs[left[cnot.target]])
        connectivity_from_biadj(g,m2,neighbours,left)
        good_verts = {}
        for i, row in enumerate(m.data):
            if sum(row) == 1:
                v = left[i]
                w = right[[j for j in range(len(m.data[i])) if m.data[i][j]][0]]
                good_verts[v] = w
        if not good_verts:
            print(m)
            print(left)
            print(right)
            print(nodes)
            raise Exception("No good match found")
        for v in left:
            if v not in good_verts:
                g.set_row(v,leftrow+1)
            else:
                g.set_row(good_verts[v],leftrow+1)
                g.set_qubit(good_verts[v],qs[v])
                if len(list(g.neighbours(v))) > 2: # Gadgets are still connected to it
                    w = add_phase_gate(qs[v],0)
                    processed_targets[v] = w
        leftrow += 1
        if leftrow >= nodestotal:
            nodestotal += 20
            for v in g.vertices():
                if rs[v] > leftrow: g.set_row(v,rs[v]+20)
    # We are done processing now. Time to deal with swaps.
    swap_map = {}
    for w in g.outputs:
        v = list(g.neighbours(w))[0]
        if g.edge_type(g.edge(v,w)) == 2:
            add_hadamard(qs[v])
            g.set_edge_type(g.edge(v,w),1)
        swap_map[qs[v]] = qs[w]
    for t1, t2 in permutation_as_swaps(swap_map):
        add_cnot(t1,t2)
        add_cnot(t2,t1)
        add_cnot(t1,t2)
    
    for i in range(len(g.outputs)):
        v = h.add_vertex(0,i,depth)
        h.outputs.append(v)
        h.add_edge((qindex[i],v),1)
        qindex[i] = v
    
    return h


# def greedy_cut_extract(g, quiet=True):
#     """Given a graph that has been put into semi-normal form by
#     :func:`simplify.clifford_simp` it cuts the graph at :math:`\pi/4` nodes
#     so that it is easier to get a circuit back out again.
#     It tries to get as many :math:`\pi/4` gates on the same row as possible
#     as to reduce the T-depth of the circuit."""
#     qubits = g.qubit_count()
#     g.normalise()
#     max_r = g.depth() - 1
#     i_vs = sorted([v for v in g.vertices() if 1 < g.row(v) < max_r],key=g.row)
#     for i in range(len(i_vs)-1):
#         v = i_vs[i]
#         if g.row(v) == g.row(i_vs[i+1]):
#             g.set_row(v,g.row(v)-0.2)
#     g.pack_circuit_rows()
#     leftrow = 1
#     cuts = 0
#     totalverts = len(i_vs)
#     if not quiet: print("Cutting graph, {!s} internal nodes to cut.".format(totalverts))
#     printboundary = 10
#     while len(i_vs) > 0:
#         row = [i_vs.pop(0)]
#         while True:
#             rightrow = g.row(row[-1])
#             left = [v for v in g.vertices() if g.row(v) == leftrow]
#             right = set()
#             for v in left: right.update(w for w in g.neighbours(v) if g.row(w)>rightrow)
#             right = list(right)
#             rank = cut_rank(g, left, right)

#             if rank + len(row) == qubits:
#                 if len(i_vs) > 0:
#                     row.append(i_vs.pop(0))
#                 else: break
#             elif rank + len(row) > qubits:
#                 if len(row) == 1:
#                     print("FAILED at row", row, "with rank", rank, ">=", qubits, "qubits")
#                     return False
#                 i_vs.insert(0, row.pop())
#                 rightrow = g.row(row[-1])
#                 left = [v for v in g.vertices() if g.row(v) == leftrow]
#                 right = []
#                 for v in left: right.extend(w for w in g.neighbours(v) if g.row(w)>rightrow)
#                 #left,right = split(g, below=g.row(row[0]), above=g.row(row[-1]))
#                 #if len(left) + len(right) + len(row) != len(g.vertices()):
#                 #    print("row partition does not cover entire graph!")
#                 rank = cut_rank(g, left, right)
#                 break
#             else:
#                 print("got len(row) + rank < qubits. For circuits, this should not happen!")
#                 return False
        
#         #r = max(g.row(v) for v in left)+2
#         r = leftrow + 2
#         available = set(range(qubits))
#         for v in row:
#             q = g.qubit(v)
#             if q in available:
#                 available.remove(q)
#             else:
#                 q = available.pop()
#                 g.set_qubit(v, q)

#         cut_edges(g, left, right, available)
#         for v in row:
#             g.set_row(v,r)
#             unspider_by_row(g, v)

#         leftrow = r
#         cuts += 1
#         if not quiet: 
#             print(".", end='')
#             if ((totalverts - len(i_vs))/totalverts)*100 > printboundary:
#                 print("{!s} %".format(printboundary), end=' ')
#                 printboundary += 10
        
#         # for i,v in enumerate(row):
#         #     g.set_qubit(v,rank+i)
#         #     g.set_row(v,r)
#         #     unspider_by_row(g, v)
#         #if iterate: yield g
#     if not quiet: print("\nDone, made {!s} cuts".format(cuts))
#     g.pack_circuit_rows()
#     return True


# def circuit_extract(g, cnot_blocksize=6,quiet=True):
#     """Given a graph put into semi-normal form by :func:`simplify.clifford_simp`, 
#     it turns the graph back into a circuit."""
#     if greedy_cut_extract(g, quiet):
#         layers = list(reversed(range(1,g.depth()-1,2)))
#         if not quiet: print("Extracting CNOT circuits, {!s} iterations.".format(len(layers)))
#         for i,layer in enumerate(layers):
#             if not quiet: print(".", end='')
#             clifford_extract(g,layer,layer+1, cnot_blocksize=cnot_blocksize)
#         if not quiet: print("\nCircuit extraction complete")
#         id_simp(g, quiet)
#         g.pack_circuit_rows()
#         return True
#     else:
#         return False

# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

usage_string = """python -m pyzx command [args]
Run one of the scripts supplied with PyZX.

The options for command are:
    opt    -- Optimise a circuit using PyZX
    tikz   -- Convert a circuit into a Tikz file
    mapper -- Map CNOT circuits onto restricted architectures

For help on the arguments for these commands run for instance 'python -m pyzx opt --help'
"""

if __name__ == '__main__':
    import sys
    import argparse
    try:
        from .scripts import circ2circ
        from .scripts import circ2tikz
        from .scripts import cnot_mapper
    except SystemError:
        print("Please run as a module by using 'python -m pyzx'")
        exit(1)
    
    parser = argparse.ArgumentParser(prog="PyZX", description="PyZX commandline interface",
                                     usage=usage_string)
    parser.add_argument('command', help='Command to run')
    if len(sys.argv) == 1:
        parser.print_help()
        exit(1)
    args = parser.parse_args(sys.argv[1:2])
    if args.command not in ('opt', 'tikz', 'mapper'):
        print("Unrecognized command '{}'".format(args.command))
        parser.print_help()
        exit(1)

    if args.command == 'opt':
        circ2circ.main(sys.argv[2:])
    if args.command == 'tikz':
        circ2tikz.main(sys.argv[2:])
    if args.command == 'mapper':
        cnot_mapper.main(sys.argv[2:])
# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

from .circuit import Circuit, HAD, ZPhase, CNOT, CZ, S, NOT, Z
from .linalg import Mat2

def circuit_phase_polynomial_blocks(circuit, optimize=False, quiet=True):
        """Tries to moves gates around such that as many ZPhase, CZ and CNOT gates 
        are together, so that the resulting circuit can be seen as a sequence of 
        phase polynomials separated by Hadamard gates. Returns a tuple ``circuit, partition`` where
        the ``partition`` is a list, the odd elements of which are phase polynomials.

        If optimize is True then :func:`optimize_block` is called on every phase polynomial block to
        optimize the gate count."""
        gates = {i:list() for i in range(circuit.qubits)}
        for g in circuit.gates:
            if isinstance(g,ZPhase):
                gates[g.target].append(ZPhase(g.target,g.phase))
            elif isinstance(g, NOT):
                if gates[g.target] and isinstance(gates[g.target][-1], HAD):
                    gates[g.target].pop()
                else:
                    gates[g.target].append(HAD(g.target))
                gates[g.target].append(Z(g.target))
                gates[g.target].append(HAD(g.target))
            elif isinstance(g, HAD):
                if gates[g.target] and isinstance(gates[g.target][-1], HAD):
                    gates[g.target].pop()
                else: gates[g.target].append(g)
            elif isinstance(g, CZ):
                if gates[g.control]: g1 = gates[g.control][-1]
                else: g1 = None
                if gates[g.target]: g2 = gates[g.target][-1]
                else: g2 = None
                if g1 and g2 and isinstance(g1, CZ) and isinstance(g2, CZ) and g.target in (g1.control, g1.target) and g.control in (g2.control, g2.target):
                    gates[g.control].pop()
                    gates[g.target].pop()
                else:
                    gates[g.control].append(g)
                    gates[g.target].append(g)
            elif isinstance(g, CNOT): # We need to convert this CNOT to a CZ by adding hadamards at the control
                cz = CZ(g.control, g.target)
                if gates[g.control]: g1 = gates[g.control][-1]
                else: g1 = None
                if gates[g.target]: g2 = gates[g.target][-1]
                else: g2 = None
                if g1 and g2 and isinstance(g1, CZ) and isinstance(g2, CZ) and g.target in (g1.control, g1.target) and g.control in (g2.control, g2.target):
                    gates[g.control].pop()
                    gates[g.target].pop()
                    gates[g.control].append(S(g.control))
                    gates[g.control].append(cz)
                    #gates[g.control].extend([S(g.control),cz])
                    gates[g.target].append(S(g.target))
                    gates[g.target].append(HAD(g.target))
                    gates[g.target].append(cz)
                    gates[g.target].append(HAD(g.target))
                    gates[g.target].append(S(g.target,adjoint=True))
                    #gates[g.target].extend([S(g.target),HAD(g.target),cz,HAD(g.target),S(g.target,adjoint=True)])
                    continue
                if g2 and isinstance(g2, HAD):
                    gates[g.target].pop()
                else:
                    gates[g.target].append(HAD(g.target))
                if g1 and g2 and isinstance(g1, CZ) and isinstance(g2, CZ) and g.target in (g1.control, g1.target) and g.control in (g2.control, g2.target):
                    gates[g.control].pop()
                    gates[g.target].pop()
                else:
                    gates[g.control].append(cz)
                    gates[g.target].append(cz)
                gates[g.target].append(HAD(g.target))
            else:
                raise TypeError("Unsupported gate {!s}. Make sure you are in GH+CNOT form.".format(g))
        partition = []
        while any(gates.values()): # We keep parsing until all the gates have been consumed
            had_layer = []
            l = []
            claimed_qubits = set()
            #print("before", gates)
            for q, gs in gates.items(): # Push a layer of hadamards back
                if q not in claimed_qubits and gs and isinstance(gs[0], HAD):
                    claimed_qubits.add(q)
                    if len(gs) >= 3 and isinstance(gs[1], CZ) and isinstance(gs[2], HAD): #H-CZ-H
                        g = gs[1]
                        q2 = g.control if g.target==q else g.target
                        #print(q, q2, gs, gates[q2])
                        if q2 in claimed_qubits:
                            had_layer.append(gs[0])
                            gs.pop(0)
                        else:
                            if isinstance(gates[q2][0], HAD):
                                had_layer.append(gates[q2][0])
                                gates[q2].pop(0)
                                claimed_qubits.add(q2)
                            index = gates[q2].index(CZ(q2,q))
                            for i in range(index):
                                if isinstance(gates[q2][i], HAD): # Can't consume CZ gate now, HAD in the way
                                    #print("nopenope")
                                    had_layer.append(gs[0])
                                    gs.pop(0)
                                    break
                            else:
                                #print("yesyes")
                                l.append(CNOT(q2,q)) #H-CZ-H = CNOT
                                claimed_qubits.add(q2)
                                gs.pop(0)
                                gs.pop(0)
                                gs.pop(0)
                                gates[q2].pop(index)
                    else:
                        had_layer.append(gs[0])
                        gs.pop(0)
            
            if had_layer: partition.append(had_layer)
            #print("after", gates)
            while True: # We keep adding gates to this phase polynomial block, until we can't any more.
                conns = []
                for q in range(circuit.qubits):
                    phases = []
                    for i,g in enumerate(gates[q]):
                        if isinstance(g, CZ):
                            q2 = g.control if g.target==q else g.target
                            conns.append((q,q2))
                        elif isinstance(g, HAD):
                            break
                        elif isinstance(g, ZPhase):
                            phases.append(i)
                    for i in reversed(phases):
                        l.append(gates[q].pop(i))
                for i,j in conns.copy():
                    if (j,i) in conns and (i,j) in conns:
                        g = CZ(i,j)
                        l.append(g)
                        gates[i].remove(g)
                        gates[j].remove(g)
                        conns.remove((i,j))
                        conns.remove((j,i))
                
                moved_gates = False
                hadamard_blocked = []
                conns = []
                for q in range(circuit.qubits):
                    if gates[q] and isinstance(gates[q][0],HAD):
                        hadamard_blocked.append(q)
                    else:
                        for g in gates[q]:
                            if isinstance(g,CZ):
                                q2 = g.control if g.target==q else g.target
                                conns.append((q,q2))
                            elif isinstance(g,HAD):
                                break

                for q in hadamard_blocked:
                    remove = []
                    for i,g in enumerate(gates[q][1:]):
                        if isinstance(g, CZ):
                            q2 = g.control if g.target==q else g.target
                            if q2 in hadamard_blocked: continue
                            if (q2,q) not in conns: continue
                            #print("cnot", q,q2)
                            l.append(CNOT(q2,q))
                            gates[q2].remove(CZ(q2,q))
                            conns.remove((q2,q))
                            remove.append(i)
                            moved_gates = True
                        elif isinstance(g, HAD): break
                    for i in reversed(remove):
                        gates[q].pop(i+1)
                for q in range(circuit.qubits):
                    if len(gates[q]) >= 2 and isinstance(gates[q][0], HAD) and isinstance(gates[q][1], HAD): #double hadamard gate
                        gates[q].pop(0)
                        gates[q].pop(0)
                        moved_gates = True
                if not moved_gates: break
            
            if l: 
                if optimize:
                    l = optimize_block(l, circuit.qubits, quiet=quiet)
                partition.append(l)
            
        c2 = Circuit(circuit.qubits)
        for gs in partition: c2.gates.extend(gs)
        return c2, partition



def optimize_block(block, qubit_count, quiet=True):
    q = qubit_count
    #First we construct the phase polynomial
    variables = ['x{:03d}'.format(i) for i in range(q)]
    phase_poly = BoolPolynomial()
    expression_polys = []
    for i in range(q):
        p = BoolPolynomial()
        p.add_term(variables[i],1)
        expression_polys.append(p)

    for g in block:
        if isinstance(g, ZPhase):
            terms = expression_polys[g.target].terms
            if len(terms) == 1:
                term = list(terms.keys())[0]
            else:
                term = "({})".format("+".join(t[0] for t in terms.keys()))
            phase_poly.add_term(term, g.phase)
        elif isinstance(g, CZ):
            tgt, ctrl = g.target, g.control
            phase_poly.add_polynomial(expression_polys[tgt]*expression_polys[ctrl])
        elif isinstance(g, CNOT):
            tgt, ctrl = g.target, g.control
            expression_polys[tgt].add_polynomial(expression_polys[ctrl])

#     print(phase_poly)
    #for p in expression_polys:
    #    print(p)
    
    # Then we extract the parities for the CZs and phases
    simple_phases = []
    czs = []
    parities = []
    for t, phase in phase_poly.terms.items():
        if len(t) == 2:
            czs.append((variables.index(t[0]),variables.index(t[1])))
            continue
        t = t[0]
        if '+' in t:
            l = []
            for v in variables:
                l.append(int(v in t[1:-1].split('+')))
            parities.append((l,phase))
        else: simple_phases.append((variables.index(t), phase))
    
    czs = set(czs)
    
    #print(simple_phases)
    #print(czs)
    #print(parities)
    
    # We try to make our cnots more efficient
    cnots = parity_network(q, [par for par,phase in parities])
    #print("parity network cnots", cnots)
    m = Mat2.id(q)
    for cnot in cnots:
        m.row_add(cnot.control, cnot.target)
    #print(m)
    data = []
    # for v in variables:
    #     l = [int((v,) in p.terms) for p in expression_polys]
    #     data.append(l)
    for p in expression_polys:
        l = [int((v,) in p.terms) for v in variables]
        data.append(l)
    #print(Mat2(data))
    target_matrix = Mat2(data) * m.inverse()
    #print("target matrix")
    #print(target_matrix)
    gates = target_matrix.to_cnots(optimize=True)
    for gate in reversed(gates):
        cnots.append(CNOT(gate.target,gate.control))
    #cnots = cnots + target_matrix.to_cnots(optimize=True)
    old_cnots = [g for g in block if isinstance(g,CNOT)]

    if len(cnots) >= len(old_cnots):
        cnots = old_cnots
    else:
        if not quiet: print("Optimized cnot count: {!s} -> {!s} ".format(len(old_cnots),len(cnots)))

    # Now we try to find good locations to put our CZs and phases, keeping track of the parities
    # that the CNOTs are creating
    m = Mat2.id(q)
    cz_sites = {(0,r1,r2):[(r1,r2)] for r1 in range(q) for r2 in range(q) if r1<r2}
    cz_parities = list(cz_sites.values())
    phase_locations = []
    for i, cnot in enumerate(cnots):
        m.row_add(cnot.control, cnot.target)
        for par, phase in parities:
            if par in m.data: # The parity checks out, so put a phase here
                phase_locations.append((i+1,m.data.index(par),phase))
                parities.remove((par,phase))
                break
        for r1 in range(q):
            for r2 in range(r1+1, q):
                if any(m.data[r1][j] and m.data[r2][j] for j in range(q)):
                    continue
                l = set([(min([j1,j2]),max([j1,j2])) for j1 in range(q) if m.data[r1][j1] for j2 in range(q) if m.data[r2][j2]])
                if l not in cz_parities:
                    cz_sites[(i+1,r1,r2)] = l
                    cz_parities.append(l)
                    
    old_cz_count = sum(1 for g in block if isinstance(g,CZ))
    new_czs = []
    # We put our CZs in locations that greedily reduce the amount of parities we need to include.
    while czs:
        best = len(czs)
        choice = None
        for loc, l in cz_sites.items():
            score = len(czs.symmetric_difference(l))
            if score < best:
                best = score
                choice = loc
        if not choice:
            print(":(")
            print(czs)
        new_czs.append(choice)
        czs.symmetric_difference_update(cz_sites[choice])
    if not quiet and old_cz_count != 0: print("Old cz count: ", old_cz_count, ". New cz count: ", len(new_czs))
    
    # We construct the new sequence of gates
    # First the gates that appear before the CNOTs
    new_block = []
    for loc, phase in simple_phases:
        new_block.append(ZPhase(loc,phase))
    for j, loc, phase in phase_locations:
        if j!=0: continue
        new_block.append(ZPhase(loc,phase))
    for j, r1, r2 in new_czs:
        if j!=0: continue
        new_block.append(CZ(r1,r2))

    # And then the gates that appear in between the CNOTs
    for i, cnot in enumerate(cnots):
        new_block.append(cnot)
        for j, loc, phase in phase_locations:
            if j!=i+1: continue
            new_block.append(ZPhase(loc,phase))
        for j, r1, r2 in new_czs:
            if j!=i+1: continue
            new_block.append(CZ(r1,r2))
    
    return new_block



class Polynomial:
    def __init__(self,poly=None):
        if poly:
            self.terms = poly.terms.copy()
        else: self.terms = {}
    
    def copy(self):
        return type(self)(self)
    
    def __str__(self):
        l = []
        for t in sorted(self.terms.keys()):
            val = self.terms[t]
            l.append("{!s}{}".format(val if val!=1 else "", "".join(str(v) for v in sorted(list(t)))))
        return " + ".join(l)
    
    def __repr__(self):
        return str(self)
    
    def add_term(self, term, value):
        if isinstance(term, str):
            term = (term, )
        term = tuple(sorted(term))
        if term in self.terms:
            if self.terms[term] == -value:
                del self.terms[term]
            else: self.terms[term] += value
        else: self.terms[term] = value
    
    def add_polynomial(self, poly):
        for term in poly.terms:
            self.add_term(term, poly.terms[term])
    
    def __add__(self, other):
        p = self.copy()
        p.add_polynomial(other)
        return p
    
    def mult_by_term(self, term, value):
        if value == 0:
            return type(self)() # Zero polynomial
        p = type(self)()
        for t in self.terms:
            s = set()
            s.update(t)
            s.update(term)
            p.add_term(tuple(sorted(list(s))), self.terms[t]*value)
        return p
    
    def mult_by_polynomial(self, poly):
        p = type(self)()
        for term, value in poly.terms.items():
            p.add_polynomial(self.mult_by_term(term,value))
        self.terms = p.terms
    
    def __mul__(self, other):
        p = self.copy()
        p.mult_by_polynomial(other)
        return p
    
    def __rmul__(self,other):
        p = self.copy()
        for t in p.terms:
            p.terms[t] *= other
        return p

class BoolPolynomial(Polynomial):
    def add_term(self, term, value):
        val = value%2
        if not val: return
        if isinstance(term, str):
            term = (term, )
        term = tuple(sorted(term))
        if term in self.terms:
            self.terms[term] = (self.terms[term] + val)%2
            if not self.terms[term]:
                del self.terms[term]
        else: self.terms[term] = val


def parity_network(n, S):
    # See page 14 of https://arxiv.org/pdf/1712.01859.pdf
    c = [] # List of cnots
    Q = [] # stack
    Q.append((S,list(range(n)),-1))
    while Q:
        S, I, i = Q.pop()
        if not S or not I: continue
        if i != -1:
            while True:
                for j in range(n):
                    if j==i: continue
                    if all(y[j] for y in S):
                        c.append(CNOT(j,i))
                        for (Sp,Ip,ip) in (Q+[(S,I,i)]):
                            for y in Sp:
                                y[j] = (y[i]+y[j])%2
                        break
                else:
                    break
        j = max(I, key=lambda j: max([len([y for y in S if y[j]==0]),len([y for y in S if y[j]==1])]))
        S0 = [y.copy() for y in S if y[j]==0]
        S1 = [y.copy() for y in S if y[j]==1]
        Iprime = [jp for jp in I if jp!=j]
        if i == -1:
            Q.append((S1,Iprime,j))
        else:
            Q.append((S1,[jp for jp in I if jp!=i],i))
        Q.append((S0,Iprime, i))
    return c# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2019 - Aleks Kissinger, John van de Wetering,
#                      and Arianne Meijer-van de Griend

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import sys, os
import time
try:
    from pandas import DataFrame
except:
    DataFrame = None
    if __name__ == '__main__':
        print("Warning: could not import pandas. No performance data will be exported.")

import numpy as np

if __name__ == '__main__':
    print("Please call this as python -m pyzx mapper ...")
    return
    #sys.path.append('..')

from ..linalg import Mat2
from ..routing.architecture import create_fully_connected_architecture, create_architecture
from ..routing.parity_maps import CNOT_tracker
from ..routing.machine_learning import GeneticAlgorithm
# from pyzx.routing.fitness import get_gate_count_fitness_func as get_fitness_func
from ..routing.steiner import steiner_gauss

description = "Compiles given qasm files or those in the given folder to a given architecture."

debug = False

# ELIMINATION MODES:
GAUSS_MODE = "gauss"
STEINER_MODE = "steiner"
GENETIC_STEINER_MODE = "genetic_steiner"
GENETIC_GAUSS_MODE = "genetic_gauss"

elim_modes = [STEINER_MODE, GAUSS_MODE, GENETIC_STEINER_MODE, GENETIC_GAUSS_MODE]
genetic_elim_modes = [GENETIC_STEINER_MODE, GENETIC_GAUSS_MODE]
no_genetic_elim_modes = [STEINER_MODE, GAUSS_MODE]

# COMPILE MODES
QUIL_COMPILER = "quilc"
NO_COMPILER = "not_compiled"

compiler_modes = [QUIL_COMPILER, NO_COMPILER]


def get_fitness_func(mode, matrix, architecture, row=True, col=True, full_reduce=True):
    """
    Creates and returns a fitness function to be used for the genetic algorithm that uses CNOT gate count as fitness.

    :param mode: The type of Gaussian elimination to be used
    :param matrix: A Mat2 parity map to route.
    :param architecture: The architecture to take into account when routing
    :param row: Whether to find a row permutation
    :param col: Whether to find a column permutation
    :param full_reduce: Whether to fully reduce the matrix, thus rebuild the full circuit.
    :return: A fitness function that calculates the number of gates needed for a given permutation.
    """
    matrix = matrix.data
    n_qubits = matrix.shape[0]

    def fitness_func(permutation):
        e = np.arange(len(permutation))
        row_perm = permutation if row else e
        col_perm = permutation if col else e
        circuit = CNOT_tracker(n_qubits)
        mat = Mat2(np.copy(matrix[row_perm][:, col_perm]))
        gauss(mode, mat, architecture=architecture, x=circuit, full_reduce=full_reduce)
        return circuit.count_cnots()

    return fitness_func


def gauss(mode, matrix, architecture=None, **kwargs):
    """
    Performs gaussian elimination of type mode on Mat2 matrix on the given architecture, if needed.

    :param mode: Type of Gaussian elimination to be used
    :param matrix: Mat2 matrix to run the algorithm on
    :param architecture: Device architecture to take into account [optional]
    :param kwargs: Other arguments that can be given to the Mat2.gauss() function or parameters for the genetic algorithm.
    :return: The rank of the matrix. Mat2 matrix is transformed.
    """
    if mode == GAUSS_MODE:
        return matrix.gauss(**kwargs)
    elif mode == STEINER_MODE:
        if architecture is None:
            print(
                "\033[91m Warning: Architecture is not given, assuming fully connected architecture of size matrix.shape[0]. \033[0m ")
            architecture = create_fully_connected_architecture(matrix.data.shape[0])
        return steiner_gauss(matrix, architecture, **kwargs)
    elif mode == GENETIC_STEINER_MODE:
        perm, cnots, rank = permutated_gauss(matrix, STEINER_MODE, architecture=architecture, **kwargs)
        return rank
    elif mode == GENETIC_GAUSS_MODE:
        perm, cnots, rank = permutated_gauss(matrix, GAUSS_MODE, architecture=architecture, **kwargs)
        return rank


def permutated_gauss(matrix, mode=None, architecture=None, population_size=30, crossover_prob=0.8, mutate_prob=0.2, n_iterations=50,
                     row=True, col=True, full_reduce=True, fitness_func=None, x=None, y=None):
    """
    Finds an optimal permutation of the matrix to reduce the number of CNOT gates.
    
    :param matrix: Mat2 matrix to do gaussian elimination over
    :param population_size: For the genetic algorithm
    :param crossover_prob: For the genetic algorithm
    :param mutate_prob: For the genetic algorithm
    :param n_iterations: For the genetic algorithm
    :param row: If the rows should be permutated
    :param col: If the columns should be permutated
    :param full_reduce: Whether to do full gaussian reduction
    :return: Best permutation found, list of CNOTS corresponding to the elimination.
    """
    if fitness_func is None:
        fitness_func =  get_fitness_func(mode, matrix, architecture, row=row, col=col, full_reduce=full_reduce)
    optimizer = GeneticAlgorithm(population_size, crossover_prob, mutate_prob, fitness_func)
    best_permutation = optimizer.find_optimimum(architecture.n_qubits, n_iterations, continued=True)

    n_qubits=matrix.data.shape[0]
    no_perm = np.arange(len(best_permutation))
    row_perm = best_permutation if row else no_perm
    col_perm = best_permutation if col else no_perm
    if y is None:
        circuit = CNOT_tracker(n_qubits)
    else:
        circuit = y
    mat = Mat2(np.copy(matrix.data[row_perm][:, col_perm]))
    circuit.row_perm = row_perm
    circuit.col_perm = col_perm
    rank = gauss(mode, mat, architecture, x=x, y=circuit, full_reduce=full_reduce)
    return best_permutation, circuit.count_cnots(), rank

def count_cnots_mat2(mode, matrix, compile_mode=None, architecture=None, n_compile=1, store_circuit_as=None, **kwargs):
    if compile_mode == QUIL_COMPILER:
        from pyzx.pyquil_circuit import PyQuilCircuit
        circuit = PyQuilCircuit(architecture)
    else:
        circuit = CNOT_tracker(matrix.data.shape[0])
    mat = Mat2(np.copy(matrix.data))
    gauss(mode, mat, architecture=architecture, y=circuit, **kwargs)
    return count_cnots_circuit(compile_mode, circuit, n_compile, store_circuit_as)

def count_cnots_circuit(mode, circuit, n_compile=1, store_circuit_as=None):
    count = -1
    if mode == QUIL_COMPILER:
        from pyzx.pyquil_circuit import PyQuilCircuit
        if isinstance(circuit, PyQuilCircuit):
            count = sum([circuit.compiled_cnot_count() for i in range(n_compile)])/n_compile
    elif mode == NO_COMPILER:
        count = circuit.count_cnots()
    if store_circuit_as is not None:
        with open(store_circuit_as, 'w') as f:
            f.write(circuit.to_qasm())
    return count


def make_into_list(possible_list):
    if type(possible_list) != type([]):
        return [possible_list]
    return possible_list

def create_dest_filename(original_file, population=None, iteration=None, crossover_prob=None, mutation_prob=None, index=None):
    pop_ext = "" if population is None else "pop" + str(population)
    iter_ext = "" if iteration is None else "iter" + str(iteration)
    crosover_ext = "" if crossover_prob is None else "crossover" + str(crossover_prob)
    mutation_ext = "" if mutation_prob is None else "mutate" + str(mutation_prob)
    index_ext = "" if index is None else "(" + str(index) + ")"
    filename = os.path.basename(original_file)
    base_file, extension = os.path.splitext(filename)
    new_filename = '_'.join([part for part in [base_file, pop_ext, iter_ext, crosover_ext, mutation_ext, index_ext] if part != ""]) + extension
    return new_filename

def get_metric_header():
    metrics = CNOT_tracker.get_metric_names()
    return ["id", "architecture", "mode", "index", "population", "n_iterations", "crossover", "mutation"] + metrics + ["time", "destination_file"]

def make_metrics(circuit, id, architecture_name, mode, dest_file=None, population=None, iteration=None, crossover_prob=None, mutation_prob=None, passed_time=None, index=None):
    result = circuit.gather_metrics()
    result["id"] = id
    result["mode"] = mode
    result["architecture"] = architecture_name
    result["population"] = population
    result["n_iterations"] = iteration
    result["crossover"] = crossover_prob
    result["mutation"] = mutation_prob
    result["time"] = passed_time
    result["index"] = index
    result["destination_file"] = dest_file
    return result


def batch_map_cnot_circuits(source, modes, architectures, n_qubits=None, populations=30, iterations=15, crossover_probs=0.8,
                            mutation_probs=0.5, dest_folder=None, metrics_file=None, n_compile=1):
    modes = make_into_list(modes)
    architectures = make_into_list(architectures)
    populations = make_into_list(populations)
    iterations = make_into_list(iterations)
    crossover_probs = make_into_list(crossover_probs)
    mutation_probs = make_into_list(mutation_probs)

    if os.path.isfile(source):
        source, file = os.path.split(source)
        files = [file]
    else:
        files = [f for f in os.listdir(source) if os.path.isfile(os.path.join(source, f))]

    if not os.path.exists(source):
        raise IOError("Folder does not exist: " + source)
    if dest_folder is None:
        dest_folder = source
    else:
        os.makedirs(dest_folder, exist_ok=True)

    arch_iter = []
    circuits = {}
    metrics = []
    for architecture in architectures:
        if architecture in dynamic_size_architectures:
            if n_qubits is None:
                raise KeyError("Number of qubits not specified for architecture" + architecture)
            else:
                n_qubits = make_into_list(n_qubits)
                arch_iter.extend([create_architecture(architecture, n_qubits=q) for q in n_qubits])
        else:
            arch_iter.append(create_architecture(architecture))
    for architecture in arch_iter:
        circuits[architecture.name] = {}
        for mode in modes:
            if mode == QUIL_COMPILER:
                n_compile_list = range(n_compile)
            else:
                n_compile_list = [None]
            new_dest_folder = os.path.join(dest_folder, architecture.name, mode)
            os.makedirs(new_dest_folder, exist_ok=True)
            if mode in genetic_elim_modes:
                pop_iter = populations
                iter_iter = iterations
                crossover_iter = crossover_probs
                mutation_iter = mutation_probs
                circuits[architecture.name][mode] = {}
            else:
                if mode == QUIL_COMPILER:
                    circuits[architecture.name][mode] = []
                pop_iter = [None]
                iter_iter = [None]
                crossover_iter = [None]
                mutation_iter = [None]

            for population in pop_iter:
                for iteration in iter_iter:
                    for crossover_prob in crossover_iter:
                        for mutation_prob in mutation_iter:
                            for file in files:
                                if os.path.splitext(file)[1].lower() == ".qasm":
                                    origin_file = os.path.join(source, file)
                                    for i in n_compile_list:
                                        dest_filename = create_dest_filename(origin_file, population, iteration, crossover_prob, mutation_prob, i)
                                        dest_file = os.path.join(dest_folder, architecture.name, mode, dest_filename)
                                        try:
                                            start_time = time.time()
                                            circuit = map_cnot_circuit(origin_file, architecture, mode=mode, dest_file=dest_file,
                                                                       population=population, iterations=iteration,
                                                                       crossover_prob=crossover_prob, mutation_prob=mutation_prob)
                                            end_time = time.time()
                                            if metrics_file is not None:
                                                metrics.append(make_metrics(circuit, origin_file, architecture.name, mode, dest_file, population, iteration, crossover_prob, mutation_prob, end_time-start_time, i))
                                            if mode in genetic_elim_modes:
                                                circuits[architecture.name][mode][(population, iteration, crossover_prob, mutation_prob)] = circuit
                                            elif mode == QUIL_COMPILER:
                                                circuits[architecture.name][mode].append(circuit)
                                            else:
                                                circuits[architecture.name][mode] = circuit
                                        except KeyError as e: # Should only happen with quilc
                                            if mode == QUIL_COMPILER:
                                                print("\033[31mCould not compile", origin_file, "into", dest_file, end="\033[0m\n")
                                            else:
                                                raise e

    if len(metrics) > 0 and DataFrame != None:
        df = DataFrame(metrics)
        if os.path.exists(metrics_file): # append to the file - do not overwrite!
            df.to_csv(metrics_file, columns=get_metric_header(), header=False, index=False, mode='a')
        else:
            df.to_csv(metrics_file, columns=get_metric_header(), index=False)
    return circuits

def map_cnot_circuit(file, architecture, mode=GENETIC_STEINER_MODE, dest_file=None, population=30, iterations=15, crossover_prob=0.8, mutation_prob=0.2):
    if type(architecture) == type(""):
        architecture = create_architecture(architecture)
    circuit = CNOT_tracker.from_qasm_file(file)
    matrix = circuit.matrix
    compiled_circuit = CNOT_tracker(circuit.n_qubits)
    if mode in no_genetic_elim_modes:
        rank = gauss(mode, matrix, architecture, full_reduce=True, y=compiled_circuit)
    elif mode in genetic_elim_modes:
        rank = gauss(mode, matrix, architecture, full_reduce=True, y=compiled_circuit,
                     population_size=population, crossover_prob=crossover_prob, mutate_prob=mutation_prob,
                     n_iterations=iterations)
    elif mode == QUIL_COMPILER:
        from pyzx.pyquil_circuit import PyQuilCircuit
        compiled_circuit = PyQuilCircuit.from_CNOT_tracker(circuit, architecture)
        compiled_circuit.compile()

    if dest_file is not None:
        compiled_qasm = compiled_circuit.to_qasm()
        with open(dest_file, "w") as f:
            f.write(compiled_qasm)
    return compiled_circuit


def main(args):
    import argparse
    from ..routing.architecture import architectures, SQUARE, dynamic_size_architectures

    def restricted_float(x):
        x = float(x)
        if x < 0.0 or x > 1.0:
            raise argparse.ArgumentTypeError("%r not in range [0.0, 1.0]." % (x,))
        return x

    parser = argparse.ArgumentParser(prog="pyzx mapper", description=description)
    parser.add_argument("QASM_source", nargs='+', help="The QASM file or folder with QASM files to be routed.")
    parser.add_argument("-m", "--mode", nargs='+', dest="mode", default=STEINER_MODE, help="The mode specifying how to route. choose 'all' for using all modes.", choices=elim_modes+[QUIL_COMPILER, "all"])
    parser.add_argument("-a", "--architecture", nargs='+', dest="architecture", default=SQUARE, choices=architectures, help="Which architecture it should run compile to.")
    parser.add_argument("-q", "--qubits", nargs='+', default=None, type=int, help="The number of qubits for the fully connected architecture.")
    #parser.add_argument("-f", "--full_reduce", dest="full_reduce", default=1, type=int, choices=[0,1], help="Full reduce")
    parser.add_argument("--population", nargs='+', default=30, type=int, help="The population size for the genetic algorithm.")
    parser.add_argument("--iterations", nargs='+', default=15, type=int, help="The number of iterations for the genetic algorithm.")
    parser.add_argument("--crossover_prob", nargs='+', default=0.8, type=restricted_float, help="The crossover probability for the genetic algorithm. Must be between 0.0 and 1.0.")
    parser.add_argument("--mutation_prob", nargs='+', default=0.2, type=restricted_float, help="The mutation probability for the genetic algorithm. Must be between 0.0 and 1.0.")
    #parser.add_argument("--perm", default="both", choices=["row", "col", "both"], help="Whether to find a single optimal permutation that permutes the rows, columns or both with the genetic algorithm.")
    parser.add_argument("--destination", help="Destination file or folder where the compiled circuit should be stored. Otherwise the source folder is used.")
    parser.add_argument("--metrics_csv", default=None, help="The location to store compiling metrics as csv, if not given, the metrics are not calculated. Only used when the source is a folder")
    parser.add_argument("--n_compile", default=1, type=int, help="How often to run the Quilc compiler, since it is not deterministic.")
    parser.add_argument("--subfolder", default=None, type=str, nargs="+", help="Possible subfolders from the main QASM source to compile from. Less typing when source folders are in the same folder. Can also be used for subfiles.")

    args = parser.parse_args(args)
    if args.metrics_csv is not None and os.path.exists(args.metrics_csv):
        delete_csv = None
        text = input("The given metrics file [%s] already exists. Do you want to overwrite it? (Otherwise it is appended) [y|n]" % args.metrics_csv)
        if text.lower() in ['y', "yes"]:
            delete_csv = True
        elif text.lower() in ['n', 'no']:
            delete_csv = False
        while delete_csv is None:
            text = input("Please answer yes or no.")
            if text.lower() in ['y', "yes"]:
                delete_csv = True
            elif text.lower() in ['n', 'no']:
                delete_csv = False
        if delete_csv:
            os.remove(args.metrics_csv)

    sources = make_into_list(args.QASM_source)
    if args.subfolder is not None:
        sources = [os.path.join(source, subfolder) for source in sources for subfolder in args.subfolder if os.path.isdir(source)]
        # Remove non existing paths

    sources = [source for source in sources if os.path.exists(source) or print("Warning, skipping non-existing source:", source)]

    if "all" in args.mode:
        mode = elim_modes + [QUIL_COMPILER]
    else:
        mode = args.mode

    all_circuits = []
    for source in sources:
        print("Mapping qasm files in path:", source)
        circuits = batch_map_cnot_circuits(source, mode, args.architecture, n_qubits=args.qubits, populations=args.population,
                                           iterations=args.iterations,
                                           crossover_probs=args.crossover_prob, mutation_probs=args.mutation_prob,
                                           dest_folder=args.destination, metrics_file=args.metrics_csv, n_compile=args.n_compile)
        all_circuits.extend(circuits)

# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import os
import sys

from ..circuit import Circuit, determine_file_type
from .. import simplify
from .. import extract
from .. import optimize

description="""End-to-end circuit optimizer

For simple optimisation of a circuit run as
    python -m pyzx opt circuit.extension

This puts an optimised version of the circuit in the same directory and of the same file type.

If we want to specify the output location and type we can run
    python -m pyzx opt -d outputfile.qc -t qc inputfile.qasm
"""

import argparse
parser = argparse.ArgumentParser(prog="pyzx opt", description=description, formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument('source',type=str,help='source circuit')
parser.add_argument('-d',type=str,help='destination for output file', dest='dest',default='')
parser.add_argument('-t',type=str,default='match', dest='outformat',
    help='Specify the output format (qasm, qc, quipper). By default matches the input')
parser.add_argument('-v',default=False, action='store_true', dest='verbose',
    help='Output verbose information')
parser.add_argument('-g',type=str,default='full', dest='simp', 
    help='ZX-simplifier to use. Options are full (default), cliff, or tele')
parser.add_argument('-p',default=False, action='store_true', dest='phasepoly',
    help='Whether to also run the phase-polynomial optimizer (default is false)')

def main(args):
    options = parser.parse_args(args)
    if not os.path.exists(options.source):
        print("File {} does not exist".format(options.source))
        return
    ctype = determine_file_type(options.source)
    if options.outformat == 'match':
        dtype = ctype
    elif options.outformat not in ('qasm', 'qc', 'quipper'):
        print("Unsupported circuit type {}. Please use qasm, qc or quipper".format(options.outformat))
        return
    else:
        dtype = options.outformat
    if not options.dest:
        base = os.path.splitext(options)[0]
        dest = base + "." + dtype
    else:
        dest = options.dest

    c = Circuit.load(options.source)
    if options.verbose:
        print("Starting circuit:")
        print(c.to_basic_gates().stats())
    g = c.to_graph()
    if options.verbose: print("Running simplification algorithm...")
    if options.simp == 'tele':
        g = simplify.teleport_reduce(g,quiet=(not options.verbose))
        c2 = Circuit.from_graph(g)
        c2 = c2.split_phase_gates()
    else:
        if options.simp == 'full':
            simplify.full_reduce(g,quiet=(not options.verbose))
        if options.simp == 'cliff':
            simplify.clifford_simp(g,quiet=(not options.verbose))
        if options.verbose: print("Extracting circuit...")
        c2 = extract.streaming_extract(g)
    if options.verbose: print("Optimizing...")
    if options.phasepoly:
        c3 = optimize.full_optimize(c2.to_basic_gates())
    else:
        c3 = optimize.basic_optimization(c2.to_basic_gates())
    c3 = c3.to_basic_gates()
    c3 = c3.split_phase_gates()
    if options.verbose: print(c3.stats())
    print("Writing output to {}".format(os.path.abspath(dest)))
    if dtype == 'qc': output = c3.to_qc()
    if dtype == 'qasm': output = c3.to_qasm()
    if dtype == 'quipper': output = c3.to_quipper()
    f = open(dest, 'w')
    f.write(output)
    f.close()
# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import os
import sys

from ..circuit import Circuit
from ..simplify import id_simp
from .. import tikz

def to_tikz(source, target):
    circ = Circuit.load(source)
    print("Converting circuit with {:d} gates to TikZ".format(len(circ.gates)))
    g = circ.to_graph()
    id_simp(g,quiet=True)
    tikz_output = tikz.to_tikz(g)
    print("Output file: ", os.path.abspath(target))
    f = open(target, 'w')
    f.write(tikz_output)
    f.close()

helpstring = """usage: pyzx tikz source [dest]

Script for converting circuits into tikz files.

positional arguments:
   source       File containing circuit
   dest         Desired output location for TikZ file

The default value for dest is to put a .tikz file of the same name in the folder of source.
"""

def main(args):
    if not args:
        print(helpstring)
    elif len(args) == 1:
        source = args[0]
        if not os.path.exists(source):
            print("File '{}' does not exist".format(source))
        else:
            basename = os.path.splitext(source)[0]
            target = basename+".tikz"
            to_tikz(source, target)
    else:
        source = args[0]
        target = args[1]
        to_tikz(source, target)

# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2019 - Aleks Kissinger, John van de Wetering,
#                      and Arianne Meijer-van de Griend

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2019 - Aleks Kissinger, John van de Wetering,
#                      and Arianne Meijer-van de Griend

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import sys
if __name__ == '__main__':
    sys.path.append('..')
from pyzx.generate import cnots as generate_cnots
from pyzx.circuit import Circuit, gate_types
from pyzx.linalg import Mat2

import numpy as np

class CNOT_tracker(Circuit):
    def __init__(self, n_qubits, **kwargs):
        super().__init__(n_qubits, **kwargs)
        self.matrix = Mat2(np.identity(n_qubits))
        self.row_perm = np.arange(n_qubits)
        self.col_perm = np.arange(n_qubits)
        self.n_qubits = n_qubits

    def count_cnots(self):
        return len([g for g in self.gates if hasattr(g, "name") and g.name == "CNOT"])

    def row_add(self, q0, q1):
        self.add_gate("CNOT", q0, q1)
        self.matrix.row_add(q0, q1)

    def col_add(self, q0, q1):
        self.prepend_gate("CNOT", q1, q0)
        self.matrix.col_add(q0, q1)

    @staticmethod
    def get_metric_names():
        return ["n_cnots"]

    def gather_metrics(self):
        metrics = {}
        metrics["n_cnots"] = self.count_cnots()
        return metrics

    def prepend_gate(self, gate, *args, **kwargs):
        """Adds a gate to the circuit. ``gate`` can either be 
        an instance of a :class:`Gate`, or it can be the name of a gate,
        in which case additional arguments should be given.

        Example::

            circuit.add_gate("CNOT", 1, 4) # adds a CNOT gate with control 1 and target 4
            circuit.add_gate("ZPhase", 2, phase=Fraction(3,4)) # Adds a ZPhase gate on qubit 2 with phase 3/4
        """
        if isinstance(gate, str):
            gate_class = gate_types[gate]
            gate = gate_class(*args, **kwargs)
        self.gates.insert(0, gate)

    def to_qasm(self):
        qasm = super().to_qasm()
        initial_perm = "// Initial wiring: " + str(self.row_perm.tolist())
        end_perm = "// Resulting wiring: " + str(self.col_perm.tolist())
        return '\n'.join([initial_perm, end_perm, qasm])

    @staticmethod
    def from_circuit(circuit):
        new_circuit = CNOT_tracker(circuit.qubits, name=circuit.name)
        new_circuit.gates = circuit.gates
        new_circuit.update_matrix()
        return new_circuit

    def update_matrix(self):
        self.matrix = Mat2(np.identity(self.n_qubits))
        for gate in self.gates:
            if hasattr(gate, "name") and gate.name == "CNOT":
                self.matrix.row_add(gate.control, gate.target)
            else:
                print("Warning: CNOT tracker can only be used for circuits with only CNOT gates!")

    @staticmethod
    def from_qasm_file(fname):
        circuit = Circuit.from_qasm_file(fname)
        return CNOT_tracker.from_circuit(circuit)

def build_random_parity_map(qubits, n_cnots, circuit=None):
    """
    Builds a random parity map.

    :param qubits: The number of qubits that participate in the parity map
    :param n_cnots: The number of CNOTs in the parity map
    :param circuit: A (list of) circuit object(s) that implements a row_add() method to add the generated CNOT gates [optional]
    :return: a 2D numpy array that represents the parity map.
    """
    if circuit is None:
        circuit = []
    if not isinstance(circuit, list):
        circuit = [circuit]
    g = generate_cnots(qubits=qubits, depth=n_cnots)
    c = Circuit.from_graph(g)
    matrix = Mat2(np.identity(qubits))
    for gate in c.gates:
        matrix.row_add(gate.control, gate.target)
        for c in circuit:
            c.row_add(gate.control, gate.target)
    return matrix.data


if __name__ == '__main__':
    import argparse
    import os
    from pyzx.cnot_mapper import make_into_list

    parser = argparse.ArgumentParser(description="Generates random CNOT circuits and stores them as QASM files.")
    parser.add_argument("folder", help="The QASM file or folder with QASM files to be routed.")
    parser.add_argument("-q", "--n_qubits", nargs='+', default=9, type=int, help="The number of qubits participating in the circuit.")
    parser.add_argument("-m", "--n_maps", default=1, type=int, help="The number of circuits to be generated.")
    parser.add_argument("-d", "--n_cnots", nargs='+', default=None, type=int, help="The number of CNOTs in the generated circuit.")

    args = parser.parse_args()
    if args.n_cnots is None:
        parser.error(message="Please specify the number of CNOT gates to be generated with the -d flag.")
    folder = args.folder
    os.makedirs(folder, exist_ok=True)

    n_qubits = make_into_list(args.n_qubits)
    n_maps = args.n_maps
    n_cnots = make_into_list(args.n_cnots)

    for q in n_qubits:
        for n in n_cnots:
            dest_folder = os.path.join(folder, str(q) + "qubits", str(n))
            os.makedirs(dest_folder, exist_ok=True)
            for i in range(n_maps):
                filename = "Original" + str(i) + ".qasm"
                dest_file = os.path.join(dest_folder, filename)
                circuit = CNOT_tracker(q)
                build_random_parity_map(q, n, circuit)
                with open(dest_file, "w") as f:
                    f.write(circuit.to_qasm())



# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2019 - Aleks Kissinger, John van de Wetering,
#                      and Arianne Meijer-van de Griend

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import numpy as np

class GeneticAlgorithm():

    def __init__(self, population_size, crossover_prob, mutation_prob, fitness_func, maximize=False):
        self.population_size = population_size
        self.negative_population_size = int(np.sqrt(population_size))
        self.crossover_prob = crossover_prob
        self.mutation_prob = mutation_prob
        self.fitness_func = fitness_func
        self._sort = lambda l: l.sort(key=lambda x:x[1], reverse=maximize)
        self.maximize = maximize
        self.n_qubits = 0
        self.population = None

    def _select(self):
        fitness_scores = [f for c,f in self.population]
        total_fitness = sum(fitness_scores)
        if self.maximize:
            selection_chance = [f/total_fitness for f in fitness_scores]
        else:
            max_fitness = max(fitness_scores) + 1
            adjusted_scores = [max_fitness - f for f in fitness_scores]
            adjusted_total = sum(adjusted_scores)
            selection_chance = [ f/adjusted_total for f in adjusted_scores]
        return np.random.choice(self.population_size, size=2, replace=False, p=selection_chance)

    def _create_population(self, n):
        self.population = [np.random.permutation(n) for _ in range(self.population_size)]
        self.population = [(chromosome, self.fitness_func(chromosome)) for chromosome in self.population]
        self._sort(self.population)
        self.negative_population = self.population[-self.negative_population_size:]

    def find_optimimum(self, n_qubits, n_generations, initial_order=None, n_child=None, continued=False):
        self.n_qubits = n_qubits
        partial_solution = False
        if not continued or self.population is None:
            if initial_order is None:
                self._create_population(n_qubits)
            elif n_qubits < len(initial_order):
                self._create_population(initial_order[:n_qubits])
                partial_solution = True
            else:
                self._create_population(initial_order)

        if n_child is None:
            n_child = self.population_size

        for _ in range(n_generations):
            self._update_population(n_child)
        if partial_solution:
            return self.population[0] + initial_order[n_qubits:]
        return self.population[0][0]

    def _add_children(self, children):
        n_child = len(children)
        self.population.extend([(child, self.fitness_func(child)) for child in children])
        self._sort(self.population)
        self.negative_population.extend(self.population[-n_child:])
        self.negative_population = [self.negative_population[i] for i in np.random.choice(self.negative_population_size + n_child, size=self.negative_population_size, replace=False)]
        self.population = self.population[:self.population_size]

    def _update_population(self, n_child):
        children = []
        # Create a child from weak parents to avoid local optima
        p1, p2 = np.random.choice(self.negative_population_size, size=2, replace=False)
        child = self._crossover(self.negative_population[p1][0], self.negative_population[p2][0])
        children.append(child)
        for _ in range(n_child):
            if np.random.random() < self.crossover_prob:
                p1, p2 = self._select()
                child = self._crossover(self.population[p1][0], self.population[p2][0])
                if np.random.random() < self.mutation_prob:
                    child = self._mutate(child)
                children.append(child)
        self._add_children(children)

    def _crossover(self, parent1, parent2):
        crossover_start = np.random.choice(int(self.n_qubits/2))
        crossover_length = np.random.choice(self.n_qubits-crossover_start)
        crossover_end = crossover_start + crossover_length
        child = -1*np.ones_like(parent1)
        child[crossover_start:crossover_end] = parent1[crossover_start: crossover_end]
        child_idx = 0
        for parent_gen in parent2:
            if child_idx == crossover_start: # skip over the parent1 part in child
                child_idx = crossover_end
            if parent_gen not in child: # only add new genes
                child[child_idx] = parent_gen
                child_idx += 1
        return child

    def _mutate(self, parent):
        gen1, gen2 = np.random.choice(len(parent), size=2, replace=False)
        _ = parent[gen1]
        parent[gen1] = parent[gen2]
        parent[gen2] = _
        return parent


if __name__ == '__main__':
    def fitness_func(chromosome):
        t1 = 1
        t2 = 1
        size = len(chromosome)
        f1 = [chromosome[i]-i for i in range(size)]
        f2 = [size - g for g in f1]
        f1.sort()
        f2.sort()
        for i in range(1, size):
            t1 += int(f1[i] == f1[i-1])
            t2 += int(f2[i] == f2[i-1])
        return t1 + t2


    optimizer = GeneticAlgorithm(1000, 0.8, 0.2, fitness_func)
    optimizer.find_optimimum(8, 300)
    print(optimizer.population)

# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2019 - Aleks Kissinger, John van de Wetering,
#                      and Arianne Meijer-van de Griend

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

from . import architecture

debug = False

def steiner_gauss(matrix, architecture, full_reduce=False, x=None, y=None):
    """
    Performs Gaussian elimination that is constraint by the given architecture
    
    :param matrix: PyZX Mat2 matrix to be reduced
    :param architecture: The Architecture object to conform to
    :param full_reduce: Whether to fully reduce or only create an upper triangular form
    :param x: 
    :param y: 
    :return: Rank of the given matrix
    """
    def row_add(c0, c1):
        matrix.row_add(c0, c1)
        debug and print("Reducing", c0, c1)
        if x != None: x.row_add(c0, c1)
        if y != None: y.col_add(c1, c0)
    def steiner_reduce(col, root, nodes, upper):
        steiner_tree = architecture.steiner_tree(root, nodes, upper)
        # Remove all zeros
        next_check = next(steiner_tree)
        debug and print("Step 1: remove zeros")
        if upper:
            zeros = []
            while next_check is not None:
                s0, s1 = next_check
                if matrix.data[s0, col] == 0:  # s1 is a new steiner point or root = 0
                    zeros.append(next_check)
                next_check = next(steiner_tree)
            while len(zeros) > 0:
                s0, s1 = zeros.pop(-1)
                if matrix.data[s0, col] == 0:
                    row_add(s1, s0)
                    debug and print(matrix.data[s0, col], matrix.data[s1, col])
        else:
            debug and print("deal with zero root")
            if next_check is not None and matrix.data[next_check[0], col] == 0:  # root is zero
                print("WARNING : Root is 0 => reducing non-pivot column", matrix.data)
            debug and print("Step 1: remove zeros", matrix.data[:, c])
            while next_check is not None:
                s0, s1 = next_check
                if matrix.data[s1, col] == 0:  # s1 is a new steiner point
                    row_add(s0, s1)
                next_check = next(steiner_tree)
        # Reduce stuff
        debug and print("Step 2: remove ones")
        next_add = next(steiner_tree)
        while next_add is not None:
            s0, s1 = next_add
            row_add(s0, s1)
            next_add = next(steiner_tree)
            debug and print(next_add)
        debug and print("Step 3: profit")

    rows = matrix.rows()
    cols = matrix.cols()
    p_cols = []
    pivot = 0
    for c in range(cols):
        nodes = [r for r in range(pivot, rows) if pivot==r or matrix.data[r][c] == 1]
        steiner_reduce(c, pivot, nodes, True)
        if matrix.data[pivot][c] == 1:
            p_cols.append(c)
            pivot += 1
    debug and print("Upper triangle form", matrix.data)
    rank = pivot
    debug and print(p_cols)
    if full_reduce:
        pivot -= 1
        for c in reversed(p_cols):
            debug and print(pivot, matrix.data[:,c])
            nodes = [r for r in range(0, pivot+1) if r==pivot or matrix.data[r][c] == 1]
            if len(nodes) > 1:
                steiner_reduce(c, pivot, nodes, False)
            pivot -= 1
    return rank
import sys
if __name__ == '__main__':
    sys.path.append('..')
from ..graph.graph import  Graph
#from pyzx.graph.base import BaseGraph # TODO fix the right graph import - one of many - right backend etc

import numpy as np

SQUARE = "square"
LINE = "line"
FULLY_CONNNECTED = "fully_connected"
CIRCLE = "circle"
IBM_QX2 = "ibm_qx2"
IBM_QX3 = "ibm_qx3"
IBM_QX4 = "ibm_qx4"
IBM_QX5 = "ibm_qx5"
IBM_Q20_TOKYO = "ibm_q20_tokyo"
RIGETTI_16Q_ASPEN = "rigetti_16q_aspen"
RIGETTI_8Q_AGAVE = "rigetti_8q_agave"

architectures = [SQUARE, CIRCLE, FULLY_CONNNECTED, LINE, IBM_QX4, IBM_QX2, IBM_QX3, IBM_QX5, IBM_Q20_TOKYO, RIGETTI_8Q_AGAVE, RIGETTI_16Q_ASPEN]
dynamic_size_architectures = [FULLY_CONNNECTED, LINE, CIRCLE, SQUARE]

debug = False

class Architecture():
    def __init__(self, name, coupling_graph=None, coupling_matrix=None, backend=None):
        """
        Class that represents the architecture of the qubits to be taken into account when routing.

        :param coupling_graph: a PyZX Graph representing the architecture, optional 
        :param coupling_matrix: a 2D numpy array representing the adjacency of the qubits, from which the Graph is created, optional
        :param backend: The PyZX Graph backend to be used when creating it from the adjacency matrix, optional
        """
        self.name = name
        if coupling_graph is None:
            self.graph = Graph(backend=backend)
        else:
            self.graph = coupling_graph

        if coupling_matrix is not None:
            # build the architecture graph
            n = coupling_matrix.shape[0]
            self.vertices = self.graph.add_vertices(n)
            edges = [(self.vertices[row], self.vertices[col]) for row in range(n) for col in range(n) if
                     coupling_matrix[row, col] == 1]
            self.graph.add_edges(edges)
        else:
            self.vertices = [v for v in self.graph.vertices()]
        self.pre_calc_distances()
        self.qubit_map = [i for i, v in enumerate(self.vertices)]
        self.n_qubits = len(self.vertices)

    def pre_calc_distances(self):
        self.distances = {"upper": [self.floyd_warshall(until, upper=True) for until, v in enumerate(self.vertices)],
                          "full": [self.floyd_warshall(until, upper=False) for until, v in enumerate(self.vertices)]}

    def to_quil_device(self):
        # Only required here
        import networkx as nx
        from pyquil.device import NxDevice
        edges = [edge for edge in self.graph.edges() if edge[0] in self.vertices]
        topology = nx.from_edgelist(edges)
        device = NxDevice(topology)
        return device

    def visualize(self, filename=None):
        import networkx as nx
        import matplotlib.pyplot as plt
        plt.switch_backend('agg')
        g = nx.Graph()
        g.add_nodes_from(self.vertices)
        g.add_edges_from(self.graph.edges())
        nx.draw(g, with_labels=True, font_weight='bold')
        if filename is None:
            filename = self.name + ".png"
        plt.savefig(filename)

    def floyd_warshall(self, exclude_excl, upper=True):
        """
        Implementation of the Floyd-Warshall algorithm to calculate the all-pair distances in a given graph

        :param exclude_excl: index up to which qubit should be excluded from the distances
        :param upper: whether use bidirectional edges or only ordered edges (src, tgt) such that src > tgt, default True
        :return: a dict with for each pair of qubits in the graph, a tuple with their distance and the corresponding shortest path
        """
        # https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm
        distances = {}
        vertices = self.vertices[exclude_excl:] if upper else self.vertices[:exclude_excl + 1]
        for edge in self.graph.edges():
            src, tgt = self.graph.edge_st(edge)
            if src in vertices and tgt in vertices:
                if upper:
                    distances[(src, tgt)] = (1, [(src, tgt)])
                    distances[(tgt, src)] = (1, [(tgt, src)])
                elif src > tgt:
                    distances[(src, tgt)] = (1, [(src, tgt)])
                else:
                    distances[(tgt, src)] = (1, [(tgt, src)])
        for v in vertices:
            distances[(v, v)] = (0, [])
        for i, v0 in enumerate(vertices):
            for j, v1 in enumerate(vertices if upper else vertices[:i + 1]):
                for v2 in vertices if upper else vertices[: i + j + 1]:
                    if (v0, v1) in distances.keys():
                        if (v1, v2) in distances.keys():
                            if (v0, v2) not in distances.keys() or distances[(v0, v2)][0] > distances[(v0, v1)][0] + \
                                    distances[(v1, v2)][0]:
                                distances[(v0, v2)] = (distances[(v0, v1)][0] + distances[(v1, v2)][0],
                                                       distances[(v0, v1)][1] + distances[(v1, v2)][1])
                                if upper:
                                    distances[(v2, v0)] = (distances[(v0, v1)][0] + distances[(v1, v2)][0],
                                                       distances[(v2, v1)][1] + distances[(v1, v0)][1])
        return distances

    def steiner_tree(self, start, nodes, upper=True):
        """
        Approximates the steiner tree given the architecture, a root qubit and the other qubits that should be present.
        This is done using the pre-calculated all-pairs shortest distance and Prim's algorithm for creating a minimum spanning tree
        :param start: The index of the root qubit to be used
        :param nodes: The indices of the other qubits that should be present in the steiner tree
        :param upper: Whether the steiner tree is used for creating an upper triangular matrix or a full reduction.
        :yields: First yields all edges from the tree top-to-bottom, finished with None, then yields all edges from the tree bottom-up, finished with None.
        """
        # Approximated by calculating the all-pairs shortest paths and then solving the mininum spanning tree over the subset of vertices and their respective shortest paths.
        # https://en.wikipedia.org/wiki/Steiner_tree_problem#Approximating_the_Steiner_tree

        # The all-pairs shortest paths are pre-calculated and the mimimum spanning tree is solved with Prim's algorithm
        # https://en.wikipedia.org/wiki/Prim%27s_algorithm

        # returns an iterator that walks the steiner tree, yielding (adj_node, leaf) pairs. If the walk is finished, it yields None
        state = [start, [n for n in nodes]]
        root = start
        # TODO deal with qubit mapping
        vertices = [root]
        edges = []
        debug and print(root, upper, nodes)
        distances = self.distances["upper"][root] if upper else self.distances["full"][root]
        steiner_pnts = []
        while nodes != []:
            options = [(node, v, *distances[(v, node)]) for node in nodes for v in (vertices + steiner_pnts) if
                       (v, node) in distances.keys()]
            best_option = min(options, key=lambda x: x[2])
            debug and print("Adding to tree: vertex ", best_option[0], "Edges ", best_option[3])
            vertices.append(best_option[0])
            edges.extend(best_option[3])
            steiner = [v for edge in best_option[3] for v in edge if v not in vertices]
            debug and print(steiner)
            steiner_pnts.extend(steiner)
            nodes.remove(best_option[0])
        edges = set(edges)  # remove duplicates
        if debug:
            print("edges:", edges)
            print("nodes:", vertices)
            print("steiner points:", steiner_pnts)
        # First go through the tree to find and remove zeros
        state += [[e for e in edges], [v for v in vertices], [s for s in steiner_pnts]]
        vs = {root}
        n_edges = len(edges)
        yielded_edges = set()
        debug_count = 0
        yield_count = 0
        warning = 0
        while len(yielded_edges) < n_edges:
            es = [e for e in edges for v in vs if e[0] == v]
            old_vs = [v for v in vs]
            yielded = False
            for edge in es:
                yield edge
                vs.add(edge[1])
                if edge in yielded_edges:
                    print("DOUBLE yielding! - should not be possible!")
                yielded_edges.add(edge)
                yielded = True
                yield_count += 1
            [vs.remove(v) for v in old_vs]
            if not yielded:
                debug and print("leaf!")
                debug_count += 1
                if debug_count > len(vertices):
                    print("infinite loop!", warning)
                    warning += 1
            if yield_count > len(edges):
                print("Yielded more edges than existing... This should not be possible!", warning)
                warning += 1
            if warning > 5:
                print(state, yielded_edges)
                # input("note it down")
                break
        yield None
        # Walk the tree bottom up to remove all ones.
        yield_count = 0
        while len(edges) > 0:
            # find leaf nodes:
            debug and print(vertices, steiner_pnts, edges)
            vs_to_consider = [vertex for vertex in vertices if vertex not in [e0 for e0, e1 in edges]] + \
                             [vertex for vertex in steiner_pnts if vertex not in [e0 for e0, e1 in edges]]
            yielded = False
            for v in vs_to_consider:
                # Get the edge that is connected to this leaf node
                for edge in [e for e in edges if e[1] == v]:
                    yield edge
                    edges.remove(edge)
                    yielded = True
                    yield_count += 1
                    # yield map(lambda i: self.qubit_map[i], edge)
            if not yielded:
                print("Infinite loop!", warning)
                warning += 1
            if yield_count > n_edges:
                print("Yielded more edges than existing again... This should not be possible!!", warning)
                warning += 1
            if warning > 10:
                print(state, edges, yield_count)
                # input("Note it down!")
                break
        yield None

def dynamic_size_architecture_name(base_name, n_qubits):
    return str(n_qubits) + "q-" + base_name

def connect_vertices_in_line(vertices):
    return [(vertices[i], vertices[i+1]) for i in range(len(vertices)-1)]

def connect_vertices_as_grid(width, height, vertices):
    if len(vertices) != width * height:
        raise KeyError("To make a grid, you need vertices exactly equal to width*height, but got %d=%d*%d." % (len(vertices), width, height))
    edges = connect_vertices_in_line(vertices)
    horizontal_lines = [vertices[i*width: (i+1)*width] for i in range(height)]
    for line1, line2 in zip(horizontal_lines, horizontal_lines[1:]):
        new_edges = [(v1, v2) for v1, v2 in zip(line1[:-1], reversed(line2[1:]))]
        edges.extend(new_edges)
    return edges

def create_line_architecture(n_qubits, backend=None, **kwargs):
    graph = Graph(backend=backend)
    vertices = graph.add_vertices(n_qubits)
    edges = connect_vertices_in_line(vertices)
    graph.add_edges(edges)
    name = dynamic_size_architecture_name(LINE, n_qubits)
    return Architecture(name=name, coupling_graph=graph, backend=backend, **kwargs)

def create_circle_architecture(n_qubits, backend=None, **kwargs):
    graph = Graph(backend=backend)
    vertices = graph.add_vertices(n_qubits)
    edges = connect_vertices_in_line(vertices)
    edges.append((vertices[-1], vertices[0]))
    graph.add_edges(edges)
    name = dynamic_size_architecture_name(CIRCLE, n_qubits)
    return Architecture(name=name, coupling_graph=graph, backend=backend, **kwargs)

def create_square_architecture(n_qubits, backend=None, **kwargs):
    # No floating point errors
    sqrt_qubits = 0
    for n in range(n_qubits):
        if n_qubits == n**2:
            sqrt_qubits = n
        if n**2 > n_qubits:
            break
    if sqrt_qubits == 0:
        raise KeyError("Sqaure architecture requires a square number of qubits, but got " + str(n_qubits))
    graph = Graph(backend=backend)
    vertices = graph.add_vertices(n_qubits)
    edges = connect_vertices_as_grid(sqrt_qubits, sqrt_qubits, vertices)
    graph.add_edges(edges)
    name = dynamic_size_architecture_name(SQUARE, n_qubits)
    return Architecture(name=name, coupling_graph=graph, backend=backend, **kwargs)

"""
def create_9q_square_architecture(**kwargs):
    m = np.array([
        [0, 1, 0, 0, 0, 1, 0, 0, 0],
        [1, 0, 1, 0, 1, 0, 0, 0, 0],
        [0, 1, 0, 1, 0, 0, 0, 0, 0],
        [0, 0, 1, 0, 1, 0, 0, 0, 1],
        [0, 1, 0, 1, 0, 1, 0, 1, 0],
        [1, 0, 0, 0, 1, 0, 1, 0, 0],
        [0, 0, 0, 0, 0, 1, 0, 1, 0],
        [0, 0, 0, 0, 0, 0, 1, 0, 1],
        [0, 0, 0, 1, 0, 0, 0, 1, 0]
    ])
    return Architecture(name=SQUARE_9Q, coupling_matrix=m, **kwargs)

def create_5q_line_architecture(**kwargs):
    m = np.array([
        [0, 1, 1, 0, 0],
        [1, 0, 1, 0, 0],
        [1, 1, 0, 1, 0],
        [0, 0, 1, 0, 1],
        [0, 0, 0, 1, 0]
    ])
    return Architecture(name=LINE_5Q, coupling_matrix=m, **kwargs)
"""
def create_ibm_qx2_architecture(**kwargs):
    m = np.array([
        [0, 1, 1, 0, 0],
        [1, 0, 1, 0, 0],
        [1, 1, 0, 1, 1],
        [0, 0, 1, 0, 1],
        [0, 0, 1, 1, 0]
    ])
    return Architecture(IBM_QX2, coupling_matrix=m, **kwargs)

def create_ibm_qx4_architecture(**kwargs):
    m = np.array([
        [0, 1, 1, 0, 0],
        [1, 0, 1, 0, 0],
        [1, 1, 0, 1, 1],
        [0, 0, 1, 0, 1],
        [0, 0, 1, 1, 0]
    ])
    return Architecture(IBM_QX4, coupling_matrix=m, **kwargs)

def create_ibm_qx3_architecture(**kwargs):
    m = np.array([
        #0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
        [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #0
        [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #1
        [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #2
        [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #3
        [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], #4
        [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], #5
        [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], #6
        [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0], #7
        [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0], #8
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], #9
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], #10
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], #11
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], #12
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0], #13
        [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], #14
        [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]  #15
    ])
    return Architecture(IBM_QX3, coupling_matrix=m, **kwargs)

def create_ibm_qx5_architecture(**kwargs):
    m = np.array([
        #0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
        [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], #0
        [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], #1
        [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], #2
        [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], #3
        [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], #4
        [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], #5
        [0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], #6
        [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], #7
        [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], #8
        [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0], #9
        [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], #10
        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], #11
        [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], #12
        [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], #13
        [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], #14
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]  #15
    ])
    return Architecture(IBM_QX5, coupling_matrix=m, **kwargs)

def create_ibm_q20_tokyo_architecture(backend=None, **kwargs):
    graph = Graph(backend=backend)
    vertices = graph.add_vertices(20)
    edges = connect_vertices_as_grid(5, 4, vertices)
    cross_edges = [
        (1, 7), (2, 8),
        (3, 5), (4, 6),
        (6, 12), (7, 13),
        (8, 10), (9, 11),
        (11, 17), (12, 18),
        (13, 15), (14, 16)
    ]
    edges.extend([(vertices[v1], vertices[v2]) for v1, v2 in cross_edges])
    graph.add_edges(edges)
    return Architecture(name=IBM_Q20_TOKYO, coupling_graph=graph, backend=backend, **kwargs)

def create_rigetti_16q_aspen_architecture(backend=None, **kwargs):
    graph = Graph(backend=backend)
    vertices = graph.add_vertices(16)
    edges = connect_vertices_in_line(vertices)
    extra_edges = [(0, 7), (8, 15), (15, 0)]
    edges += [(vertices[v1], vertices[v2]) for v1, v2 in extra_edges]
    graph.add_edges(edges)
    return Architecture(RIGETTI_16Q_ASPEN, coupling_graph=graph, backend=backend, **kwargs)

def create_rigetti_8q_agave_architecture(**kwargs):
    m = np.array([
        [0, 1, 0, 0, 0, 0, 0, 1],
        [1, 0, 1, 0, 0, 0, 0, 0],
        [0, 1, 0, 1, 0, 0, 0, 0],
        [0, 0, 1, 0, 1, 0, 0, 0],
        [0, 0, 0, 1, 0, 1, 0, 0],
        [0, 0, 0, 0, 1, 0, 1, 0],
        [0, 0, 0, 0, 0, 1, 0, 1],
        [1, 0, 0, 0, 0, 0, 1, 0]
    ])
    return Architecture(RIGETTI_8Q_AGAVE, coupling_matrix=m, **kwargs)

def create_fully_connected_architecture(n_qubits=None, **kwargs):
    if n_qubits is None:
        print("Warning: size is not given for the fully connected architecuture, using 9 as default.")
        n_qubits = 9
    m = np.ones(shape=(n_qubits, n_qubits))
    for i in range(n_qubits):
        m[i][i] = 0
    name = dynamic_size_architecture_name(FULLY_CONNNECTED, n_qubits)
    return Architecture(name, coupling_matrix=m, **kwargs)

def create_architecture(name, **kwargs):
    # Source Rigetti architectures: https://www.rigetti.com/qpu # TODO create the architectures from names in pyquil.list_quantum_computers() <- needs mapping
    # Source IBM architectures: http://iic.jku.at/files/eda/2018_tcad_mapping_quantum_circuit_to_ibm_qx.pdf​
    # IBM architectures are currently ignoring CNOT direction.
    if isinstance(name, Architecture):
        return name
    if name == SQUARE:
        return create_square_architecture(**kwargs)
    elif name == LINE:
        return create_line_architecture(**kwargs)
    elif name == FULLY_CONNNECTED:
        return create_fully_connected_architecture(**kwargs)
    elif name == CIRCLE:
        return create_circle_architecture(**kwargs)
    elif name == IBM_QX2:
        return create_ibm_qx2_architecture(**kwargs)
    elif name == IBM_QX3:
        return create_ibm_qx3_architecture(**kwargs)
    elif name == IBM_QX4:
        return create_ibm_qx4_architecture(**kwargs)
    elif name == IBM_QX5:
        return create_ibm_qx5_architecture(**kwargs)
    elif name == IBM_Q20_TOKYO:
        return create_ibm_q20_tokyo_architecture(**kwargs)
    elif name == RIGETTI_16Q_ASPEN:
        return create_rigetti_16q_aspen_architecture(**kwargs)
    elif name == RIGETTI_8Q_AGAVE:
        return create_rigetti_8q_agave_architecture(**kwargs)
    else:
        raise KeyError("name" + str(name) + "not recognized as architecture name. Please use one of", *architectures)

def colored_print_9X9(np_array):
    """
    Prints a 9x9 numpy array with colors representing their distance in a 9x9 square architecture
    :param np_array:  the array
    """
    if np_array.shape == (9,9):
        CRED = '\033[91m '
        CEND = '\033[0m '
        CGREEN = '\33[32m '
        CYELLOW = '\33[33m '
        CBLUE = '\33[34m '
        CWHITE = '\33[37m '
        CVIOLET = '\33[35m '
        color = [CBLUE, CGREEN, CVIOLET, CYELLOW, CRED]
        layout = [[0,1,2,3,2,1,2,3,4],
                  [1,0,1,2,1,2,3,2,3],
                  [2,1,0,1,2,3,4,3,2],
                  [3,2,1,0,1,2,3,2,1],
                  [2,1,2,1,0,1,2,1,2],
                  [1,2,3,2,1,0,1,2,3],
                  [2,3,4,3,2,1,0,1,2],
                  [3,2,3,2,1,2,1,0,1],
                  [4,3,2,1,2,3,2,1,0]]
        for i, l in enumerate(layout):
            print('[', ', '.join([(color[c] + '1' if v ==1 else CWHITE + '0') for c, v in zip(l, np_array[i])]), CEND, ']')
    else:
        print(np_array)

if __name__ == '__main__':
    n_qubits = 25
    for name in dynamic_size_architectures:
        arch = create_architecture(name, n_qubits=n_qubits)
        arch.visualize()

    arch = create_architecture(IBM_Q20_TOKYO)
    arch.visualize()import graph_tool.all as gt

from .base import BaseGraph

#DEPRECATED
class GraphGT(BaseGraph):
	backend = 'graph_tool'
	def __init__(self):
		raise Warning("Graph_tool is currently not fully supported.")
		BaseGraph.__init__(self)
		self.graph = gt.Graph(directed=False)
		self.graph.set_fast_edge_removal()
		self.graph.vp.type = self.graph.new_vertex_property('int')

	def add_vertices(self, amount, vertex_data=None):
		self.graph.add_vertex(amount)

	def add_edges(self, edges, vertex_data=None):
		self.graph.add_edge_list(edges)

	def remove_vertices(self, vertices):
		for v in reversed(sorted(vertices)):
			self.graph.remove_vertex(v,fast=True)

	def remove_vertex(self, vertex):
		self.graph.remove_vertex(v)

	def remove_edges(self, edges):
		for e in edges:
			if isinstance(e,tuple):
				self.graph.remove_edge(self.graph.edge(e[0],e[1]))
			else:
				self.graph.remove_edge(e)

	def num_vertices(self):
		return self.graph.get_vertices().shape[0]

	def num_edges(self):
		return self.graph.get_edges().shape[0]

	def vertices(self):
		'''Iterator over all the vertices'''
		return self.graph.vertices()

	def verts_as_int(self, verts):
		return [int(v) for v in verts]

	def edges(self):
		'''Iterator over all the edges'''
		return self.graph.edges()

	def edges_as_int(self, edges):
		return [(self.graph.edge_index[e] if isinstance(e,gt.Edge) else e) for e in edges]

	def edge_set(self):
		#return set(self.graph.get_edges()[...,2])
		return set(self.graph.edges())

	def edge_st(self, edge):
		'''Returns a tuple of source/target of the given edge'''
		if isinstance(edge, gt.Edge):
			return (edge.source(), edge.target())
		e = gt.find_edge(self.graph,self.graph.edge_index,edge)[0]
		return (e.source(), e.target())

	def get_neighbours(self, vertex):
		'''Returns a tuple of source/target of the given edge'''
		return vertex.all_neighbors()

	def get_vertex_degree(self, vertex):
		'''Returns all neighbouring vertices of the given vertex'''
		return vertex.in_degree() + vertex.out_degree()

	def get_incident_edges(self, vertex):
		#return [self.graph.edge_index[e] for e in vertex.all_edges()]
		return vertex.all_edges()

	def is_connected(self,v1,v2):
		return bool(self.graph.edge(v1, v2))

	def is_equal(self,v1,v2):
		'''Returns whether v1 and v2 represent the same vertex'''
		return int(v1) == int(v2)

	def get_type(self, vertex):
		return self.graph.vp.type[vertex]

	def set_type(self, vertex, t):
		self.graph.vp.type[vertex] = t

	def add_attribute(self, attrib_name, default=0):
		self.graph.vertex_properties[attrib_name] = self.graph.new_vertex_property('int')
		self.graph.vertex_properties[attrib_name].set_value(default)
# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

_all__ = ['Graph', 'graph']
from .graph import Graph# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

backends = {'simple': True}

typeB = 0
typeZ = 1
typeX = 2

def Graph(backend=None):
	"""Returns an instance of an implementation of :class:`~graph.base.BaseGraph`. 
	By default :class:`~graph.graph_s.GraphS` is used. 
	Currently ``backend`` is allowed to be `simple` (for the default),
	or 'graph_tool' and 'igraph'.
	**Note**: graph_tool is currently not fully supported."""
	if not backend: backend = 'simple'
	if backend:
		if backend not in backends:
			raise KeyError("Unavailable backend '{}'".format(backend))
		if backend == 'simple': return GraphS()
		if backend == 'graph_tool': 
			return GraphGT()
		if backend == 'igraph': return GraphIG()
	return GraphS()

from .graph_s import GraphS

try:
	import graph_tool.all as gt
	from .graph_gt import GraphGT
	backends['graph_tool'] = gt
except ImportError:
	pass
try:
	import igraph as ig
	from .graph_ig import GraphIG
	backends['igraph'] = ig 
except ImportError:
	pass
# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

from fractions import Fraction
from .base import BaseGraph

class GraphS(BaseGraph):
	"""Purely Pythonic implementation of :class:`~graph.base.BaseGraph`."""
	backend = 'simple'

	#The documentation of what these methods do 
	#can be found in base.BaseGraph
	def __init__(self):
		BaseGraph.__init__(self)
		self.graph = dict()
		self._vindex = 0
		self.nedges = 0
		self.ty = dict()
		self._phase = dict()
		self._qindex = dict()
		self._maxq = -1
		self._rindex = dict()
		self._maxr = -1

		self.inputs = []
		self.outputs = []
		self._vdata = dict()
		

	def vindex(self): return self._vindex
	def depth(self): 
		if self._rindex: self._maxr = max(self._rindex.values())
		else: self._maxr = -1
		return self._maxr
	def qubit_count(self): 
		if self._qindex: self._maxq = max(self._qindex.values())
		else: self._maxq = -1
		return self._maxq + 1

	def add_vertices(self, amount):
		for i in range(self._vindex, self._vindex + amount):
			self.graph[i] = dict()
			self.ty[i] = 0
			self._phase[i] = 0
		self._vindex += amount
		return range(self._vindex - amount, self._vindex)

	def add_edges(self, edges, edgetype=1):
		for s,t in edges:
			self.nedges += 1
			self.graph[s][t] = edgetype
			self.graph[t][s] = edgetype

	def remove_vertices(self, vertices):
		for v in vertices:
			vs = list(self.graph[v])
			# remove all edges
			for v1 in vs:
				self.nedges -= 1
				del self.graph[v][v1]
				del self.graph[v1][v]
			# remove the vertex
			del self.graph[v]
			del self.ty[v]
			del self._phase[v]
			try: del self._qindex[v]
			except: pass
			try: del self._rindex[v]
			except: pass
			try: del self.phase_index[v]
			except: pass
			self._vdata.pop(v,None)

	def remove_vertex(self, vertex):
		self.remove_vertices([vertex])

	def remove_isolated_vertices(self):
		self.remove_vertices([v for v in self.vertices() if self.vertex_degree(v)==0])

	def remove_edges(self, edges):
		for s,t in edges:
			self.nedges -= 1
			del self.graph[s][t]
			del self.graph[t][s]

	def remove_edge(self, edge):
		self.remove_edges([edge])

	def num_vertices(self):
		return len(self.graph)

	def num_edges(self):
		return self.nedges

	def vertices(self):
		return self.graph.keys()

	def vertices_in_range(self, start, end):
		"""Returns all vertices with index between start and end
		that only have neighbours whose indices are between start and end"""
		for v in self.graph.keys():
			if not start<v<end: continue
			if all(start<v2<end for v2 in self.graph[v]):
				yield v

	def edges(self):
		for v0,adj in self.graph.items():
			for v1 in adj:
				if v1 > v0: yield (v0,v1)

	def edges_in_range(self, start, end, safe=False):
		"""like self.edges, but only returns edges that belong to vertices 
		that are only directly connected to other vertices with 
		index between start and end.
		If safe=True then it also checks that every neighbour is only connected to vertices with the right index"""
		if not safe:
			for v0,adj in self.graph.items():
				if not (start<v0<end): continue
				#verify that all neighbours are in range
				if all(start<v1<end for v1 in adj):
					for v1 in adj:
						if v1 > v0: yield (v0,v1)
		else:
			for v0,adj in self.graph.items():
				if not (start<v0<end): continue
				#verify that all neighbours are in range, and that each neighbour
				# is only connected to vertices that are also in range
				if all(start<v1<end for v1 in adj) and all(all(start<v2<end for v2 in self.graph[v1]) for v1 in adj):
					for v1 in adj:
						if v1 > v0:
							yield (v0,v1)

	def edge(self, s, t):
		return (s,t) if s < t else (t,s)
	def edge_set(self):
		return set(self.edges())
	def edge_st(self, edge):
		return edge

	def neighbours(self, vertex):
		return self.graph[vertex].keys()

	def vertex_degree(self, vertex):
		return len(self.graph[vertex])

	def incident_edges(self, vertex):
		return [(vertex, v1) if v1 > vertex else (v1, vertex) for v1 in self.graph[vertex]]

	def connected(self,v1,v2):
		return v2 in self.graph[v1]

	def edge_type(self, e):
		v1,v2 = e
		try:
			return self.graph[v1][v2]
		except KeyError:
			return 0

	def set_edge_type(self, e, t):
		v1,v2 = e
		self.graph[v1][v2] = t
		self.graph[v2][v1] = t

	def type(self, vertex):
		return self.ty[vertex]
	def types(self):
		return self.ty
	def set_type(self, vertex, t):
		self.ty[vertex] = t

	def phase(self, vertex):
		return self._phase.get(vertex,Fraction(1))
	def phases(self):
		return self._phase
	def set_phase(self, vertex, phase):
		self._phase[vertex] = Fraction(phase) % 2
	def add_to_phase(self, vertex, phase):
		self._phase[vertex] = (self._phase.get(vertex,Fraction(1)) + phase) % 2

	def qubit(self, vertex):
		return self._qindex.get(vertex,-1)
	def qubits(self):
		return self._qindex
	def set_qubit(self, vertex, q):
		if q > self._maxq: self._maxq = q
		self._qindex[vertex] = q

	def row(self, vertex):
		return self._rindex.get(vertex, -1)
	def rows(self):
		return self._rindex
	def set_row(self, vertex, r):
		if r > self._maxr: self._maxr = r
		self._rindex[vertex] = r

	def vdata_keys(self, vertex):
		return self._vdata.get(vertex, {}).keys()
	def vdata(self, vertex, key, default=0):
		if vertex in self._vdata:
			return self._vdata[vertex].get(key,default)
		else:
			return default
	def set_vdata(self, vertex, key, val):
		if vertex in self._vdata:
			self._vdata[vertex][key] = val
		else:
			self._vdata[vertex] = {key:val}# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

try:
	import igraph as ig
except ImportError:
	print("python-igraph not available")
	ig = None

from .base import BaseGraph

class GraphIG(BaseGraph):
	"""Implementation of :class:`~graph.base.BaseGraph` using ``python-igraph`` 
	as its backend"""
	backend = 'igraph'
	def __init__(self):
		BaseGraph.__init__(self)
		self.graph = ig.Graph(directed=False)
		self.graph.vs['_a'] = None
		self.graph.vs['_t'] = None
		self.graph.vs['_q'] = None
		self.graph.vs['_r'] = None
		self.graph.es['_t'] = None
		self._maxq = -1
		self._maxr = -1
		self.inputs = []
		self.outputs = []

	# since igraph uses consecutive indexing, vindex() == num_vertices()
	def vindex(self):
		return self.num_vertices()

	def depth(self): 
		self._maxr = max(self._rindex.values())
		return self._maxr
	def qubit_count(self): return self._maxq + 1

	def add_vertices(self, amount, vertex_data=None):
		self.graph.add_vertices(amount)
		n = self.num_vertices()
		return range(n - amount, n)

	def add_edges(self, edges, edge_data=None):
		self.graph.add_edges(edges)

	def remove_vertices(self, vertices):
		self.graph.delete_vertices(vertices)

	def remove_isolated_vertices(self):
		self.graph.vs.select(_degree=0).delete()

	def remove_edges(self, edges):
		self.graph.delete_edges(edges)

	def num_vertices(self):
		return len(self.graph.vs)

	def num_edges(self):
		return len(self.graph.es)

	def vertices(self):
		return range(len(self.graph.vs))

	def edges(self):
		return range(len(self.graph.es))

	def edge(self, s, t):
		return self.graph.es[s,t][0].index
	
	def edge_st(self, edge):
		edge = self.graph.es[edge]
		return (edge.source, edge.target)

	def edge_s(self, edge):
		edge = self.graph.es[edge]
		return edge.source

	def edge_t(self, edge):
		edge = self.graph.es[edge]
		return edge.target

	def neighbours(self, vertex):
		return self.graph.neighbors(vertex)

	def vertex_degree(self, vertex):
		return self.graph.degree(vertex)

	def incident_edges(self, vertex):
		return self.graph.incident(vertex, mode=ig.ALL)

	def connected(self,v1,v2):
		return self.graph.are_connected(v1,v2)

	def edge_type(self, e):
		if e in self.graph.es:
			t = self.graph.es[e]['_t']
			return 1 if t == None else t
		else:
			return 0

	def set_edge_type(self, e, t):
		self.graph.es[e]['_t'] = t


	def type(self, v):
		t = self.graph.vs[v]['_t']
		return t if t != None else 0

	def types(self):
		return self.graph.vs['_t']

	def set_type(self, v, t):
		self.graph.vs[v]['_t'] = t
		
	def phase(self, vertex):
		a = self.graph.vs[vertex]['_a']
		return a if a != None else 0

	def phases(self):
		return [a if a != None else 0 for a in self.graph.vs['_a']]

	def set_phase(self, vertex, phase):
		self.graph.vs[vertex]['_a'] = phase % 2

	def qubit(self, vertex):
		return self.graph.vs[vertex]['_q'] or -1
	def qubits(self):
		return self.graph.vs['_q']
	def set_qubit(self, vertex, q):
		if q > self._maxq: self._maxq = q
		self.graph.vs[vertex]['_q'] = q

	def row(self, vertex):
		return self.graph.vs[vertex]['_r'] or -1
	def rows(self):
		return self.graph.vs['_r']
	def set_row(self, vertex, r):
		if r > self._maxr: self._maxr = r
		self.graph.vs[vertex]['_r'] = r

	def set_vdata(self, v, key, val):
		self.graph.vs[v][key] = val

	def vdata_keys(self, v):
		return [a for a in self.graph.vertex_attributes() if a != '_a' and a != '_t' and a != '_q' and a != '_r']

	def vdata(self, v, key, default=0):
		try:
			val = self.graph.vs[v][key]
			if not val: val = default
		except KeyError:
			val = default
		return val# PyZX - Python library for quantum circuit rewriting 
#        and optimisation using the ZX-calculus
# Copyright (C) 2018 - Aleks Kissinger and John van de Wetering

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import abc

from pyzx.tensor import tensorfy, tensor_to_matrix

class DocstringMeta(abc.ABCMeta):
    """Metaclass that allows docstring 'inheritance'."""

    def __new__(mcls, classname, bases, cls_dict):
        cls = abc.ABCMeta.__new__(mcls, classname, bases, cls_dict)
        mro = cls.__mro__[1:]
        for name, member in cls_dict.items():
            if not getattr(member, '__doc__'):
                for base in mro:
                    try:
                        member.__doc__ = getattr(base, name).__doc__
                        break
                    except AttributeError:
                        pass
        return cls

def pack_indices(lst):
    d = dict()
    if len(lst) == 0: return d
    list.sort(lst)
    i = 0
    x = None
    for j in range(len(lst)):
        y = lst[j]
        if y != x:
            x = y
            d[y] = i
            i += 1
    return d

class BaseGraph(object):
    """Base class for letting graph backends interact with PyZX.
    For a backend to work with PyZX, there should be a class that implements
    all the methods of this class. For implementations of this class see 
    :class:`~graph.graph_s.GraphS` or :class `~graph.graph_ig.GraphIG`."""
    __metaclass__ = DocstringMeta
    backend = 'None'

    def __init__(self):
        self.track_phases = False
        self.phase_index = dict()
        self.phase_master = None
        self.phase_mult = dict()
        self.max_phase_index = -1

    def __str__(self):
        return "Graph({} vertices, {} edges)".format(
                str(self.num_vertices()),str(self.num_edges()))

    def __repr__(self):
        return str(self)

    def stats(self):
        s = str(self) + "\n"
        degrees = {}
        for v in self.vertices():
            d = self.vertex_degree(v)
            if d in degrees: degrees[d] += 1
            else: degrees[d] = 1
        s += "degree distribution: \n"
        for d, n in sorted(degrees.items(),key=lambda x: x[0]):
            s += "{:d}: {:d}\n".format(d,n)
        return s

    def copy(self, adjoint=False, backend=None):
        """Create a copy of the graph. If ``adjoint`` is set, 
        the adjoint of the graph will be returned (inputs and outputs flipped, phases reversed).
        When ``backend`` is set, a copy of the graph with the given backend is produced. 
        By default the copy will have the same backend.

        `Note`: The copy will have consecutive vertex indices, even if the original
        graph did not.
        """
        from .graph import Graph # imported here to prevent circularity
        if (backend == None):
            backend = type(self).backend
        g = Graph(backend = backend)
        g.track_phases = self.track_phases
        mult = 1
        if adjoint: mult = -1

        #g.add_vertices(self.num_vertices())
        ty = self.types()
        ph = self.phases()
        qs = self.qubits()
        rs = self.rows()
        maxr = self.depth()
        vtab = dict()
        for v in self.vertices():
            i = g.add_vertex(ty[v],phase=mult*ph[v])
            if v in qs: g.set_qubit(i,qs[v])
            if v in rs: 
                if adjoint: g.set_row(i, maxr-rs[v])
                else: g.set_row(i, rs[v])
            vtab[v] = i
            for k in self.vdata_keys(v):
                g.set_vdata(i, k, self.vdata(v, k))

        for i in self.inputs:
            if adjoint: g.outputs.append(vtab[i])
            else: g.inputs.append(vtab[i])
        for o in self.outputs:
            if adjoint: g.inputs.append(vtab[o])
            else: g.outputs.append(vtab[o])
        
        etab = {e:(vtab[self.edge_s(e)],vtab[self.edge_t(e)]) for e in self.edges()}
        g.add_edges(etab.values())
        for e,(s,t) in etab.items():
            g.set_edge_type(g.edge(s,t), self.edge_type(e))
        return g
    def adjoint(self):
        """Returns a new graph equal to the adjoint of this graph."""
        return self.copy(adjoint=True)

    def replace_subgraph(self, left_row, right_row, replace):
        """Deletes the subgraph of all nodes with rank strictly between ``left_row``
        and ``right_row`` and replaces it with the graph ``replace``.
        The amount of nodes on the left row should match the amount of inputs of 
        the replacement graph and the same for the right row and the outputs.
        The graphs are glued together based on the qubit index of the vertices."""
        qleft = [v for v in self.vertices() if self.row(v)==left_row]
        qright= [v for v in self.vertices() if self.row(v)==right_row]
        if len(qleft) != len(replace.inputs):
            raise TypeError("Inputs do not match glueing vertices")
        if len(qright) != len(replace.outputs):
            raise TypeError("Outputs do not match glueing vertices")
        if set(self.qubit(v) for v in qleft) != set(replace.qubit(v) for v in replace.inputs):
            raise TypeError("Input qubit indices do not match")
        if set(self.qubit(v) for v in qright)!= set(replace.qubit(v) for v in replace.outputs):
            raise TypeError("Output qubit indices do not match")
        
        self.remove_vertices([v for v in self.vertices() if (left_row < self.row(v) and self.row(v) < right_row)])
        self.remove_edges([self.edge(s,t) for s in qleft for t in qright if self.connected(s,t)])
        rdepth = replace.depth() -1
        for v in (v for v in self.vertices() if self.row(v)>=right_row):
            self.set_row(v, self.row(v)+rdepth)

        vtab = {}
        for v in replace.vertices():
            if v in replace.inputs or v in replace.outputs: continue
            vtab[v] = self.add_vertex(replace.type(v),replace.qubit(v),
                                replace.row(v)+left_row,replace.phase(v))
        for v in replace.inputs:
            vtab[v] = [i for i in qleft if self.qubit(i) == replace.qubit(v)][0]

        for v in replace.outputs:
            vtab[v] = [i for i in qright if self.qubit(i) == replace.qubit(v)][0]

        etab = {e:(vtab[replace.edge_s(e)],vtab[replace.edge_t(e)]) for e in replace.edges()}
        self.add_edges(etab.values())
        for e,(s,t) in etab.items():
            self.set_edge_type(self.edge(s,t), replace.edge_type(e))

    def compose(self, other):
        """Inserts a circuit after this one. The amount of qubits of the circuits must match."""
        if self.qubit_count() != other.qubit_count():
            raise TypeError("Circuits work on different qubit amounts")
        self.normalise()
        other = other.copy()
        other.normalise()
        for o in self.outputs:
            q = self.qubit(o)
            e = list(self.incident_edges(o))[0]
            if self.edge_type(e) == 2: #hadamard edge
                i = [v for v in other.inputs if other.qubit(v)==q][0]
                e = list(other.incident_edges(i))[0]
                other.set_edge_type(e, 3-other.edge_type(e)) # toggle the edge type
        d = self.depth()
        self.replace_subgraph(d-1,d,other)

    def to_tensor(self):
        """Returns a representation of the graph as a tensor using :func:`~pyzx.tensor.tensorfy`"""
        return tensorfy(self)
    def to_matrix(self):
        """Returns a representation of the graph as a matrix using :func:`~pyzx.tensor.tensorfy`"""
        return tensor_to_matrix(tensorfy(self), len(self.inputs), len(self.outputs))


    def vindex(self):
        """The index given to the next vertex added to the graph. It should always
        be equal to ``max(g.vertices()) + 1``."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)

    def depth(self):
        """Returns the value of the highest row number given to a vertex.
        This is -1 when no rows have been set."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)

    def pack_circuit_rows(self):
        """Compresses the rows of the graph so that every index is used."""
        rows = [self.row(v) for v in self.vertices()]
        new_rows = pack_indices(rows)
        for v in self.vertices():
            self.set_row(v, new_rows[self.row(v)])

    def qubit_count(self):
        """Returns the value of the highest qubit index given to a vertex.
        This is -1 when no qubit indices have been set."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)

    def auto_detect_inputs(self):
        if self.inputs or self.outputs: return self.inputs, self.outputs
        minrow = 100000
        maxrow = -100000
        nodes = {}
        ty = self.types()
        for v in self.vertices():
            if ty[v] == 0:
                r = self.row(v)
                nodes[v] = r
                if r < minrow:
                    minrow = r
                if r > maxrow:
                    maxrow = r

        for v,r in nodes.items():
            if r == minrow:
                self.inputs.append(v)
            if r == maxrow:
                self.outputs.append(v)
        self.inputs.sort(key=self.qubit)
        self.outputs.sort(key=self.qubit)
        return self.inputs, self.outputs


    def normalise(self):
        """Puts every node connecting to an input/output at the correct qubit index and row."""
        if not self.inputs:
            self.auto_detect_inputs()
        max_r = self.depth() - 1
        if max_r <= 2: return
        claimed = []
        for q,i in enumerate(sorted(self.inputs, key=self.qubit)):
            self.set_row(i,0)
            self.set_qubit(i,q)
            #q = self.qubit(i)
            n = list(self.neighbours(i))[0]
            if self.type(n) in (1,2):
                claimed.append(n)
                self.set_row(n,1)
                self.set_qubit(n, q)
            else: #directly connected to output
                e = self.edge(i, n)
                t = self.edge_type(e)
                self.remove_edge(e)
                v = self.add_vertex(1,q,1)
                self.add_edge((i,v),3-t)
                self.add_edge((v,n), 2)
                claimed.append(v)
        for q, o in enumerate(sorted(self.outputs,key=self.qubit)):
            #q = self.qubit(o)
            self.set_row(o,max_r+1)
            self.set_qubit(o,q)
            n = list(self.neighbours(o))[0]
            if n not in claimed:
                self.set_row(n,max_r)
                self.set_qubit(n, q)
            else:
                e = self.edge(o, n)
                t = self.edge_type(e)
                self.remove_edge(e)
                v = self.add_vertex(1,q,max_r)
                self.add_edge((o,v),3-t)
                self.add_edge((v,n), 2)

        self.pack_circuit_rows()

    def add_vertices(self, amount):
        """Add the given amount of vertices, and return the indices of the
        new vertices added to the graph, namely: range(g.vindex() - amount, g.vindex())"""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)

    def add_vertex(self, ty=0, qubit=-1, row=-1, phase=0):
        """Add a single vertex to the graph and return its index.
        The optional parameters allow you to respectively set
        the type, qubit index, row index and phase of the vertex."""
        v = self.add_vertices(1)[0]
        if ty: self.set_type(v, ty)
        if qubit!=-1: self.set_qubit(v, qubit)
        if row!=-1: self.set_row(v, row)
        if phase: 
            self.set_phase(v, phase)
        if self.track_phases:
            self.max_phase_index += 1
            self.phase_index[v] = self.max_phase_index
            self.phase_mult[v] = 1
        return v

    def add_edges(self, edges, edgetype=1):
        """Adds a list of edges to the graph. 
        If edgetype is 1 (the default), these will be regular edges.
        If edgetype is 2, these edges will be Hadamard edges."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)

    def add_edge(self, edge, edgetype=1):
        """Adds a single edge of the given type (1=regular, 2=Hadamard edge)"""
        self.add_edges([edge], edgetype)

    def add_edge_table(self, etab):
        """Takes a dictionary mapping (source,target) --> (#edges, #h-edges) specifying that
        #edges regular edges must be added between source and target and $h-edges Hadamard edges.
        The method selectively adds or removes edges to produce that ZX diagram which would 
        result from adding (#edges, #h-edges), and then removing all parallel edges using Hopf/spider laws."""
        add = ([],[]) # list of edges and h-edges to add
        remove = []   # list of edges to remove
        #add_pi_phase = []
        for (v1,v2),(n1,n2) in etab.items():
            conn_type = self.edge_type(self.edge(v1,v2))
            if conn_type == 1: n1 += 1 #and add to the relevant edge count
            elif conn_type == 2: n2 += 1
            
            t1 = self.type(v1)
            t2 = self.type(v2)
            if t1 == t2:         #types are equal,
                n1 = bool(n1)     #so normal edges fuse
                n2 = n2%2         #while hadamard edges go modulo 2
                if n1 != 0 and n2 != 0:  #reduction rule for when both edges appear
                    new_type = 1
                    self.add_to_phase(v1, 1)
                    #add_pi_phase.append(v1)
                elif n1 != 0: new_type = 1
                elif n2 != 0: new_type = 2
                else: new_type = 0
            else:                #types are different
                n1 = n1%2        #so normal edges go modulo 2
                n2 = bool(n2)    #while hadamard edges fuse
                if n1 != 0 and n2 != 0:  #reduction rule for when both edges appear
                    new_type = 2
                    self.add_to_phase(v1, 1)
                    #add_pi_phase.append(v1)
                elif n1 != 0: new_type = 1
                elif n2 != 0: new_type = 2
                else: new_type = 0
            if new_type != 0: # They should be connected, so update the graph
                if conn_type == 0: #new edge added
                    add[new_type-1].append((v1,v2))
                elif conn_type != new_type: #type of edge has changed
                    self.set_edge_type(self.edge(v1,v2), new_type)
            elif conn_type != 0: #They were connected, but not anymore, so update the graph
                remove.append(self.edge(v1,v2))

        self.remove_edges(remove)
        self.add_edges(add[0],1)
        self.add_edges(add[1],2)

    def set_phase_master(self, m):
        self.phase_master = m

    def update_phase_index(self, old, new):
        if not self.track_phases: return
        i = self.phase_index[old]
        self.phase_index[old] = self.phase_index[new]
        self.phase_index[new] = i

    def fuse_phases(self, p1, p2):
        if p1 not in self.phase_index or p2 not in self.phase_index: 
            return
        if self.phase_master: 
            self.phase_master.fuse_phases(self.phase_index[p1],self.phase_index[p2])
        self.phase_index[p2] = self.phase_index[p1]

    def phase_negate(self, v):
        if v not in self.phase_index: return
        index = self.phase_index[v]
        #print("Negating phase", v, index)
        mult = self.phase_mult[index]
        self.phase_mult[index] = -1*mult 

    def vertex_from_phase_index(self, i):
        return list(self.phase_index.keys())[list(self.phase_index.values()).index(i)]


    def remove_vertices(self, vertices):
        """Removes the list of vertices from the graph."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)

    def remove_vertex(self, vertex):
        """Removes the given vertex from the graph."""
        self.remove_vertices([vertex])

    def remove_isolated_vertices(self):
        """Deletes all vertices that are not connected to any other vertex.
        Should be replaced by a faster alternative if available in the backend."""
        self.remove_vertices([v for v in self.vertices() if self.vertex_degree(v)==0])

    def remove_edges(self, edges):
        """Removes the list of edges from the graph."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)

    def remove_edge(self, edge):
        """Removes the given edge from the graph."""
        self.remove_edge([edge])

    def num_vertices(self):
        """Returns the amount of vertices in the graph."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)

    def num_edges(self):
        """Returns the amount of edges in the graph"""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)

    def vertices(self):
        """Iterator over all the vertices."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)

    def edges(self):
        """Iterator that returns all the edges. Output type depends on implementation in backend."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)

    def vertex_set(self):
        """Returns the vertices of the graph as a Python set. 
        Should be overloaded if the backend supplies a cheaper version than this."""
        return set(self.vertices())

    def edge_set(self):
        """Returns the edges of the graph as a Python set. 
        Should be overloaded if the backend supplies a cheaper version than this."""
        return set(self.edges())

    def edge(self, s, t):
        """Returns the edge object with the given source/target."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)

    def edge_st(self, edge):
        """Returns a tuple of source/target of the given edge."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)
    def edge_s(self, edge):
        """Returns the source of the given edge."""
        return self.edge_st(edge)[0]
    def edge_t(self, edge):
        """Returns the target of the given edge."""
        return self.edge_st(edge)[1]

    def neighbours(self, vertex):
        """Returns all neighbouring vertices of the given vertex."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)

    def vertex_degree(self, vertex):
        """Returns the degree of the given vertex."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)

    def incident_edges(self, vertex):
        """Returns all neighbouring edges of the given vertex."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)

    def connected(self,v1,v2):
        """Returns whether vertices v1 and v2 share an edge."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)

    def edge_type(self, e):
        """Returns the type of the given edge:
        1 if it is regular, 2 if it is a Hadamard edge, 0 if the edge is not in the graph."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)
    def set_edge_type(self, e, t):
        """Sets the type of the given edge."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)

    def type(self, vertex):
        """Returns the type of the given vertex:
        0 if it is a boundary, 1 if is a Z node, 2 if it a X node."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)
    def types(self):
        """Returns a mapping of vertices to their types."""
        raise NotImplementedError("Not implemented on backend " + type(self).backend)
    def set_type(self, vertex, t):
        """Sets the type of the given vertex to t."""
        raise NotImplementedError("Not implemented on backend" + type(self).backend)
    
    def phase(self, vertex):
        """Returns the phase value of the given vertex."""
        raise NotImplementedError("Not implemented on backend" + type(self).backend)
    def phases(self):
        """Returns a mapping of vertices to their phase values."""
        raise NotImplementedError("Not implemented on backend" + type(self).backend)
    def set_phase(self, vertex, phase):
        """Sets the phase of the vertex to the given value."""
        raise NotImplementedError("Not implemented on backend" + type(self).backend)
    def add_to_phase(self, vertex, phase):
        """Add the given phase to the phase value of the given vertex."""
        self.set_phase(vertex,self.phase(vertex)+phase)

    def qubit(self, vertex):
        """Returns the qubit index associated to the vertex. 
        If no index has been set, returns -1."""
        raise NotImplementedError("Not implemented on backend" + type(self).backend)
    def qubits(self):
        """Returns a mapping of vertices to their qubit index."""
        raise NotImplementedError("Not implemented on backend" + type(self).backend)
    def set_qubit(self, vertex, q):
        """Sets the qubit index associated to the vertex."""
        raise NotImplementedError("Not implemented on backend" + type(self).backend)

    def row(self, vertex):
        """Returns the row that the vertex is positioned at. 
        If no row has been set, returns -1."""
        raise NotImplementedError("Not implemented on backend" + type(self).backend)
    def rows(self):
        """Returns a mapping of vertices to their row index."""
        raise NotImplementedError("Not implemented on backend" + type(self).backend)
    def set_row(self, vertex, r):
        """Sets the row the vertex should be positioned at."""
        raise NotImplementedError("Not implemented on backend" + type(self).backend)

    def set_position(self, vertex, q, r):
        """Set both the qubit index and row index of the vertex."""
        self.set_qubit(vertex, q)
        self.set_row(vertex, r)

    def vdata_keys(self, vertex):
        """Returns an iterable of the vertex data key names.
        Used e.g. in making a copy of the graph in a backend-independent way."""
        raise NotImplementedError("Not implemented on backend" + type(self).backend)
    def vdata(self, vertex, key, default=0):
        """Returns the data value of the given vertex associated to the key.
        If this key has no value associated with it, it returns the default value."""
        raise NotImplementedError("Not implemented on backend" + type(self).backend)
    def set_vdata(self, vertex, key, val):
        """Sets the vertex data associated to key to val."""
        raise NotImplementedError("Not implemented on backend" + type(self).backend)